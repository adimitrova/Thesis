[sound]. 
okay. 
so as you know, we were just talking to 
martin, and he was telling us a bit about 
rjdj. 
we've heard from marko. 
marko's been telling us about how to use 
sliders. 
and we've also done some stuff last week 
on sliders and building them and stuff. 
and, you know, matt's been doing this 
stuff with you about, playing back sounds 
in rhythm to a sequence. 
so, what i'm doing is i'm going to show 
you an application that we developed, i 
just briefly touched upon with martin. 
i'm just going to i'm going to set it 
running again for you. 
but i want you to just kind of pay 
attention to the little things i do. 
as i'm doing them, i'm going to briefly 
explain what they are, then i'm going to 
go through the whole application in 
detail. 
explain how it works. 
then we're going to discuss it with me 
and marco and matt at the end just so 
that we can make sure we've got 
everything covered. 
this is like a fully fledged music 
application. 
it's sonically quite advanced. 
it's just bare minimum on the user 
interface, it just has the interaction, 
so you could use quite a lot of the 
techniques that are in this to make your 
own thing. 
but let's just see what it sounds like 
again and see where we, we are with it. 
[music] okay, here we are. 
so you can hear we've got a drum machine. 
let's just turn the two synths down, so 
we can hear these these, these drums 
here. 
we've got a bass drum, we got a snare 
drum and you can see, i'm pointing at a 
snare drum hit. 
[music] that one and that one. 
and there's a blue line that tracks 
across telling us where in a drum beat we 
are. 
the second line in the drum, in the drum 
machine is this. 
you hear that? 
that's the 
[inaudible] 
the clap. 
so the claps going on the in between 
beats in between the base and the snares. 
you got a classic techno feel. 
and as matt was saying all of the sounds 
we're using come straight from your 
standard kind of 808 or 909 drum machine 
and thereof [music] so, what else can it 
do? 
well, we've got two synthesizers. 
we can play these [inaudible] 
synthesizers individually, and we can 
vary a whole range of parameters for 
them. 
they're fully fledged synthesizers. 
we can write waveforms for them. 
if you're interested in synthesis and you 
know a little about it i think you'll 
find this one interesting. 
but if you don't, it's still really 
usable and i need you to get your head 
around it. 
we can write waveforms, we can add a 
filter, we can change the quality of the 
filter. 
now let's just have a listen to the 
filters, i'm want to turn one of them up. 
[music] so here's one of the synths. 
i'm going to change the filter. 
[music] [music] i've also got this 
resonance. 
and this filter out. 
we could also change the release and the 
attack. 
so we're giving it an envelope. 
and it creates that kind of acid techno 
feel. 
if i change the attack actually with 
something like this. 
[music] just makes it quieter. 
we can transpose any of the channels. 
so i'll change the key of the entire 
sequence. 
and then again. 
and then if i want [music]. 
you just go back to where you were, more 
or less. 
and also, i can add some delay. 
[music] and i've got a second one here as 
well. 
now, the beat that i'm altering at the 
moment is the actual [music] [inaudible] 
sequence of notes that it plays. 
now, i can select a sequence of high 
notes, like this, or a sequence of low 
notes. 
and just like in the example that matt 
was showing you [inaudible] [music] drum 
machine. 
there's 16 steps, so i can change two of 
the notes. 
there you go. 
i've got the fill trap as well and i'll 
do this stuff. 
[music]. 
that's quite pleasant. 
we have resonance. 
[music] that's distorting quite a lot. 
i don't really mind. 
i can add some more delay. 
[music] add a few claps. 
[music] and some more snares. 
maybe a cymbal. 
[music] 
you gotta take, 
so that's a basic music machine. 
[music] it's a common thing that you can 
easily sell on the upstart for, i don't 
know, actually music apps. 
let's talk about this for a minute. 
music apps go for quite a lot more money 
than other kind of apps. 
you can sell an app like this for much 
more than three quid on the [inaudible] 
on the ios app store. 
you can probably sell it for five to six 
pounds or more. 
or if you're in america, that would be 
dollars. 
i imagine that like $8 or $9 out of 
[inaudible], what is, what are pounds and 
dollars anyway? 
who cares? 
anyway, they're much more expensive and 
they're much more specialist but they're 
still they're still really useful. 
and i think something like this, i mean 
as something really famous, well, there's 
a really famous [unknown] app which is 
built on, based on a and old-fashioned tv 
r3 synthesizer and a nice [inaudible] 
drum machine in which still sells in it's 
droves. 
and all the people do is complain about 
how unusable it is. 
so i'm not that worried that ours is 
knocked out quite quickly. 
it is knocked out quite quickly, but it 
is powerful, and you can build on it to 
do more interesting things. 
and you could use some of the other stuff 
we've done to play some loops. 
by there are some complexities to this 
and i want to show that you know, what 
they are, so i'm going to quit this 
temporarily and just go back to the basic 
version before i continue with that. 
just see you can see in the most simple 
possible way what it is that we're doing. 
so you go all this stuff for free as i 
was describing before. 
as i've said every week, you know, you 
can just go to your lessons. 
but this time we're in week six. 
week six has got a bunch of small tests 
in it. 
it's got a small drum machine, and t's 
got this thing called synth test. 
so, we're going to have a quick look at 
this synth test. 
just because it's a easier code to, to 
look at. 
it's got the gooey code in it. 
it doesn't have the drum machine it just 
has one synthesizer. 
and yeah. 
there you go. 
it's just one of the synths. 
[music] [music] now, [cough] so you can 
see here it's the same, and it basically 
allows me to set the pitch, change the 
filter, change the resonance. 
same old same old. 
let's have a look at it. 
so we start off as we normally start off 
by declaring a maxim context. 
if i can just make this a little bigger 
so you can see. 
so this is what's happening on the audio. 
behind it, as, you know when martin was 
here we were talking about the web audio 
api. 
so, behind this is all web audio. 
and the maxim js, the maxim js file, 
which is here has got all of this stuff 
in the background. 
now, if you're interested in this sort of 
stuff, and you want to learn more about 
how we built max and js. 
you can always post questions on the 
forums. 
and the tas will manage those and any 
really important questions where we feel 
we've got some material we can really 
help you with we can point you towards a 
good answer. 
and also there are lots of other places 
like musicdsp.com and other sites like 
that can help you understand what it is 
that's gone into building this. 
but you don't really need to if you just 
want to get started. 
we just have to have a context, and maxim 
provides the context. 
also, we've got an audio file player. 
actually, we're not using that here, so 
that's not going to matter. 
instead of using the audio file player, 
which is what we've been using most of 
the time, we're using a synth. 
so, maxim can have a synth and i've 
called this synth waveform. 
now, the thing about a synth that makes 
it different to an audio file player is 
you can write in an array of values 
between minus 1 and 1. 
and that will define the texture of the 
sound which you're creating. 
now, most synthesizers have a number of 
different wave forms. 
and there's lot of different approaches 
to creating wave forms. 
um, [cough] and in one of the other 
examples that we've got in this folder 
there's a really easy way of gyrating 
wave forms but essentially, you're just 
writing numbers between minus 1 and 1 
into an array which is of a particular 
length. 
so we'll be talking about how to do that 
in a moment. 
so we have our synth. 
it's called waveform, and we're writing a 
waveform into it, which is what makes the 
sound. 
we've got a play head. 
now, the play head, as matt was 
describing, is, it's literally the thing 
which tells us how many, how many frames 
there have been. 
and we use that to work out whether we 
should trigger a new beat. 
okay. 
so we've also got, this array called 
notes, which is an integer array. 
and it holds midi notes. 
if you know about music, then you'll know 
what midi is. 
if you don't really know about music and 
music technology, you've probably never 
heard of it. 
it's called musical instrument digital 
interface. 
it's a specification. 
for a numbering system that relates to 
musical notes and musical information. 
so these midi notes normally what they 
represent are all the keys on the 
keyboard. 
they're 7-bit numbers, which means that 
they go for a range of 0 to 127. 
there's 128 independent values, the 
lower, the number, the lower, the note. 
so, i'm right down the bottom end of the 
piano, as you can see. 
with all these numbers, zero, zero, zero. 
12, 12, 12, whatever. 
okay. 
so, then we've got some float variables. 
fc, which is filter cutoff, resonance, 
attack, and release. 
and these are variables which i'm using 
to control the filter cutoff resonance, 
attack and release of my synth. 
this is my wave table. 
excuse me. 
this is my wave table. 
its an array and of float variables. 
like i said its going to be between minus 
one and one and its got four five hundred 
and fourteen elements. 
now the reason its got 514 elements its 
kind of complicated but its because of 
something called interpolate. 
very briefly what we need to do when we 
create that way-, when we create a 
waveform, is we need to make sure that 
that waveform can playback at various 
different frequencies. 
so it's sound is made up of lots and lots 
of different frequencies and we measure 
those frequencies in repetitions per 
second. 
or cycles per second, and the measurement 
value we use for that is hertz. 
so for example, if i take a sound, a very 
small snippet of sound and i repeat it 
more than 20 times a second we actually 
hear it as a pitched note, because it's 
repeating so fast. 
and that's what we think of, we think of 
music. 
most people just think about pitched 
notes. 
so, in order to be able to have a, a wav 
form which can be played back at 20 
hertz, or at the oth- -- at the other end 
of the scale 20,000 hertz, which is about 
the highest, frequency that we can hear; 
in fact, i can't hear 20,000 hertz. 
what -- who'm i tryin' to kid? 
as you get older, you can't really hear 
up there. 
i probably can hear about 18,000 hertz 
or, if i'm on a good day, with a good 
wind. 
so, in order to be able to do that, to go 
between a very low frequency sound and a 
very high frequency sound, we need to 
interpolate. 
to make the interpolation work, i.e. 
to make up the numbers that we need. 
because that's what interpolation means. 
it means we're making up numbers that 
aren't there. 
what, because we changed the playback 
rate or the waveform, to make up those 
numbers, we need some spare numbers on 
the end. 
so it's, normally you have a 512 point 
buffer, it's called a 512 point buffer 
because it's, it's, that's the number of 
points that you run through to make the 
sound. 
but where you've got a couple of extra 
points on the end, and we're using those 
for interpolation. 
so that's the reason why it's 514. 
okay, so there are out setup options 
sorry, they're not our setup options, 
they, they are basically our 
declarations. 
we are declaring all the objects that we 
need in order to make this program work. 
and then what i'm doing is i'm going into 
the setup function. 
i'm just declaring a size. 
i'm creating a, i'm calling new on my 
maxim object, and that means i'm setting 
up my context. 
and then i've gone [cough] done, done the 
same thing to my wave form objects. 
i'm, i'm creating new synth. 
so the synth is got a, a waveform in it, 
which is waiting to be populated with 
something with numbers. 
and it's also got all the other stuff 
that we need delays, filters and that 
kind of malarkey. 
then we're setting up my sliders. 
this is the same as the way marko showed 
you to do his. 
i've got this, which is delayed time 
that's dt, dg, which is delayed amount or 
delayed game. 
a, which is attack. 
r, which is released. 
f, which is the filter cut off. 
and q, which is the filter q, which is 
the resonance, which is what makes it 
sound, sort of acidy. 
so, there are the sliders that we need. 
and then i have another multi-slider, 
which i'm using to enter the notes. 
so you can see here, mark has explained 
to you how the multi-slider works. 
seq is also, that's a sequence. 
it's a, basically it takes an array. 
it takes the array notes. 
and then it, it fills that array whenever 
i interact with the multislider. 
okay. 
so i then, i'm loading a file which i'm 
not using. 
so actually [sound] we don't need that. 
frame rate is 30. 
the frame rate is roughly the speed of 
the tick rate. 
just like matt explained. 
but instead of running through those 
ticks, and using them to trigger drum 
sounds, although we do that in the more 
advanced example. 
in this example, we're just going to use 
it to select a note from our note array 
and use it to set a frequency for our 
waveform generator. 
okay. 
so, before we do any of that, we're still 
in setup. 
and you see the section here that i'm 
highlighting? 
this is me generating a waveform. 
so we know that our buffer is 414 points 
long so. 
we want to fill the array, which is 414 
elements long with a bunch of numbers 
between minus one and one. 
[cough] now, i'm going for a sorptive 
wave here so, i actually want the 
waveform to be 512 points, as i've 
explained, but with a couple of extra 
points for good measure. 
so, what i'm doing is i'm taking the 
value, i, and i'm dividing it by 512 to 
make a value between zero and one. 
and then i'm subtracting 0.5 to make a 
value between negative 0.5 and 0.5. 
now what actually happens when i do that 
is i, i make a ramp, you know, it's as 
if, if you imagine that's my array, the 
ramp goes up like this, so it's kind of 
an inverted sawtooth wave. 
and as it repeats, it drops down, goes 
back to the beginning, goes up again, and 
this produces a nice harmonic spectrum 
that we can filter. 
it's a very simple waveform, but it 
creates all these harmonics and, it 
pretty much creates every harmonic that 
we need. 
and then, we filter those harmonics out, 
and add the resonance for that acid 
sound. 
but the values, the actual amplitude is 
only for minus, naught .5 to 5. 
that's absolutely fine. 
it's, it's absolutely fine. 
we could double it, but then we'd get 
more distortion. 
and you can hear that you know i'd have 
to do more work balancing this out so 
it's just to keep the sound within a 
reaonable range. 
so then i make the, the waveform and then 
i add it to my synth which is called 
ironically enough or confusingly enough 
waveform. 
so i can set the wave table size i could 
set it to any amount i like that we've 
already discussed it's going to be 514. 
and then i load my wave table. 
in. 
wave form load wave table wave table. 
and then it's wave form dot play. 
so, that means i've initialized my 
synthesiser. 
i've loaded a wave form. 
i can change that at any time, any way 
that i like. 
so you could have 10 different wave 
forms. 
you could have really long wave forms. 
you could take a picture of your face, 
analyze all the pixels, and then use that 
as a the waveform it's entirely up to you 
it's just an array of numbers. 
so you know be creative and then i'm 
pressing play what that really means is 
it's on. 
so ready to rock. 
in the door method we're doing the same 
stuff that marco explained. 
we are [cough] setting up our sliders 
then we get our slider information in the 
draw method. 
so, if f get, basically if we get 
something from the frequency slider, we 
set the filter that belongs to the wave 
form object. 
and if we get delay time, then we set the 
delay time. 
yes unless i'm munging i'm dividing it by 
fifty just to get it into a decent range. 
the same thing to delay gang get and to 
the huge get. 
a get and r get. 
lot's of good gets. 
because we are in the draw method that's 
a good place to set the display. 
so we display everything. 
and then we do the business end, which is 
ticking through the array, which has the 
notes in, and using that to set the 
frequencies. 
so, playhead ++, every time we enter the 
draw loop, we iterate the playhead. 
so the tick rate is different to the rate 
of actual playback. 
the tick rate is quite fast, it's 30 
frames a second. 
we could have 60 or 120. 
it can be quite fast. 
and a tick rate's normally much much 
higher than the rate of the rhythm. 
so what i've done is i've just said, 
okay. 
well, every four ticks. 
we'll say that's a semi quaver, which is 
a. 
small chunk of a beat, it's a quarter of 
a beat, so f play had modular four equals 
equals zero just the same way matthews 
already showed you. 
wave form.ramp, we ramped a [cough] 
knot.5 which is going to be our volume 
given the attack time... 
yet. 
and what that does is it means that, if 
the attack time's long, it'll be a slow 
ramp. 
and if the attack time, attack time is 
fast, it will be a short ramp. 
and then, following a ramp, we set the 
frequency. 
wave form set frequency. 
now, we're using this thing, m2f. 
now what this does is it takes midi notes 
and turns it into frequency information. 
and this is just looking up an array, 
which is a maxim j s here. 
so it's saying okay, if i get a, a number 
zero, that's going to be a midi note of 
zero. 
if i get a number one, a midi note of 
one, that's going to be a frequency of 
8.661957, which we'll never hear. 
but i generated this with an algorithm. 
and i just pasted it in, because it saves 
you having to worry about it. 
okay? 
then we access notes. 
we get the play head modulo 4. 
sorry, play head divided by 4, modulo 16. 
that's basically saying, okay. 
we've had ticks, that's fine. 
but this is the note we actually want. 
and then we're adding 30, which is a 
constant, which is just, so if it was 
zero, then it would actually be 30. 
so finally what we do is the next ti, 
tick we release. 
so immediately we release before we then 
retriever. 
so if player head module [inaudible] 
equals equals one we trigger the release, 
and then we're off. 
there are better ways of doing this, but 
not using processing. 
okay, so as you can see, we've triggered 
our sound, we've set the note for this 
particular tick and we've released it. 
for the following notes, the following 
tig. 
so the next thing to do is to sort out 
the interaction. 
when mouse pressed, what we do is, we 
just get the user interface stuff, and 
that handles all our mouse pressed gui. 
dt mouse pressed, dt mouse pressed, blah. 
same thing in mouse drags so that's 
useful for mouse devices. 
and in mouse release we we just check one 
thing. 
we check to see if the notes have changed 
in the array that holds all the notes. 
and if they have, then we just populate 
the sequence sorry, we populate the notes 
array with the new sequence that's in our 
sequence similty slider. 
and that's what this does, so notes i, 
which is the current note from 0 to 15, 
so there's 16 different steps, we flaw 
this value basically. 
so we get the sequencing value. 
and then there's a bit of [unknown] to 
make sure that it's the right value and 
we stick it in there, make, we basically 
convert it from the slider value to a 
mini value. 
we could have used the map function to do 
that, which would have been easier to 
read. 
but instead of using map, i'm just doing 
it with standard mathematical operators. 
right. 
now that actually is that, is that first 
test. 
so let's just go back and have a look. 
[music]. 
yeah, that's nice. 
and here's the delay time again. 
[music]. 
[sound] i wanted to just talk briefly 
about the filter because the filter is 
quite is, i don't know, it's nice to 
think about what the filter actually 
does. 
i've already explained that we have a 
wave form and it goes at a certain rate. 
it give us lots of harmonics. 
and then we use the filter to block them. 
but how that process occurs is kind of 
interesting. 
basically what the filter does [sound] is 
it, it lets everything through [sound]. 
let's just get a single note [sound]. 
it lets everything through when it's wide 
open. 
[music] and as we drop it, what it's 
actually doing [music] is this preventing 
the weight form from moving very quickly? 
the filter basically is averaging 
smoothing out the weight form/g. 
the weight form remember is like that. 
and it's going really really fast. 
lets say it's going a thousand times a 
second. 
and it's producing all of these harmonics 
which are. 
two thousand, three thousand, four 
thousand, five thousand, six thousand, 
seven thousand, eight thousand, et 
cetera, times per second, with an 
altitude drop-off. 
and that's making a very bright sound. 
that's making that buzz, that nice, 
buzzing sound that we, we like. 
well, i'm assuming you like that. 
if you don't like that [music]. 
that then tough, 'cuz that's the sound it 
makes. 
but the thing is that when we repeat it 
over and over and over again., we're, 
actually, when we get to the end of the 
route, and we drop down again. 
that's actually quite a fast move. 
and that's what creates all the 
harmonics. 
if we smooth that, it prevents the 
harmonics from being generated, and it 
smoothes filters out that sound, so what 
we're actually doing is we're averaging 
the signal as it goes up, kind of. 
and that's fine because it's a slow 
increase, but then when we get that 
sudden drop, we smooth it in the same way 
we might blur an image. 
and that's more or less how we turn high 
frequencies down. 
so, it's really simple and if you're 
interested in that process. 
there's a number of filters that come 
bundled with the course air package that 
we've put together for you. 
and they run nicely on android as well, 
so you want to have a look at those, 
they're in the android package and 
there's 4 or 5 of them. 
and you can actually see the algorithms 
if you're interested, you can have a look 
at them. 
alright, so that's how the synthesiser 
works. 
now, finally, what i want to do is go 
back to our, 
a more complex example that combines all 
the bits together and just talk about how 
that tinal thing wor, works. 
just a few little things that make it a 
bit more useable. 
so i'm going to go back to our music 
machine example which is here and i'm 
going to run it and what's going to 
happen is. 
[music] it started up straight away 
[cough] and it's distorting beautifully 
really not bad. 
there's very little i have to do now all 
of it [music] make music. 
let's have some bass drums. 
i do like a bit of bass drum, can you 
hear the bass drum? 
you can just about, let me knock this one 
out. 
okay, that's good. 
it's quite hard to use that. 
you could have a nicer keyboard setting 
or something like that. 
[music] so let's have a look at what 
we've done to put the main application 
together. 
so, we've got two synthesizers. 
now there's a clever way to do this and 
there's a stupid way of doing this and 
just to make your life easier, i've done 
it the stupid way. 
instead of creating an object or a class 
which is a synth although i've already 
done that behind the scenes anyway. 
but instead of doing that, just so it's 
clear and you can see how it's done, i've 
just duplicated all of the codes. 
there was actually two sets. 
a brighter, cleverer, more engineering 
savvy method is to make another class 
that encapsulates all of the sliders. 
and then just to create one of those 
objects and to say where you want where 
to put it, so that's something we should 
have a look at. 
there's a good example in all of the 
current examples that we've given you, 
there are good examples of classes, and 
you should have a look at that those. 
but i didn't want to do that and find 
that no-, that some of you didn't really 
understand that whole process. 
so i've just gone through and i've 
duplicated all of that code. 
so basic stuff is i thought well i want 
it to look slightly better than it 
currently looks so i've created a brushed 
metal background. 
i've positioned all the sliders on the 
screen and then i've created this brushed 
metal background and you see that this is 
a good tip. 
if you can avoid havong to draw 
non-animated information. 
via algorithmic methods, i.e. 
if you can avoid having to apply the 
interface graphics, do avoid it. 
make a photoshop image that has your 
interface. 
so i've got a slightly embossed area here 
and here which these are the panels that 
hold the information and if i spent more 
time on that i can make them look really 
nice and i've fake knobs and switches 
that i copied and pasted of the internet. 
or i could photograph my something from 
my set connection and then put those on 
them instead. 
but i guess what i'm trying to say is you 
can do an awful lot by preparing your 
images in photoshop just like we did last 
week with the instaspan for the overlay. 
it's the same sort of thing. 
put the effort in there if it's not 
going to animate. 
put the effort in in photoshop, make it 
look sweet, and then draw it. 
i must admit i've not really put the 
effort in here, but there's a back, 
there's a basic starting point. 
you can see where the panels are; they're 
sort of lined up. 
another thing you can do is you can put 
your interactive graphic elements onto 
your screen so that you do that 
problematically then you screenshot it 
the right size and move that into your 
photoshop application and then you can 
draw on top of it. 
i guess it's what i'm saying is do the 
work in photoshop is you're not going to 
have to animate it make it look nice 
there. 
we did exactly did the same thing with 
angry droids as well we just do a bit of 
support work there. 
so that's the basic idea, and you can get 
away with a lot there. 
also it's nice to add custom graphics to 
your sliders, and you can do that too. 
so, we've done that. 
and then we've loaded it in here. 
and then we've done the same thing, exact 
same thing that matt did for the drum 
track. 
we created four boolean arrays. 
track, 1, 2, 3, and 4. 
these are for our four drum sounds that 
were in our drum machine, which is a 
kick, a snare, a handclap, and a cymbal. 
ideally, i'd have a hi hat. 
there is a hi hat knocking around in one 
of the, folders on the coursera pack that 
you've got. 
and you can see here, exactly as i said, 
i just duplicated everything. 
so there's the floats that you've already 
seen. 
except we've added another function, 
filter attack, which is what gives it 
that sort of tb 303 baseline sound. 
[laugh] allegedly. 
and then we've got, some transpose 
functions as well, which allows us to 
move it around. 
we've got a second wave table for the 
second object. 
you can see we've got two syns waveform 
and waveform two. 
and now these are all basically 
everything that has a two after it is for 
the second waveform. 
we create a bunch of secondary slide and 
sliders and multi-sliders to hold all the 
separate information and then we load in 
some samples. 
and then we set up a sliders, so we have 
twice as many sliders. 
but they have slightly different numbers 
in to re, to represent the fact that 
they're going to be drawn somewhere else. 
now as i said, you would draw them, 
screen shot it, import it into photoshop, 
do your background, and then just load 
the background. 
now so we load the background where do i 
load the background. 
into the bottom of this. 
that's the wavetable, exactly the same 
way as i described in the first example. 
okay the background is loaded, there it 
is, brushed metal, that's my brushed 
metal background. 
and then here, what i do is i set up the 
drum tracks in the same way that matt's 
already explained. 
i just create these boolean arrays, 
they're either true or false. 
and i set them all to false, so they're 
all off. 
okay, and then we get all the information 
in exactly the same way, as we did 
before. 
and then we use the same playhead 
information to get the frequency content 
for both synthesizers. 
and then we use another variable, current 
b, so we could use playhead if we're 
using current b too. 
it doesn't really matter, it's the same. 
to find out whether it's if it's true 
basically, then what we do is [cough] we 
play that drum sound back. 
the mass press stuff is exactly the same, 
if you click there it sets it and, you've 
set it to play. 
in both mouse press and mouse drags. 
and other than that, it's exactly the 
same as the two examples you've seen. 
the basic synth example, and the drum 
example. 
and that's how you end up with this. 
[music]. 
[music] 
