[
sound
]
.
hello
.
so
you
just
heard
about
how
you
can
use
a
physics
engine
to
control
the
movement
and
collisions
of
a
variety
of
objects
on
the
screen
.
what
we
're
going
to
do
now
is
,
is
look
into
a
real
example
where
we
develop
that
into
a
game
with
,
with
nice
graphics
and
sound
.
and
i
'm
going
to
begin
that
inspection
by
figuring
out
how
we
can
connect
sound
events
up
to
this
collision
events
that
we
've
seen
before
.
let
's
look
into
the
code
of
the
,
the
,
the
example
here
.
[
blank_audio
]
so
we
're
modeling
this
as
a
little
droid
character
that
can
be
bounced
around
the
screen
,
and
it
smashes
into
crates
.
so
,
we
got
[
sound
]
an
array
of
crate
uh
,
[
inaudible
]
crates
,
which
is
an
array
of
physics
engine
body
objects
.
so
these
represent
all
the
crates
that
move
around
the
screen
.
we
've
also
got
another
entity
which
is
a
physics
engine
circle
called
droid
which
represents
a
little
character
that
's
going
to
bounce
around
the
screen
.
finally
,
we
've
got
these
walls
which
the
droid
might
bounce
into
and
also
the
crates
.
so
what
we
're
going
to
try
and
do
is
hook
up
the
audio
engine
so
that
every
time
a
collision
happens
,
it
triggers
an
appropriate
sounds
.
first
of
all
,
in
here
,
you
can
see
we
create
maxim
as
usual
.
and
then
,
we
've
got
two
audio
players
,
so
let
's
just
look
at
the
variables
up
at
the
top
there
.
so
these
are
all
the
audio
variables
.
it
's
all
we
need
.
[
sound
]
we
've
got
no
maxim
,
we
've
got
two
single
audio
players
,
and
then
we
have
an
array
of
audio
players
.
as
i
said
earlier
,
we
had
this
array
of
crate
and
body
objects
.
so
for
each
of
those
crates
,
i
'm
going
to
have
an
individual
audio
player
,
so
that
will
allow
me
to
simultaneously
play
sounds
for
all
of
the
creates
.
so
you
can
hear
all
of
those
creates
hitting
each
other
at
the
same
time
.
then
we
need
a
single
sound
for
the
,
for
the
droid
,
because
there
's
only
one
of
those
in
the
screen
,
and
then
a
sound
for
the
walls
.
okay
.
[
blank_audio
]
here
,
we
basically
load
,
load
a
file
,
which
i
prepared
earlier
.
and
then
,
another
files
.
i
've
got
droid
sound
and
a
wall
sound
.
the
droid
sound
is
kind
of
funny
vocal
sound
that
i
made
and
the
,
the
wall
sound
is
a
clanging
metallic
sound
.
you
'll
hear
them
shortly
.
and
then
i
tell
them
both
not
to
loop
[
sound
]
because
their
one
shot
sample
,
the
[
inaudible
]
,
the
20
play
all
the
way
through
once
and
then
stop
when
,
when
,
when
a
collision
happens
.
next
,
i
create
the
array
of
crate
sounds
.
so
,
they
're
,
they
're
again
,
they
're
just
all
audio
players
,
but
they
're
stored
into
an
array
,
so
it
's
more
convenient
to
work
with
them
.
and
we
use
the
same
method
and
we
load
a
[
unknown
]
file
into
each
one
.
now
,
it
's
worth
noting
here
that
,
that
we
're
actually
going
to
store
that
copies
about
[
inaudible
]
file
data
but
we
need
to
do
that
,
so
that
we
can
playback
easily
and
with
several
the
same
time
.
so
we
load
that
file
up
and
got
all
those
[
inaudible
]
.
we
tell
them
up
to
mute
either
.
the
next
thing
is
we
hook
up
the
collision
function
,
which
marco
mentioned
earlier
,
which
cool
every
time
a
collision
happens
between
two
of
the
,
two
of
the
objects
in
the
physics
world
.
so
collision
is
called
.
it
tells
us
that
two
objects
have
collided
and
it
tells
us
how
hard
they
hit
each
other
if
you
like
.
so
let
's
just
have
a
look
at
that
function
down
here
.
so
here
.
[
sound
]
we
've
got
the
,
the
[
inaudible
]
two
bodies
coming
in
,
which
are
the
two
colliding
bodies
,
and
then
we
've
got
the
strength
of
that
collision
.
and
we
've
got
some
logic
here
,
which
basically
decides
whether
there
should
be
a
score
or
not
.
and
mick
's
going
to
talk
a
little
bit
more
about
that
later
.
but
then
,
here
's
the
logic
that
decides
when
to
play
sounds
.
[
sound
]
so
,
first
of
all
,
the
first
trick
is
that
we
know
that
the
walls
have
a
zero
mass
.
the
walls
are
set
up
having
a
zero
mass
.
so
in
order
[
inaudible
]
to
figure
out
whether
one
of
the
bodies
that
's
been
hit
is
a
wall
,
we
just
test
the
two
bodies
.
so
we
say
b1.getmass
,
that
will
tell
us
the
mass
.
and
we
test
if
it
's
equal
to
zero
.
so
if
b1
is
equal
to
0
mass
,
that
means
it
,
it
's
wall
,
because
the
walls
are
the
only
things
with
zero
mass
.
and
then
if
b4
,
we
got
this
double
bar
side
here
,
which
means
all
,
so
if
b1
or
b2
have
zero
mass
,
it
means
at
least
one
of
those
things
that
's
just
collided
is
a
wall
.
and
that
means
we
're
going
to
trigger
the
wall
sound
.
so
you
can
see
we
cue
the
sound
up
and
rewind
it
to
the
beginning
.
and
then
,
we
set
the
speed
on
the
sound
.
so
we
're
actually
going
to
make
the
sound
more
dynamic
by
assigning
a
speed
based
on
how
hard
that
,
that
thing
hit
the
wall
.
so
if
it
hits
the
wall
really
hard
,
it
will
play
the
sound
faster
.
so
it
will
be
a
high
pitch
sound
.
if
it
hits
it
slower
it
's
,
it
's
,
it
's
a
low
pitched
sound
,
which
kind
of
makes
sense
because
it
,
it
's
this
idea
that
the
sound
plays
more
slowly
with
a
slower
collision
.
and
,
finally
,
we
play
.
notice
i
'm
scaling
the
,
the
impulse
into
a
range
of
zero
to
one
there
.
because
that
,
the
impulse
comes
in
,
can
be
quite
high
value
.
so
it
's
,
i
,
i
,
i
did
a
lot
of
tests
and
they
come
in
the
range
of
100,000.
so
i
'm
just
scaling
it
down
with
that
.
so
again
we
,
we
,
we
've
got
this
thing
where
you
've
got
different
types
of
data
coming
into
your
,
your
code
and
you
need
to
know
what
kind
of
range
that
data
is
in
,
and
then
you
can
scale
it
into
a
range
that
's
appropriate
for
parametizing
audio
and
parametezing
graphics
.
so
lot
of
the
tricks
and
how
to
make
things
work
properly
is
all
about
knowing
what
range
or
numbers
you
're
dealing
so
with
the
accleratometer
what
range
of
numbers
do
it
generate
.
with
the
physics
engine
what
range
of
number
does
that
generate
and
being
able
to
correctly
scale
the
numbers
to
map
to
other
things
okay
so
the
next
bit
of
logic
.
there
's
a
quick
test
to
see
if
either
the
things
are
the
actual
drawing
object
,
so
if
we
've
[
unknown
]
the
droid
that
means
we
've
triggered
the
droid
sound
.
so
we
queue
it
up
and
again
set
the
speed
in
the
same
way
and
then
hit
play
.
and
then
find
with
that
logic
is
which
of
the
crate
sounds
need
to
be
played
.
okay
.
so
,
this
loop
here
is
the
same
four
loop
we
've
seen
a
few
times
now
.
which
loops
through
the
array
of
crates
.
and
tests
each
of
the
,
the
bodies
that
have
come
in
.
so
the
,
b1
and
b2
are
the
two
bodies
that
have
collided
.
we
want
to
check
if
either
of
those
is
one
of
this
,
is
one
of
those
crates
.
if
it
is
,
then
we
cue
it
up
,
and
trigger
it
.
and
i
've
done
a
bit
of
fine
tuning
here
.
i
've
got
10,000
here
instead
of
100,000
because
i
found
that
the
crates
in
this
game
tended
to
collide
more
slowly
than
other
things
.
so
i
've
kind
of
scaled
down
the
,
the
,
the
number
there
a
bit
to
reflect
that
.
so
again
,
it
's
a
bit
of
tweaking
.
it
's
not
always
super
precise
.
it
's
about
playing
around
with
it
and
tweaking
it
so
it
works
how
you
want
.
okay
,
so
the
speed
is
set
like
that
.
so
a
slightly
different
way
of
setting
the
speed
.
finally
i
'll
play
it
,
okay
,
so
now
what
we
're
going
to
do
is
just
run
this
on
the
android
device
.
and
,
you
'll
be
able
to
see
and
hear
it
.
that
's
just
building
now
.
so
i
just
lift
it
up
so
everybody
takes
the
screen
,
because
this
one
works
in
okay
,
so
there
's
my
boyd
.
mick
is
going
to
talk
to
you
more
about
the
graphics
and
how
to
make
those
really
good
.
but
at
the
moment
,
i
'm
just
,
just
worried
about
the
sound
.
so
,
if
he
,
if
he
hits
the
walls
,
[
sound
]
[
inaudible
]
that
's
the
crates
colliding
.
so
that
metallic
sound
is
,
is
,
is
the
,
the
wall
sound
.
and
then
the
tappy
sound
is
the
crates
colliding
.
so
you
can
see
if
he
hits
the
wall
really
fast
,
if
i
fling
him
against
the
wall
,
[
sound
]
[
inaudible
]
[
sound
]
.
okay
.
one
more
into
the
wall
,
just
to
demonstrate
that
.
[
sound
]
[
sound
]
.
>
>
sounds
pretty
good
.
[
music
]
