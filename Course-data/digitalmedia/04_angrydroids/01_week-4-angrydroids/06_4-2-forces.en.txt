[NOISE] So, we've talked about objects. 
The, the things that affect objects may move other forces. 
I'm going to talk about a couple forces that we'll work with. 
The first force is the pervasive gravity. Basically we're always going to have 
force downwards that pulls objects down. Doesn't have to be downwards you can 
actually set gravity to move to the left or even 0 if you want a space world. 
But most of the time you're going to have a force pulling things downwards. 
And that's automatically built into the worlds. 
So, you don't have to do anything to get gravity. 
You can use the Set Gravity commands to change the gravity force. 
It's a vector. So you can have, at the moment, gravity 
is something like 0, minus 10. 0x minus 10y so it's, vertical, but you 
can have horizontal gravity if you give it a, an x value. 
Another kind of force is an impulse. That's basically a force that's applied 
at a particular moment in time. So, sometimes you just want to push an 
object in a certain direction to get it moving and applying impulses is a good 
way of doing it. It's just applied for one moment, just 
like kicking an object. This is how you do it. 
An impulse is a vector. You create a new vector with whatever 
values you want so that you'd call new Vec2. 
That's a vector type. And you pass in the x and y coordinates 
of that vector. It's actually a direction. 
Say 2, 4 where we mostly vertical, we mostly downwards with a bit across. 
And then you call the Apply impulse command on the box. 
So you do box.applyimpluse and that applies impluse to that box. 
You pass in you have to say where the impulse is acting on. 
So you can apply an impulse to different bits of the box. 
Often you just want to apply to the center of the box so it's not going to 
spin around. But if you apply it to the edge of the 
box, you, bo-, box won't just move, it will also spin around. 
And then you obviously have to apply past the impulse into that function. 
I'm going to show a bit more of a complex example that Mick will be following up 
later and in, in, in the code he's going to show you. 
[COUGH] Of how to implement a catapult. So we've got a ball that's on a piece of 
elastic and when we pull that ball, the further back we pull it, when we release 
it, it will fly in the direction that we've been pulling back. 
So the two things we need to know will fly in the direction of the elastic. 
But, the more we pull the elastic back the further it will fly. 
So, it depends on both the distance and the direction from the catapult to the 
ball and what it produces is an impulse that's applied to the ball. 
So that impulse, if you remember what I was saying about vectors earlier. 
Is based on the vector that goes from the ball to the catapult. 
It's in that direction, then the more that the growth of distance is, the 
bigger the force is going to be. That's fine, because that vector includes 
that. So the vector from the ball to the 
catapult is simply catapult minus ball. The catapult is the vector position of 
the catapult. Ball is the vector position of the ball 
and we multiply that by constant c. just so, you know, just so we've got a 
bit more control about how big that impulse is. 
So we can vary that to make it a bigger force or, or a lesser force and just 
tweak it again. When you, when you're working with 
physics again there's a lot of tweaking to do to make sure that all the densities 
and the, the, these constants are right. Just get the right feel that it's moving 
at the right dynamically enough without things going all over the place. 
So, if we look here how we do the calculation we create first an impulse 
vector. That's a vector. 
We set its value to be equal to the position of the catapult. 
Then we subtract off the position of the ball. 
And finally, we multiply by a constant, in this case, 200, quite a big number to 
get a quite a dynamic move. And we'll see that later in the example 
that Mick's going to show you. The final kind of force, and maybe the 
most important one for physics engine is collisions. 
A lot of what a physics engine does is handle when objects collide at each other 
and bounce off. And gets that, those collisions 
absolutely physically correct. And, you see in example, we've got 
objects bouncing off crates, and then objects bouncing off the sides of the 
screen, stuff bouncing everywhere and that's all handled by the physics engine. 
Um, [COUGH] in a, in a sense, you don't really need to do anything. 
to handle collisions the physics engine will do everything for you. 
But sometimes you want to know when a collision's happening. 
so, for example, you might want to, increase your score whenever a collision 
happens. And as, as Matthew would show you, you 
may want to you may want to play a sound whenever you have a collision. 
So you need to know when there's a collision. 
In the first extension we're using, we do this in a very simple way. 
You just create a function in your program called collision. 
That has to look exactly like this. It has to have collision. 
Takes three parameters. body 1 body 2 and the impulse. 
So the body 1 and body 2 are the 2 objects that are colliding with each 
other. And the impulse parameter is how big the 
force or the impulse of the collision was. 
So that's really useful. You can find out which objects are 
colliding. So, depending on which objects there are, 
you can make different sounds. And you can make use of how big the 
collision was. So maybe if the collision was very small, 
you don't make a sound. Maybe with a bigger collision, you make a 
bigger sound. So, 
With those three parameters you can really control exactly what happens in 
your program when different collisions happen. 
And the next, Matthew will talk about how to create a sound engine which can 
produce different results, based on different objects and with, varying 
parameters of the sound, which is exactly what we need to change the sound whenever 
an impulse is played. Once he's done that, Mick will show you 
full example that has physics objects colliding all over the place and audio 
being triggered by those physics objects. [MUSIC] [MUSIC]