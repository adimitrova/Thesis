[sound]. 
hi so we've heard matt explain to you the 
wonders of audio recording and sound 
effects and how to synchronize it with 
collisions generated by physics engine. 
we've had marco explain the physic engine 
in which we're using that works in ios 
devices and also android and on the desk 
what we've done is we've tried to create 
a framework app. 
which is a basic physics game, 2d physics 
game. 
and they're really, really popular on 
handheld devices. 
really popular amongst casual gamers. 
so our template just gives you the bare 
bones for it you want to make a game. 
it gives you a physics engine. 
it gives you a mechanism for loading 
sound effects, and a mechanism for 
loading artwork. 
and you can easily make a game that, you 
can easily make a game with those 
components which is somewhat like angry 
birds, angry birds being the most famous 
physics-based 2d platformer on mobile 
devices, i should think. 
 >> which actually uses box2d, which is 
the same library we've been using. 
 >> yeah. 
 >> so you're using exactly the same 
physics engine, almost exactly the same 
physics engine that edward burns is using 
yeah. 
except you're using the one that we've 
hacked together, which may or may not be 
a good thing. 
with certain improvements. 
 >> yes, there's been some improvements 
made cross-platform and it should be 
relatively easy for you to use. 
so we've got this example. 
we're want to talk you through it. 
so you see it when [inaudible]. 
this is it running on an ios device. 
so you can see it's basically the same. 
you've got our little hero here. 
who is a he's basically tux, he's what 
linux users refer to as tux who is the 
symbol of linux. 
he's a penguin. 
he's not normally a really ugly penguin 
which does reveal a lot about linux. 
and he's wearing a little android head. 
and he's fighting [laugh] i can see 
[unknown] he's fighting these little 
boxes, he's trying to hit the boxes 
inside the crate with a bunch of apples, 
you can't see those that's more of a 
[unknown] thing. 
so it runs fine on the ipad device and it 
runs fine on your iphone. 
so let's have a look at this desktop 
version, this is it running on the 
desktop, it's basically the same. 
we hit the boxes, and we're off. 
so, we've got some artwork assets here, 
and then we've got a physics engine 
that's implemented that has a lot of 
complicated stuff that i'm going to talk 
about and also were going to talk about 
you know how the whole thing's put 
together so lets start with the art work 
assets. 
that will just take a small amount of 
time. 
you'll find in your coursera folder in 
week 4. 
 >> the basis of our game it's called 
angry drawings which we thought was 
funny. 
 >> [cough] at the time. 
 >> at the time. 
so yeah, basically, you can see in the 
data folder there's a bunch of different 
aspects. 
we have a ball which we're not currently 
using, we have a crate which is our 
mythical apple crate. 
and then we have this, these scrapyard 
backgrounds. 
and then we have our tux droid. 
and you'll notice he's a png file, so 
he's got transparent background, and that 
means that although he's a rectangle, 
when we draw him on the screen as you can 
see here, he's just the shape of a fluffy 
penguin. 
with an android [inaudible]. 
so we don't have any of those nasty 
rectangular issues, that's why he is a 
png. 
the background isn't a png, the 
background is just a jpeg so it's a 
compressed image. 
we've got two backgrounds, we've got this 
one which is nice and bleak. 
i don't know if you can see that. 
the bleak background, which you might 
want to throw in if you feel depressive. 
and then we've got the scrap yard. 
now in order to produce the kind of align 
the way you can place all of the objects. 
part of the scrap yard image has been 
grayed out and has been made a bit more 
muted in color. 
and then we've got a more colorful kind 
of ground area where we would place all 
the objects ideally. 
so we haven't actually got that many 
assets. 
we could easily introduce more assets. 
but that's enough for us to have a basic 
level. 
and you know, the dynamics of the game 
are you spring back, tucked, and you fire 
them at the boxes and then every time it 
hits a box, you score a point. 
[cough] that's a long way from a complete 
game. 
it's just to get you started. 
so in order to understand what's going on 
here let me talk you through this code. 
i'm going to ask some questions and 
marco's going to fill us in and then 
matt's going to fill us in on some other 
bits, too. 
fundamentally we've got a a base of code 
which works the same way on android as it 
does on ios desktop. 
so, we've got some stuff in here that's 
specific to one or the other platform. 
so here you can see we've got a bunch of 
import statements, and what these are 
doing is importing box2d, which is the 
library you were talking about before, 
marco, is that right? 
 >> yeah, that's right, so we're using 
an external library in order to implement 
physics engine and on java and android we 
need to import that live v using that 
code there. 
and with code you're running on 
javascript, that code just gets ignored. 
instead what happens is you'll see that 
on the other tabs we have a copy of ox 
td. 
we have a copy pf physics.js, which is my 
little wraparound /q ox td. 
 >> and the collision doctor detected 
objects which handles collisions and 
gives you a nice interface to create just 
a simple collision function that gets 
called whenever something collides. 
 >> so that's entirely running all of 
the physics that we see on the. 
 >> [inaudible] yeah, okay. 
all right, so as usual, what we've got 
here is a maxim audio context and then 
some audio players. 
these audio players are for the sound 
effects. 
right, matt? 
 >> that's right. 
so, we have one audio player for tux. 
so if tux hits anything he has his own 
sound. 
and then we have another sound for the 
wall. 
 >> so, if anything hits a wall, then we 
trigger a wall. 
it's kind of a metallic sound. 
the tux sound's a kind of ee sound, so i 
thought that was appropriate. 
 >> so, did you do that yourself? 
 >> i did it myself, and. 
 >> very good. 
 >> and, finally we've actually got 
something a bit more complicated for the 
crates. 
now when we're, we're playing around 
with, with one audio player just for, for 
all the crates. 
so we never have crate collided with 
something. 
we triggered the audio file but we found 
it was a problem because if there were 
several crates colliding at the same 
time, then they would keep retriggering 
the sound so you would only ever hear one 
sound. 
so i decided to create an array of 
players. 
one for each crate instead. 
 >> so what happens now is depending 
which crates collide though. 
they have their own sound player per 
crate. 
and i'll trigger it individually. 
 >> cool. 
and then, we also have a new object, 
which is called physics. 
and it's of type physics. 
so this is the main physics handler. 
 >> and this is basically what we're 
using to control well, what's making all 
of the physics this controls work, is 
that right? 
this is doing all the work. 
 >> yeah, that's right as i explained in 
my lecture the physics object is 
[inaudible] the whole physics world and 
it contains things like gravity and all 
that. 
you need to create it. 
you're going to need to create one 
physics world. 
a bit like you only need to create one 
maxim. 
 >> but you can create several bodies 
[crosstalk] so we call a body called 
boid, who's our droid. 
our angry droid, in fact. 
 >> yes, our [crosstalk] droid yep. 
 >> and, it's the [inaudible] and then 
we got a whole, array of other bodies 
which crates will [unknown] interacts. 
 >> so having an array you could just 
have lights with crates and crate hole. 
 >> and then we have a vector which is 
the start point, which we use to, set 
with a catapult is. 
 >> so that's the start point for when 
s, bring back, talks in the guy room, is 
that right. 
 >> yeah, that's right, that's where the 
catapult is. 
 >> okay, and then we have a collision 
detector, called detector, in which the, 
a, detection responds to collisions. 
 >> so that's basically what, a, detects 
the collisions and then calls the 
collision method. 
 >> that we'll see later. 
 >> right, then we have some 
initializers for these variables. 
crate size, which you can change if you 
want a massive crate bolt size. 
and then we have a bunch of images which 
we then pass into the physics engine and 
it then draws. 
we'll explain about how that works in a 
second. 
 >> score is initialized to zero and 
then we're currently not dragging what is 
that marker? 
 >> can you [crosstalk] that's just i 
need to keep track of when you're 
dragging the mouse because it's drawing a 
line that's sent to the catapult elastic. 
so whenever you're actually dragging with 
the mouse, you're dragging the 
[inaudible] will follow you around and 
you're pulling on the elastic and you 
need to see that elastic. 
that's all that's doing. 
 >> there are some really terrible jokes 
in this. 
i think, yeah, we'll just have to 
pretend. 
that they're funny. 
so you can see here that we have a size 
command. 
because this is the one that we're using 
for the ipad predominantly at the moment. 
this is 1024 by 768. 
but what we can do is set this to the 
size of an iphone screen. 
which would be 480 by 320. 
or if it's on android it we just comment 
it out. 
we're at 60 frames a second. 
and we load our images. 
the scrap yard is the background. 
the crate is the grate. 
the tux droid is our hero. 
image mode center, you know what that 
means. 
now, we get our physics objects and we 
initialize it with a width and a height, 
which basically says what the bounds of 
the world are. 
 >> so in this case, it's the same as 
the bounds of the actual screen. 
 >> i'd like to just say that i've put 
some comments after it, which gives 
another example of how you might want to 
do a more complex initialization where 
you can pass in values for gravity and 
here width over width times 2 height 
times 2. 
that's the overall world size. 
it's going to be bigger than the size of 
the, of the screen. 
and so you could have this more complex 
initialization which sets more values. 
most of the time you're not going to need 
that. 
 >> most of the time you should do this 
version. 
 >> so if you have a world size which is 
greater than the size of the screen you 
can have off screen objects which can 
float into the screen? 
 >> exactly. 
so objects can go off screen and not 
instantly sort of stop being stimulated. 
the world size, if something goes outside 
of the world size it stops being part of 
the physics simulation. 
 >> and then also you can have custom 
gravitiy so that you can. 
 >> yeah. 
 >> 
 >> have high gravity or have gravity 
that goes upwards [crosstalk] so the 
things can suddenly go up or suddenly go 
down. 
 >> yeah. 
 >> i always love it when that happens. 
well that's actually what happens in that 
kind of space version of that very famous 
physics game that we already mentioned 
far too much. 
okay. 
 >> so we've got a custom rendering 
method which i'll talk a little bit about 
this. 
this is something special about this sort 
of the way the physics engine works. 
now you can actually, if you don't do 
that, if you comment that line out, it 
will draw itself. 
it had it's own sort of renderer which 
will draw boxes for all the boxes and all 
that. 
which is quite useful when you␙re 
debugging or if you don␙t, haven␙t got 
your graphics in yet. 
but once you␙ve got your graphics in, you 
want to be able to control the rendering 
of all the physics objects. 
and rather than calling that in the draw 
method, the physics engine sets up a 
custom rendering method, which is the 
function mycustomrenderer. 
which we'll see later on, [unknown] does 
all the drawing of the [unknown]. 
 >> and that basically draws tucks, and 
it draws all the cranes. 
 >> yeah, that's right. 
 >> right, okay. 
so instead of having to draw methods, 
we've just got our own method, which is a 
wearable and a physical object. 
okay, great. 
and then we've got set density, which is 
how stupid i've. 
 >> [inaudible] no. 
 >> okay. 
how, what is that [inaudible]? 
 >> [laugh] it's it's basically, ti 
controls the mass of the object, so the 
density is mass divided by area, and that 
will, so the, the mass of an object, 
[inaudible]. 
how much it resists forces, how much 
force you need to actually push an 
object. 
is determined by how big it is but also 
the density. 
so if you set really high density, with 
quite a high density then the objects on 
is going to, are going to be quite 
massive. 
it's going to be a bit hard for me to 
move them around. 
if you set a really low density they're 
going to be floating around more. 
if you set the density to zero, can 
create objects that don't move. 
and that's quite useful. 
so if you want objects that don't, that 
don't move, set density equals zero, and 
then after that set density equals one, 
and you can create objects that do move. 
so you can change the density as you go, 
as you create different objects. 
 >> all right, so then we create seven 
new bodies, which are all our crates and 
then these are accessed as arrays, and 
then we create a [cough] rectangular 
body. 
and it has a position, which is its start 
position. 
a height a width. 
and what's this last one? 
 >> so that's, that is the, that's the y 
position. 
x position, y position. 
 >> y position. 
 >> width and height. 
 >> and i'm just using height because. 
 >> oh yeah, x1. 
 >> it's at the bottom of the screen, so 
it's just moving up from the height 
[inaudible] from the bottom of the 
screen. 
 >> okay. 
 >> so it's actually x position, y 
poition, the top left, x position, y 
position the bottom right. 
not width and height like like a 
rectangle. 
 >> yeah, so fundamentally, it would be 
much better if this was all done 
relatively to the screen width and the 
screen height in as in our week two 
example. 
 >> yeah. 
yeah. 
 >> that, we'll leave that up to you. 
so, yeah. 
so this basically sets up where the, all 
the boxes are at the beginning. 
it gives them an initial position. 
and then the start point, which is where, 
that's where the tux is connected to 
[inaudible] stuff. 
see i [inaudible] [inaudible] .and this 
is just where we put it. 
and then we just put that in a physics 
word. 
yeah so i'm converting to a physics 
coordinates. 
as i said in my lecture, we've got a 
different set of coordinates for the 
world, the simulation than you would for 
the screen and we want the start point in 
physics coordinates. 
so, the boid is circle rather than a 
rectangle. 
when we created the [unknown], those 
bodies, we used this rect, but for the 
android for the kind of angry droid we're 
using a circle. 
why's that? 
 >> well, because, well, first to say 
this is the example of the fact that you 
use simpler shapes for your physics than 
you would for drawings. 
so [inaudible] is quite a complex object. 
for the crates, the crated boxes, it's 
fine to use a box for the physics and for 
the graphics. 
but for [inaudible] it's a fairly complex 
object. 
 >> but you wouldn't want to simulate 
all the physics of his exact shape, 
because that would be. 
 >> yeah. 
 >> very [unknown] expensive. 
it would take a lot of time. 
so you have a simplified object, and you 
take the physics in that. 
so we're simplifying him down, he's quite 
rounds, we're simplifying him down to a 
circle from the point of view physics, 
and you see him as something a bit 
different from, in the actual graphics. 
so then we set up our collision detector. 
which is standard. 
we pass it to the phy, the physics word 
basically gets the collision detector. 
then we have our maxim context, which 
we've seen before. 
we load in our boid sounds, which is the 
sounds of tux hitting something. 
the wall sound. 
then we set them looping, all the stuff 
you've seen before. 
and then we have this for loop which 
loads over create sounds in. 
and that's the big array full of sounds, 
right? 
let you describe the array now. 
 >> that's correct. 
yes. 
 >> okay. 
and then we're moving to the draw method. 
 >> so whoo, we start our game, our 
first level of our game, that was quite 
intense, now. 
 >> just a second, great thing about 
using a physics engine is once you set it 
up, it will just run. 
 >> yeah, that is true. 
 >> and actually the biggest thing is 
you just set up the world, and it just 
does everything for you. 
 >> yep, that is good. 
and so you don't actually have to process 
any of your own collisions, you don't 
actually have to know what the velocity 
of any of your objects are or compute 
them. 
the physics engine does it all for you. 
this is what most people who are 
developing games do. 
then we learn from search engine in order 
to do those those calculations. 
some people insist on watching learn from 
search engines from scratch. 
[cough] i think that's actually a good 
idea if you like doing that sort of 
thing, but if you don't you should 
probably [inaudible]. 
so, the draw method is surprisingly 
small, in this case, because as mark has 
already mentioned. 
the physics engine is doing the drawing 
for the foreground objects that are 
moving around. 
this is because it knows where everything 
is because it's calculating the velocity. 
in other words it's calculating all the x 
and y positions. 
but we still need to have the image of 
the tip, which is the backdrop, which i 
already explained. 
and we also have to have the score. 
which, at the moment, there's no 
objective. 
one thing you might do for an objective 
is say, you know what, let's have each 
session last 20 seconds. 
and get the highest score you can in 20 
seconds. 
and then have a second, in other words, 
each session lasts, each game level lasts 
15 seconds. 
and then the next level lasts 10 seconds. 
and you just have to get the highest 
score that you can. 
this provides an objective. 
it's up to you to kind of think of an 
objective. 
the whole point of designing a game is to 
have something people want to do. 
we're just giving you a framework. 
so it'll be great to see what you come up 
with. 
all right. 
now, [cough], as a few of the standard 
methods mouse-dragged, which basically 
sets the position of tucks. 
who is basically the boid object. 
and we've got these 'screentoworld' 
coordinates. 
we parse in the mousex and the mousey 
values, add a two-dimensional vector to 
our physics world, and that sets the 
position so that when we click on the 
screen we can make sure that that's where 
our [unknown] is going to be. 
and then we just demo that. 
 >> that's why when i click on the 
screen turks appears more or less where i 
leave him, and i can just fly him around. 
okay. 
mouse release there's a bit more stuff 
going on. 
dragging is set to false. 
so this means that we're no longer fixing 
the position of turks and we have this 
thing called an impulse and now that's 
probably best if marco explains this. 
 >> so basically, when you release the 
catapults touch will start flying off, 
the reason is that force is instantly 
applied to touch. 
it's an impulse; i talked about this in 
my lecture. 
so what we're doing is we're calculating 
the appropriate impulse direction and 
magnitude of the impulse based on where 
you're pulling back. 
the elastic catapult. 
i've gone through the details of this 
calculation in my lecture, but it's using 
vector subtraction and multiplying the 
impulse by a certain constant to get it 
at about the right value, just as matthew 
was saying a bit about the audio 
sometimes you just need to play around to 
get the right number, to get the right 
feel for it and then we apply the impulse 
to tux and from then on the physics just 
handle how it moves. 
 >> so that constant in this case is 
 >> and then, yeah, we apply the impulse 
to, to him and then he's given the 
impulse just as if you've smacked him in 
the face with a big stick. 
which yeah, i think penguins, you know, 
they're probably used to that. 
okay, so the last thing we want to talk 
about in the terms of this demo app is 
the my custom rendered. 
which is i'll substitute for the draw 
function where all the drawing and the 
physics end and so the first thing to 
note here is that we set the stoke to 0 
and we get the start point and use it 
draw to a line and that's as you can see 
in the example this line is. 
 >> the pole that tux is suspended from 
and that we use to fire him off. 
that's his kind of starting point in the 
world. 
boing. 
okay, and then following that we have to 
draw all the other stuff. 
so marco, do you just want to talk us 
through that? 
 >> yeah, sure. 
just to make a note this is, this is what 
i described in my lecture. 
we're getting into position of and the 
angle of the each of our physics objects 
in this case void we have to convert from 
world coordinates to screen coordinates. 
just as we did we have to do up here. 
and then we can use whatever processing 
drawing code we like using those 
coordinates. 
they're just values they're just numbers 
we can do whatever we like with them. 
i'm doing a fairly obvious thing, i'm 
translating, imitating by those two 
values and then drawing an image. 
 >> so most of the time you are going to 
want to get the positions and the angle 
translate by position take by the angle 
and then draw whatever you want, in this 
case we're going to draw the images we 
got and the code for crate is exactly the 
same where we've got a four loop over all 
the crates but we're just doing pretty 
much the same thing just drawing a 
different image. 
 >> and it's just because it's an array 
of crates. 
 >> yeah. 
 >> so doing each one at a time. 
okay so the final, final thing in 
addition to the other final thing we 
going to talk about is just how the 
collisions work. 
 >> now, the main the method for doing 
collisions is, it's all in collision 
detector dot js. 
so we just have to use that collision 
detector, pass in the positions and it 
will work out where a collision has 
happened and will let us know. 
so the main method for that, well this is 
basically here boid collision. 
so the collision dysfunction is caused by 
the collision detector, and you've got, 
as i said in my lecture, two bodies that 
are colliding in the impulse. 
so you can use that, for example, i'm 
checking here if the impulse is more than 
one, so it's a proper impulse. 
i'm increasing the score, so the score's 
going up. 
that's how we did in scoring. 
but we're going to do a few things so we 
can, we can, because we got the bodies we 
can check which particular body it is. 
and we need to make sure that there's two 
things. 
there's, we need ju-, the, it's the 
actual tux that's colliding so we're 
checking if one of the bodies, b1 or b2, 
is, is void. 
and the other thing we're doing here is 
we're checking the mass of the other 
objects. 
why are we doing that? 
because you might notice that cut 
bouncing off the screen that's because 
they're physics objects at the edges of 
the screen that automically created. 
those have 0 mass which means they don't 
move they're static objects. 
but we don't want to get [unknown] when 
we bounce off the walls so we'er just 
checking that the objects have more than 
0 mass which means they're not one of the 
static objects, they're one of the 
crates. 
so we can do that test similarly 
[unknown] whether you talk through a 
bunch of code is easiest to crate the 
audio. 
 >> and to create audio to respond to 
collisions. 
and that stuff's just here, and it's the 
same. 
 >> that's right. 
 >> okay, great. 
so fundamentally that's the basic set 
example. 
 >> it shows you how to create a 
physical world, how to put objects in 
that world, and then how to interact with 
them, and have them interact with each 
other, it also shows you how to draw the 
different artwork that you need, the best 
way of preparing the artwork, and it's up 
to you to put in for example decent 
artwork, game play, mechanics that sort 
of thing, or the kinds of scoring 
mechanisms and different kind of ideas. 
so you can use it as a starting point, 
and you can develop it and try to build 
on something that's a much more developed 
project. 
 >> and, and that's it. 
 >> have fun. 
[music]. 
