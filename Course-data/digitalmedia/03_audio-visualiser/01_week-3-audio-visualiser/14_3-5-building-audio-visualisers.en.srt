1
00:00:00,492 --> 00:00:18,218
[SOUND]. 

2
00:00:18,218 --> 00:00:21,568
Okay, so we've had Marco explain to you 
about rotation and translation and other 

3
00:00:21,568 --> 00:00:24,668
types of methods for changing the display 
of certain types of graphics and 

4
00:00:24,668 --> 00:00:28,780
characteristics of graphics on the 
screen. 

5
00:00:28,780 --> 00:00:34,170
And we've had Matt explaining to you, 
explaining really how we analyze audio 

6
00:00:34,170 --> 00:00:37,874
among other things. 
Now what we going to do is we're going to 

7
00:00:37,874 --> 00:00:39,780
try and combine those two things 
together. 

8
00:00:39,780 --> 00:00:43,812
We're going to do a little bit of what we 
call graphical synthesis to create 

9
00:00:43,812 --> 00:00:47,297
algorithmic graphics. 
And we're going to do a little bit of 

10
00:00:47,297 --> 00:00:50,176
audio analysis and combine that to make 
an audio visualizer. 

11
00:00:50,176 --> 00:00:54,202
Audio visualizers are really popular and 
you find them all over the place 

12
00:00:54,202 --> 00:01:00,193
remarkably so in pretty much every media 
player and every major console. 

13
00:01:00,193 --> 00:01:04,603
So for example in the xbox Jeff Minter's 
audio visualizer is the main visualizer 

14
00:01:04,603 --> 00:01:11,156
when you see when you put a CD in. 
although other visual artist like I think 

15
00:01:11,156 --> 00:01:14,796
it's flight 404, their visualizer used 
for iTunes, so there is a whole range of 

16
00:01:14,796 --> 00:01:20,410
people who just make computer graphics, 
abstract computer graphics. 

17
00:01:20,410 --> 00:01:24,506
And their work is a major part of 
everybody's listening experience. 

18
00:01:24,506 --> 00:01:28,853
the audo analysis aspect of doing 
audio-visualization is quite good to 

19
00:01:28,853 --> 00:01:34,980
understand and is quite nice to know how 
to do some of those tricks. 

20
00:01:34,980 --> 00:01:38,225
I'm going to take you through basic 
analysis and how we use it to change 

21
00:01:38,225 --> 00:01:41,827
graphic parameters. 
And I'm also going to give you a really 

22
00:01:41,827 --> 00:01:47,560
quick introduction to beat detection. 
so let's start at the beginning. 

23
00:01:49,660 --> 00:01:54,762
Building an audio visualiser. 
So, the first thing we need to learn is 

24
00:01:54,762 --> 00:01:58,464
how to do algorithmic drawings. 
There are so many different ways to doing 

25
00:01:58,464 --> 00:02:02,940
this and so many different methods and 
different algorithms you can apply. 

26
00:02:02,940 --> 00:02:07,500
I'm going to teach you how to do some 
really simple stuff that uses rotation 

27
00:02:07,500 --> 00:02:12,654
and translation, and we're going to start 
with rotation. 

28
00:02:12,654 --> 00:02:21,605
Now, fundamentally the key to almost all 
algorithmic drawing is a for loop. 

29
00:02:21,605 --> 00:02:24,899
And Marco will explain that to you if 
you're not sure what for loops are you 

30
00:02:24,899 --> 00:02:28,517
should go back and check the programming 
lectures that Marco supplied for you in 

31
00:02:28,517 --> 00:02:33,127
case you're a little rusty. 
It's actually really, really easy to 

32
00:02:33,127 --> 00:02:36,840
understand the for loop and I'm sure 
you'll be fine with it. 

33
00:02:36,840 --> 00:02:39,486
But all you really need to know is this 
is a method for drawing lots and lots of 

34
00:02:39,486 --> 00:02:43,650
things in different ways on the screen. 
Let me give you an example. 

35
00:02:43,650 --> 00:02:46,890
Here's a basic rotation sketch which we 
can look at. 

36
00:02:46,890 --> 00:02:50,080
You can see this would run fine on an 
iPad or an iPhone. 

37
00:02:50,080 --> 00:02:53,450
We've got a bunch of rectangles and 
they're all spinning round. 

38
00:02:53,450 --> 00:02:59,590
You'll notice that when they spin round, 
they seem to, line up at certain points. 

39
00:02:59,590 --> 00:03:02,640
Like just then. 
Also you'll notice if you're looking, 

40
00:03:02,640 --> 00:03:06,168
that you get four, a group of four, then 
a group of five, then a group of three, 

41
00:03:06,168 --> 00:03:12,150
and then it spins out into one long arm 
and goes all the way around. 

42
00:03:12,150 --> 00:03:15,498
Now the reason this works is because 
every individual shape I'm drawing is 

43
00:03:15,498 --> 00:03:19,090
spinning. 
Based on its position in a system of a 

44
00:03:19,090 --> 00:03:22,704
certain number of object. 
So if I want, If I had 20 objects and I 

45
00:03:22,704 --> 00:03:25,712
was spinning them all, and I was spinning 
an object in the middle, I, I would be 

46
00:03:25,712 --> 00:03:30,476
spinning it 20 times slower than the 
object on the object on the edge. 

47
00:03:30,476 --> 00:03:34,100
And when you do that, you get this 
interesting symmetrical pattern. 

48
00:03:34,100 --> 00:03:38,455
This has been used by lots of artists 
over the years and it's an interesting 

49
00:03:38,455 --> 00:03:44,590
way of getting feedback type effects that 
are really symmetrical. 

50
00:03:44,590 --> 00:03:49,159
Let's have a quick look at how it works. 
So it doesn't use any trigonometry 

51
00:03:49,159 --> 00:03:53,590
although we are going to look at some 
basic trig real soon. 

52
00:03:53,590 --> 00:04:00,916
But what we do have is a so it doesn't 
use any trigonometry, but what we do have 

53
00:04:00,916 --> 00:04:07,340
is a simple rotation. 
And I'm going to show you how that works. 

54
00:04:07,340 --> 00:04:10,321
This is the sketch. 
So ther's no sine, there's no cosine, 

55
00:04:10,321 --> 00:04:14,090
there's no tangents or stuff, and there's 
no pi. 

56
00:04:14,090 --> 00:04:16,470
We'll be looking at pi a little bit 
later. 

57
00:04:16,470 --> 00:04:21,056
Young blah etc. 
But it has a similar effect, I'll just 

58
00:04:21,056 --> 00:04:24,922
used a variable called time. 
This variable is initialized at zero at 

59
00:04:24,922 --> 00:04:29,620
the top of the sketch. 
Let's have a quick look at what's going 

60
00:04:29,620 --> 00:04:34,980
on underneath here if we go back. 
So we have time and time is this value 

61
00:04:34,980 --> 00:04:38,925
where we're incrementing bit by bit. 
Every, every time that we ask the 

62
00:04:38,925 --> 00:04:43,343
computer to draw a frame that increments. 
And then what we do is we say okay, 

63
00:04:43,343 --> 00:04:47,697
here's a for loop. 
basically I want to do this 20 times 

64
00:04:47,697 --> 00:04:56,260
times, and it uses this variable i, which 
is an integer, to do it 20 times. 

65
00:04:56,260 --> 00:05:00,036
We're going to rotate given the current 
time so as time progresses and as time is 

66
00:05:00,036 --> 00:05:04,872
incremented by this value of 0.01, it's 
going to change the rotation. 

67
00:05:04,872 --> 00:05:09,356
And then what we're going to do is we're 
going to draw a rectangle based on its 

68
00:05:09,356 --> 00:05:16,050
position, i, it's position in the system, 
whichever one it is. 

69
00:05:16,050 --> 00:05:18,670
And then we're also going to change the 
signs based on their position. 

70
00:05:19,830 --> 00:05:23,358
and that's what we have here and that's 
what gives us this spinning set of 

71
00:05:23,358 --> 00:05:27,682
squares. 
So you can see here the normal sort 

72
00:05:27,682 --> 00:05:32,280
processing stuff size and frame rate, we 
set the background to white. 

73
00:05:32,280 --> 00:05:36,351
We translated everything to the middle of 
the screen so that zero and zero the 0x 

74
00:05:36,351 --> 00:05:40,543
and 0y is right in the center. 
This is useful, and for all the sketches 

75
00:05:40,543 --> 00:05:42,980
I'm doing today, that why, that's how I'm 
working. 

76
00:05:42,980 --> 00:05:48,030
I've turned the fill of and then here's 
the bit we just looked at. 

77
00:05:48,030 --> 00:05:51,500
I'm incrementing time. 
I've got 20 of these and then I'm just 

78
00:05:51,500 --> 00:05:54,950
spinning them around. 
Each one is being spun around differently 

79
00:05:54,950 --> 00:05:59,168
based on what the time is. 
And then I'm drawing it but the join 

80
00:05:59,168 --> 00:06:03,720
functions been parameterized with the 
number i. 

81
00:06:03,720 --> 00:06:07,770
The number i represents the number in the 
system, so remember what I said before. 

82
00:06:07,770 --> 00:06:11,070
So if I'm spinning the one in the center 
around, I was spinning it 20 times slower 

83
00:06:11,070 --> 00:06:15,403
than the one on the edge. 
So as I count each one out rectangle 

84
00:06:15,403 --> 00:06:19,222
here, rectangle here, rectangle here this 
one spins like this and this one spins 

85
00:06:19,222 --> 00:06:22,517
like this. 
So this one for every single rotation 

86
00:06:22,517 --> 00:06:26,060
this one does this one does 20 rotations, 
the one on the other end. 

87
00:06:27,250 --> 00:06:29,985
Okay, so that's the basic idea. 
Let's try something a bit more 

88
00:06:29,985 --> 00:06:34,407
complicated. 
Let's do a for loop with rotation and a 

89
00:06:34,407 --> 00:06:37,175
bit of trigonometry. 
It's a really, really simple algorithmic 

90
00:06:37,175 --> 00:06:39,556
process. 
This one, I always use, I always used 

91
00:06:39,556 --> 00:06:43,144
this example when I'm explaining about 
algorithmic drawing because it's a really 

92
00:06:43,144 --> 00:06:46,628
good algorithm to start with because it's 
one of the earliest computer graphics 

93
00:06:46,628 --> 00:06:52,481
algorithms we're creating. 
animations and it was used by John 

94
00:06:52,481 --> 00:06:58,280
Whitney, Sr to produce a range of really 
famous abstract animated pieces. 

95
00:06:58,280 --> 00:07:01,928
He also used a similar technique for 
generating what's called Lissajous 

96
00:07:01,928 --> 00:07:05,615
figures for doing the title sequence to 
Vertigo. 

97
00:07:05,615 --> 00:07:09,423
Which I think there's just been a, in 
fact the day we're recording this there's 

98
00:07:09,423 --> 00:07:14,861
a Google doodle which gives you an 
indication of when we're recording this. 

99
00:07:14,861 --> 00:07:18,601
There's a Google doodle which celebrates 
the work of Saul Bass and on that there's 

100
00:07:18,601 --> 00:07:22,231
quite a lot of stuff about John Whitney 
because Saul Bass went with John Whitney 

101
00:07:22,231 --> 00:07:27,490
to do the vertigo type of sequence using 
exactly this algorithm. 

102
00:07:27,490 --> 00:07:31,074
And it's one of the earliest pieces of 
computer graphics that Whitney did on a 

103
00:07:31,074 --> 00:07:37,253
computer that he built himself, in fact. 
So get this to work, we need to use some 

104
00:07:37,253 --> 00:07:42,080
trigonometry, and we need some elements. 
We've got some variables and some 

105
00:07:42,080 --> 00:07:44,646
elements. 
The elements is the number of objects 

106
00:07:44,646 --> 00:07:49,170
that we want to draw and the variables 
are the way we want to draw them. 

107
00:07:49,170 --> 00:07:54,090
And we change these all inside the loop. 
So we have a variable float spacing a 

108
00:07:54,090 --> 00:07:57,567
variable called rotation a variable 
called radius and a variable called 

109
00:07:57,567 --> 00:08:01,708
magnify. 
And the we have int the number of 

110
00:08:01,708 --> 00:08:05,524
elements. 
So in the for loop we say. 

111
00:08:06,760 --> 00:08:09,343
As many elements as we've got, we keep 
looping around until we've drawn them 

112
00:08:09,343 --> 00:08:11,482
all. 
That's what it says int i equals 0, i 

113
00:08:11,482 --> 00:08:15,020
less than element i plus plus. 
And then we're using pushMatrix and 

114
00:08:15,020 --> 00:08:18,660
popMatrix, which Marco will have 
explained to you about already. 

115
00:08:18,660 --> 00:08:23,967
Now what we do is instead of rotating 
given our time value, we rotate given 

116
00:08:23,967 --> 00:08:29,984
spacing, i and rotation. 
So there are three numbers that we use to 

117
00:08:29,984 --> 00:08:34,630
calculate what the current rotation's 
going to be. 

118
00:08:34,630 --> 00:08:37,340
So we have the spacing, which is the 
distance between all the objects. 

119
00:08:37,340 --> 00:08:39,920
We have i, which is the number of the 
object in the system. 

120
00:08:39,920 --> 00:08:43,760
And we have rotation, which is how much 
rotation there currently is, how much 

121
00:08:43,760 --> 00:08:49,533
we're rotating into our system. 
And then what we do is we're translating 

122
00:08:49,533 --> 00:08:53,170
it as well at the same time. 
So that's the main difference. 

123
00:08:53,170 --> 00:08:56,602
Although we're parametrizing rotate 
differently, we're still just rotating 

124
00:08:56,602 --> 00:08:58,904
it. 
The key thing is here we're translating 

125
00:08:58,904 --> 00:09:01,786
at the same time. 
Which means It doesn't just spin round, 

126
00:09:01,786 --> 00:09:05,091
it goes in and out. 
And we are using sine to do this which is 

127
00:09:05,091 --> 00:09:10,050
a trigonometric function which squeezes 
all the, all the shapes in and out. 

128
00:09:10,050 --> 00:09:14,008
Now, let's have a quick look. 
Basically, we're drawing an ellipse every 

129
00:09:14,008 --> 00:09:17,524
time we do this. 
I'm going to show you what that looks 

130
00:09:17,524 --> 00:09:21,110
like. 
So this is the basic rotation with sine. 

131
00:09:21,110 --> 00:09:24,815
Now, as always with these examples, 
they're accessible in week three, lesson 

132
00:09:24,815 --> 00:09:29,440
three of the coursera documents that you 
should have. 

133
00:09:29,440 --> 00:09:33,807
and here we have it. 
So this is this is the algorithm that I 

134
00:09:33,807 --> 00:09:39,950
was just talking about. 
It's useful for all sorts of things. 

135
00:09:39,950 --> 00:09:43,918
And, it's neat so I'll pair, I'll 
parametrize it with mouseX and mouseY so 

136
00:09:43,918 --> 00:09:48,704
you can see I'm just exploring with the 
mouse at the moment. 

137
00:09:48,704 --> 00:09:53,126
you'll notice that while I'm just 
traveling down the diagonal, we'll always 

138
00:09:53,126 --> 00:10:00,640
have it well it always gives us circles. 
But if I move in the y dimension, it 

139
00:10:00,640 --> 00:10:06,820
rotates and if I move in the x dimension, 
it translates. 

140
00:10:08,090 --> 00:10:10,782
And you see we get these interesting 
symmetries. 

141
00:10:10,782 --> 00:10:13,784
Let's have a, a kind of closer look at 
that. 

142
00:10:13,784 --> 00:10:19,100
I'm going to go back to here. 
So how are we doing that? 

143
00:10:19,100 --> 00:10:22,696
Well, we're mapping the radius and the 
rotation, given mouseX and mouseY, 

144
00:10:22,696 --> 00:10:29,470
exactly as I'm showing you on this slide. 
So, we're going, okay. 

145
00:10:29,470 --> 00:10:34,130
Well, we'll take the mouseX as input. 
And we presume that's from zero, which is 

146
00:10:34,130 --> 00:10:38,320
the leftmost side of the screen, to the 
width of the screen. 

147
00:10:38,320 --> 00:10:40,780
And then we're mapping that to values 
between 0 and 10. 

148
00:10:40,780 --> 00:10:42,590
And we're doing the same for the 
rotation. 

149
00:10:42,590 --> 00:10:47,198
So, because of the way we've organized 
these elements to be drawn, radius and 

150
00:10:47,198 --> 00:10:52,380
rotation are in the same range. 
The other thing, the other variable which 

151
00:10:52,380 --> 00:10:55,512
we introduced in the last slide which 
we're using to make this Whitney 

152
00:10:55,512 --> 00:11:00,920
algorithm, is, spacing. 
Now spacing is how far apart, as I've 

153
00:11:00,920 --> 00:11:05,010
said, how far apart the different 
elements are drawn. 

154
00:11:05,010 --> 00:11:08,440
And this is really about how far around a 
circle it is. 

155
00:11:08,440 --> 00:11:14,168
So in this case, we're getting TWO_PI. 
Now TWO_PI is basically how we measure 

156
00:11:14,168 --> 00:11:19,052
around a circle. 
So we start here zero pi and we measure 

157
00:11:19,052 --> 00:11:21,495
around and we get to, TWO_PI. 
Okay? 

158
00:11:21,495 --> 00:11:27,620
So Marco will have explained a little bit 
about pi. 

159
00:11:27,620 --> 00:11:31,836
We're using pi divided by elements to 
figure out how we get, say we have 1000 

160
00:11:31,836 --> 00:11:36,275
elements. 
We're dividing TWO_PI by 1000. 

161
00:11:36,275 --> 00:11:40,240
And we're saying that's how far apart all 
the, all the different elements are. 

162
00:11:40,240 --> 00:11:43,180
So it's a bit like saying, well, you 
know, I've got a box which is one meter 

163
00:11:43,180 --> 00:11:46,550
long. 
And I want to get ten sandwiches in it. 

164
00:11:46,550 --> 00:11:49,350
So I'm going to stick each one in at a 
tenth of a meter, apart. 

165
00:11:49,350 --> 00:11:51,540
That's basically what we're doing. 
Although they're not sandwiches. 

166
00:11:51,540 --> 00:11:55,455
There's no box. 
It's just a circle and some graphics. 

167
00:11:55,455 --> 00:11:59,349
So radius and rotation, they're the two 
variables which are how far around it's 

168
00:11:59,349 --> 00:12:03,007
going, and how far away from the center 
it is, and spacing is how far apart we 

169
00:12:03,007 --> 00:12:09,320
are around the circle. 
So quickly let's have a look at this. 

170
00:12:11,200 --> 00:12:13,260
So here they are. 
We're in the draw loop. 

171
00:12:13,260 --> 00:12:18,500
We set the background to black. 
We've mapped mouseX to ray x. 

172
00:12:18,500 --> 00:12:22,034
We've mapped mouseY to rotation. 
We've created spacing which is TWO_PI 

173
00:12:22,034 --> 00:12:24,718
elements. 
We translated the center of the screen 

174
00:12:24,718 --> 00:12:26,910
which is what we're doing for all these 
sketches. 

175
00:12:26,910 --> 00:12:30,720
I've explained that to you before. 
We turn fill off and then what we do is 

176
00:12:30,720 --> 00:12:36,379
we say for every element pick a color. 
I'll be talking about a color in a 

177
00:12:36,379 --> 00:12:39,600
minute. 
PushMatrix just like Marco said we needed 

178
00:12:39,600 --> 00:12:42,652
to. 
Now rotate based on how far apart they're 

179
00:12:42,652 --> 00:12:47,276
supposed to be, which element and system 
they are and what the rotation currently 

180
00:12:47,276 --> 00:12:50,977
is. 
And then translate but when we 

181
00:12:50,977 --> 00:12:57,812
translating we're getting the sine of the 
spacing which is how far apart they are. 

182
00:12:57,812 --> 00:13:01,292
The i which is the number which 
particular element it is and the radius 

183
00:13:01,292 --> 00:13:07,324
which is how far from the center it is. 
So we get the sine of that and then we 

184
00:13:07,324 --> 00:13:10,624
magnify it. 
Now this is what creates that squeezing, 

185
00:13:10,624 --> 00:13:14,302
cause the, what sine produces is this 
waveform like this. 

186
00:13:14,302 --> 00:13:18,054
And because we're running those values 
into a sine wave and then magnifying them 

187
00:13:18,054 --> 00:13:21,806
out, then we're basically not just going 
around the circle, we're going through 

188
00:13:21,806 --> 00:13:27,105
the circle as well. 
As we are squeezing the radius to and 

189
00:13:27,105 --> 00:13:30,860
from the centerfold. 
And that's how it works. 

190
00:13:30,860 --> 00:13:33,909
Then we draw our circles. 
Now, you'll see, if I show you the 

191
00:13:33,909 --> 00:13:36,810
sketch, all the circles are the same 
size. 

192
00:13:36,810 --> 00:13:41,100
I can do some interesting things quite 
fast just by times-ing them by i. 

193
00:13:43,550 --> 00:13:46,732
Let's try again. 
And you'll notice that immediately I've 

194
00:13:46,732 --> 00:13:51,820
got a very very different sketch with, 
which looks a lot more interesting. 

195
00:13:51,820 --> 00:13:55,411
You see, I've got, I think they're far 
too big so I should probably change the 

196
00:13:55,411 --> 00:13:59,305
size. 
Let's just make them, I just, I'll say i 

197
00:13:59,305 --> 00:14:03,696
times 10 instead of 20, cause they're a 
bit off the screen. 

198
00:14:03,696 --> 00:14:06,775
let's try that again. 
Yeah, that's a bit more like it. 

199
00:14:06,775 --> 00:14:10,487
So you can see I've got a lot more 
control, and you get this weird sort of 

200
00:14:10,487 --> 00:14:14,768
pseudo 3D effect. 
And it's worrying as all the different 

201
00:14:14,768 --> 00:14:19,140
circles interact, exactly like they did 
in the first sketch. 

202
00:14:19,140 --> 00:14:21,470
You get this kind of weird mesh. 
Now, when I'm all the way over here, it 

203
00:14:21,470 --> 00:14:25,554
looks a bit messy. 
But really when both the values are quite 

204
00:14:25,554 --> 00:14:32,250
near to zero, you get some quite nice 
effects, nice 3D effects. 

205
00:14:32,250 --> 00:14:35,910
Also what we can do is we can change the 
number of circles. 

206
00:14:35,910 --> 00:14:39,595
So if I change the number of elements to 
something a bit ridiculous, like 1,000 is 

207
00:14:39,595 --> 00:14:42,850
a lot. 
Let's try 256, just double them, I wonder 

208
00:14:42,850 --> 00:14:46,798
if it can handle that? 
Yeah, there you go, well that's 256 and 

209
00:14:46,798 --> 00:14:50,713
you see that immediately. 
It's starting to look a lot more 

210
00:14:50,713 --> 00:14:54,997
interesting, and all we've done is taken 
a few of the variables and parameterized 

211
00:14:54,997 --> 00:14:59,190
them okay. 
So we're going to use this, in a bit to 

212
00:14:59,190 --> 00:15:02,740
show you the final example. 
But lets move on. 

213
00:15:02,740 --> 00:15:07,254
I want to talk a bit about hue and 
rotation and then I'm going to talk about 

214
00:15:07,254 --> 00:15:11,842
how we organize, so we do color and then 
I'm going to talk about how we organize 

215
00:15:11,842 --> 00:15:19,390
sound and beat detection. 
So instead of using red, green, and blue 

216
00:15:19,390 --> 00:15:26,690
colors like we normally do I'm using hue 
saturation and brightness, HSB. 

217
00:15:26,690 --> 00:15:31,550
Sometimes called HSV color where the V 
stands for Value instead of brightness. 

218
00:15:31,550 --> 00:15:33,280
Sometimes called HSL, where it stands for 
Luminance. 

219
00:15:33,280 --> 00:15:39,290
So basically, hue is the color tone. 
Rather than having a mixture of red, 

220
00:15:39,290 --> 00:15:42,788
green and blue, we can say, well, I want 
the color tone, whether it's red, blue or 

221
00:15:42,788 --> 00:15:47,117
yellow to be one number. 
And that's normally expressed between 

222
00:15:47,117 --> 00:15:50,402
zero and 360 degrees. 
And it's, it's as if it was going around 

223
00:15:50,402 --> 00:15:54,130
a circle. 
saturation is the color depth which is 

224
00:15:54,130 --> 00:15:58,420
how strong the color is. 
And brightness is self explanatory, it's 

225
00:15:58,420 --> 00:16:01,920
how bright it is. 
So bright it is if so if saturation is 

226
00:16:01,920 --> 00:16:04,570
zero. 
The color is, is either you know, is a 

227
00:16:04,570 --> 00:16:08,160
shade of gray. 
And if brightness is zero, it's black. 

228
00:16:09,180 --> 00:16:11,210
And you can see by this triangle, how it 
works. 

229
00:16:12,660 --> 00:16:15,924
Now so what we do here in processing, in 
order to make this work is we change the 

230
00:16:15,924 --> 00:16:19,323
color mode to HSB. 
And then we can control what we would 

231
00:16:19,323 --> 00:16:22,689
normally like the Fill command, or the 
Stroke command to set the hue saturation 

232
00:16:22,689 --> 00:16:26,325
and brightness. 
And in that example I was showing you, 

233
00:16:26,325 --> 00:16:29,790
you saw that the color was going through 
a range of different colors from one 

234
00:16:29,790 --> 00:16:33,810
circle to the other. 
Because in my Stroke command in my fit, 

235
00:16:33,810 --> 00:16:37,742
yeah, it was the Stroke command. 
In that Stroke command I was setting it 

236
00:16:37,742 --> 00:16:40,410
based on the number of the elements in 
the system. 

237
00:16:40,410 --> 00:16:44,505
So it went around the hue circle, you can 
see the hue circle here, which is on the 

238
00:16:44,505 --> 00:16:50,607
top of this, on the bottom of this cone. 
It went round and round and round that 

239
00:16:50,607 --> 00:16:55,750
cone, based on which number in the 
graphical system we were drawing. 

240
00:16:55,750 --> 00:17:00,578
So, if we use that hue saturation and 
brightness, and then we do some analysis, 

241
00:17:00,578 --> 00:17:06,695
we can create some interesting visuals. 
I'm going to start with a really simple 

242
00:17:06,695 --> 00:17:11,190
visualizer, based on analyzing sound. 
Exactly what Matt said. 

243
00:17:11,190 --> 00:17:16,152
We get, we analyze the audio by getting a 
float value called power in this example. 

244
00:17:16,152 --> 00:17:22,300
And that's that's done by using the audio 
method, get average power. 

245
00:17:22,300 --> 00:17:27,834
So, we go float power equals plat pow 
Float power equals player.getAveragePower 

246
00:17:27,834 --> 00:17:31,180
and then we use the variable power to 
change the animation. 

247
00:17:31,180 --> 00:17:33,380
I've got an example that I want to show 
you. 

248
00:17:33,380 --> 00:17:38,640
Which is really, really simple. 
what it does is, it's, uses HSV, as I've 

249
00:17:38,640 --> 00:17:45,006
already said, and it produces. 
The form, it produces it, you load the 

250
00:17:45,006 --> 00:17:51,580
sound, you analyze the sound, and then we 
just change the color. 

251
00:17:51,580 --> 00:17:55,800
You can see I'm changing the color here, 
before it draws this circle. 

252
00:17:55,800 --> 00:18:00,833
And it looks like this. 
And we should get some [MUSIC] and just 

253
00:18:00,833 --> 00:18:08,769
to prove that I'm actually analyzing it 
if I change the speed you see that a hue 

254
00:18:08,769 --> 00:18:18,127
rotation changes speed too. 
So, I'm clicking and dragging, [SOUND] 

255
00:18:18,127 --> 00:18:24,023
clicking and dragging to change the speed 
and you gotta be a bit careful with this 

256
00:18:24,023 --> 00:18:31,770
cause if you stare at it to long it can 
give you a funny feeling. 

257
00:18:31,770 --> 00:18:34,662
I guess I better move on. 
So, if I show you a bit of that code, 

258
00:18:34,662 --> 00:18:37,963
it's really simple. 
We have another for loop with a number of 

259
00:18:37,963 --> 00:18:40,798
elements which is exactly the same as 
before. 

260
00:18:40,798 --> 00:18:44,574
I'm literally just drawing 20 circles, 
and those 20 circles are spaced in the 

261
00:18:44,574 --> 00:18:48,468
screen from the outside in, just as if I 
was laying sugar paper circles one on top 

262
00:18:48,468 --> 00:18:53,327
of the other. 
And then, what I'm doing, is I'm using 

263
00:18:53,327 --> 00:18:58,367
the hue and I'm rotating the hue based on 
the power, and also the also then the 

264
00:18:58,367 --> 00:19:03,696
number of the element that we're 
currently in. 

265
00:19:03,696 --> 00:19:09,730
So, the outer circle is a different hue 
to the inner circle. 

266
00:19:09,730 --> 00:19:13,070
Which is why it seems to cycle from the 
outside to in. 

267
00:19:13,070 --> 00:19:15,364
That's basic color cycling. 
Okay. 

268
00:19:15,364 --> 00:19:20,054
So, we're just to go through that again, 
we're changing the color of the elements 

269
00:19:20,054 --> 00:19:24,950
depending on the power. 
We get the float value power from the 

270
00:19:24,950 --> 00:19:30,170
getAveragePower method. 
We also have another float called Go 

271
00:19:30,170 --> 00:19:33,230
which. 
Go is basically how much energy we have. 

272
00:19:33,230 --> 00:19:36,578
So we keep adding the extra power and 
I've got a multiplier plus 50 which you 

273
00:19:36,578 --> 00:19:39,100
can change. 
Have a mess with that. 

274
00:19:39,100 --> 00:19:43,422
See how it effects how fast it moves. 
So Go is a value which we use to keep 

275
00:19:43,422 --> 00:19:47,700
cycling through, through all the 
different color values. 

276
00:19:47,700 --> 00:19:51,080
So, it's the, It's the additive power as 
we keep going. 

277
00:19:51,080 --> 00:19:53,950
And it's kind of a number that keeps 
getting bigger and bigger. 

278
00:19:53,950 --> 00:19:57,910
Now, I'm using Modulo here to make sure 
that whatever that value is, it's 

279
00:19:57,910 --> 00:20:02,609
constrained to between 0 and 255. 
And we go, basically we have a fill 

280
00:20:02,609 --> 00:20:07,770
command, i plus go, modulo 255. 
And that's the hue, power times 512, 

281
00:20:07,770 --> 00:20:16,140
that's the saturation, and 255 is the 
brightness, so it's always very bright. 

282
00:20:16,140 --> 00:20:20,170
And then we draw our ellipses, and the 
size of the ellipse is dependent on which 

283
00:20:20,170 --> 00:20:25,710
circle we're actually drawing. 
So the circle go from the outside in. 

284
00:20:25,710 --> 00:20:29,020
So that's the most simple kind of audio 
visualiser. 

285
00:20:29,020 --> 00:20:31,408
Let's take another look at it because 
it's good for the eyes [MUSIC]. 

286
00:20:31,408 --> 00:20:37,620
Really simple and really effective. 
Now let's say you want to do something 

287
00:20:37,620 --> 00:20:40,609
more complicated, we can control the 
visualizer with sound through beat 

288
00:20:40,609 --> 00:20:43,673
detection. 
Beat detection is something which is 

289
00:20:43,673 --> 00:20:47,999
useful when you're doing visualizers. 
And I've got a simple example here. 

290
00:20:47,999 --> 00:20:53,290
Let me show you the example. 
I'll tell you how it works. 

291
00:20:53,290 --> 00:20:58,390
As I've said before, all of these can be 
found in the materials which you should 

292
00:20:58,390 --> 00:21:03,224
have week three. 
So um, [MUSIC] we've got the same track 

293
00:21:03,224 --> 00:21:07,128
here and you'll notice we've got circle 
in the middle, which is showing us the 

294
00:21:07,128 --> 00:21:10,975
average power. 
And then there's a square appearing 

295
00:21:10,975 --> 00:21:14,290
whenever it, it detects a beat, and the 
square is appearing in the top left hand 

296
00:21:14,290 --> 00:21:21,420
corner. 
Let me show you how I did that. 

297
00:21:21,420 --> 00:21:25,466
So how did I do that? 
Basically, what I'm doing is I'm getting 

298
00:21:25,466 --> 00:21:30,710
the average power, I'm running a beat 
detector. 

299
00:21:30,710 --> 00:21:32,400
Let me talk you through how the beat 
detector works. 

300
00:21:35,300 --> 00:21:43,910
So quickly, what we do is we need to have 
two variables for beat detector. 

301
00:21:43,910 --> 00:21:48,430
In addition to power, we need to have 
threshold, and we need to have wait. 

302
00:21:49,860 --> 00:21:53,630
So the threshold is what the power needs 
to be for us to detect that there's been 

303
00:21:53,630 --> 00:21:56,875
a beat. 
It's basically a level that we set and if 

304
00:21:56,875 --> 00:21:59,739
it goes over that level, we call it a 
beat. 

305
00:22:00,740 --> 00:22:06,525
And then wait, tells us to wait a certain 
amount of time before we go looking for 

306
00:22:06,525 --> 00:22:11,450
more beats. 
Now, so we have a little method here, in 

307
00:22:11,450 --> 00:22:15,407
each statement. 
Power, if the power is greater than the 

308
00:22:15,407 --> 00:22:19,631
threshold, and also weight is less than 
zero so if we finished waiting and the 

309
00:22:19,631 --> 00:22:26,280
power is over the threshold then we can 
do something to change the animation. 

310
00:22:26,280 --> 00:22:29,340
So in the case that I just showed you 
we're just drawing a rectangle on the 

311
00:22:29,340 --> 00:22:32,362
screen but we could also do something 
else. 

312
00:22:32,362 --> 00:22:36,622
We could get this value go or our other 
value, we'll call it amplitude for 

313
00:22:36,622 --> 00:22:41,166
example and we can add the power to that 
amplitude to create a running graph of 

314
00:22:41,166 --> 00:22:47,800
the current amplitude. 
And then what we do is we add ten to the 

315
00:22:47,800 --> 00:22:51,833
wait value. 
So we wait for another ten frames before 

316
00:22:51,833 --> 00:22:56,655
we detect another beat. 
And then immediately we close that 

317
00:22:56,655 --> 00:22:59,590
bracket we do wait minus minus which 
starts the countdown. 

318
00:22:59,590 --> 00:23:03,295
So every drawing frame we count down and 
we're counting down until wait is less 

319
00:23:03,295 --> 00:23:08,460
than zero again and then we go okay we 
can look for another beat. 

320
00:23:08,460 --> 00:23:11,570
And that's basically how it works. 
Let me just show it working again so you 

321
00:23:11,570 --> 00:23:16,176
can see. 
[MUSIC] And you can see that [MUSIC] you 

322
00:23:16,176 --> 00:23:22,642
should actually be able to see the 
numbers flashing on as it detects a beat 

323
00:23:22,642 --> 00:23:27,835
here. 
You've got the average here and the 

324
00:23:27,835 --> 00:23:32,535
square is being drawn when we get a beat. 
[NOISE] So that's really simple. 

325
00:23:32,535 --> 00:23:35,829
Okay so this is the last example I'm 
showing you, it's just a way of showing 

326
00:23:35,829 --> 00:23:41,760
you how we put all those things together. 
it's not a fully In a worked example you 

327
00:23:41,760 --> 00:23:45,138
cold do a lot. 
So for example, I'm, I'm not really using 

328
00:23:45,138 --> 00:23:48,446
the color cycling. 
And also I've only done a little bit to 

329
00:23:48,446 --> 00:23:51,750
change the animation. 
I just made it look slightly nice. 

330
00:23:51,750 --> 00:23:55,090
But I'm drawing lines instead of drawing 
circles. 

331
00:23:55,090 --> 00:23:57,850
also I'm not changing the visualizer 
through out. 

332
00:23:57,850 --> 00:24:01,630
You could have a number of different 
drawing methods and change them based on. 

333
00:24:01,630 --> 00:24:05,580
How many beats are being detected or any 
number of different ideas. 

334
00:24:05,580 --> 00:24:08,604
So let me just show you a bit what that 
looks like and then you should take this 

335
00:24:08,604 --> 00:24:11,628
away as a starting point with all of the 
other examples and try and build your 

336
00:24:11,628 --> 00:24:15,760
own. 
So this is what it ends up looking like. 

337
00:24:15,760 --> 00:24:20,399
[MUSIC] You can see that we've got the 
position of the lines changes based on 

338
00:24:20,399 --> 00:24:24,958
[MUSIC] the beat's being protected, but 
they're also rotating based on the 

339
00:24:24,958 --> 00:24:30,990
energy, so they're really closely linked 
to the music. 

340
00:24:30,990 --> 00:24:35,690
Also, because the lines are all being 
rotated. 

341
00:24:35,690 --> 00:24:39,596
They're being rotated twice, once around 
the origin and then again given a 

342
00:24:39,596 --> 00:24:43,943
separate value, and you'll see sometimes 
we get nice symmetries, and sometimes we 

343
00:24:43,943 --> 00:24:51,234
get more noisy output. 
[MUSIC] I'm also using a hue to rotate 

344
00:24:51,234 --> 00:24:57,475
all of the different colors, and so 
that's it. 

345
00:24:57,475 --> 00:25:02,339
So in summary, what we've done is we're 
created a simple visualizer, a really 

346
00:25:02,339 --> 00:25:05,533
basic one. 
We could do a lot more by using alpha 

347
00:25:05,533 --> 00:25:09,672
blending, by doing more color cycling. 
But essentially we are taking some 

348
00:25:09,672 --> 00:25:13,994
algorithmic approaches to drawing. 
We are parameterizing them so that we can 

349
00:25:13,994 --> 00:25:17,805
control them in various ways. 
We're analyzing the audio and we're 

350
00:25:17,805 --> 00:25:21,831
taking the output of the audio analysis 
and plugging it into the sound, into the 

351
00:25:21,831 --> 00:25:26,486
graphics parameters. 
So the sounds being plugged straight into 

352
00:25:26,486 --> 00:25:31,880
the graphics as if we were taking a Jack 
plug out of a guitar and sticking it in. 

353
00:25:31,880 --> 00:25:35,195
In fact it's more complex than that 
because we're doing spectral analysis and 

354
00:25:35,195 --> 00:25:38,320
we're doing weighted average spectral 
analysis. 

355
00:25:38,320 --> 00:25:46,132
So this is a really good way a good 
method of generating visual material and 

356
00:25:46,132 --> 00:25:54,246
generating interesting visual 
applications [MUSIC] 