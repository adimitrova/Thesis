Our next topic is Shape Control by Curves. And what we introduce here is called
FiberMesh. And what we propose is an extension of the previous technique, which called
sketch 3D modeling. The difference is that original sketch
stays and works as a handle. So here, the input is very similar. You draw something and you get 3D shape. However, unlike previous system, this
curve stays on the surface, and then you can graph them and move them around and
then they form the shape. Let me show you a demo. So again, input is very similar. Here's a just draw a line, and the system
inflates it. However, as you see, your input stroke
stays there and this serves as a handle. So you can grab them, and move upwards. And then, soft continuously changes. You can see it from the top, and then you
can pull it sideways to see the shape. In this way, you can get more control, and
you can get more smooth shapes, which was not possible
in the polygon based system. And you can also add more contour curves
in this way. And then you can grab this thing, to
change the shape. And then like previously same you can also
add an arm. And from the sideways, you can pull it
down to change the shape. And here, as you see, we have two kinds of
curves. The blue curves is a kind of smooth
constraint, and the red curve is, as you see, a sharp
constraint. And of course, you can change the
categories. For example, if you change them to a blue,
you know, as you see. You will get a smooth rendition and, if
you want you can also erase them to remove any
constraint. And you will get a very smooth shape. As an example is here. You draw a shape here, and then you draw a shape here. And here this is to literally to motion. And if you want, you can make them sharp, and then you're going to get this kind of
shape. All right. Let me show you a couple more examples. Here you get this shape, and then you cut
it here like this way. And then you get the shops, shapes. And then if you erase these parts, you can get shape. So here, you know, smooth shape,
discontinuity here, but so this part is going around. And then again, you meet at a sharp
crease. This is not easy to do compared to other
approaches. You can use [INAUDIBLE] it's always
smooth, if you use this they are continuous boundaries and this is
not easy. And after combining these operations, you
can get these and other good shapes like
these. You can make this kind of mask or a human
body. Or arms and so on. And the point here is that, traditional
methods require the user to design. Is models by manipulating individual
control body, but here I use a control over a curves. And then we hope that this is a more
intuitive and more efficient. And let me describe the algorithm behind
the scene. So basic idea behind it is a user controls
a curve. And the curves define the boundary, and
the system automatically generates the smooth
surface based on the curves by running a continuous
optimization, trying to make a smooth surface as defined by the
curves. So that's the basic idea. Now let me describe the details. So curve deformation takes handle position
as the input, and then generates curve geometry,
updated curve geometry. And the surface optimization takes curve
geometry as the input, and then generates a smooth
surface. And let me describe the curve deformation
first. So curve deformation works like this way. So you have this shape. Input save, and then each segment has
three dimensional coordinate frames. Then, if you pull one point upwards, and then an assistant will define the entire
curve. Then, as you pull upwards, all coordinate
frames also rotate together. What we do is simultaneously updates its
position, its rings, and also quotation coordinate frame for individual
segments, curve segments. This is a quick overview. Please refer to paper for the details. Minimize these functional, right, moving around quadrics positions and digital
rotations. So we try to find very good more smooth quadric position and edgy digital
rotations and minimize this. And what we minimizes here, is that
difference. So this is this is a small laplacian which means, difference observed current position from
the surrounding position, and then the current difference is rotated
and it is compared to the current updated
laplacian. And this preserves the local details. And this one tries to minimize the
difference between neighboring rotations. So this tries to achieve smoother
rotations. And then this one is tries to minimize
difference between current position and the position of this line positions, the
nearby positions. So, each one is a smooth position. this, try to minimize the difference between original position and updated
position. Similarly, this one tries to minimize previous current rotation and updated
rotation. So by solving this system, system tries to
find a smooth deformation. Next one is Surface Optimization. And surface optimization takes as input a
curve geometry and a mesh topology. And this is the input. And then system will automatically
generate smooth surface. To do so system basically tries to
minimize variation of curvature. You know, curvature is how curved the
surface is. And then by minimizing the variation of curvature, system tries to generate a
smooth surface. In a mathematical representation, it looks
like this. So, Kn is a curvature, and then Kn
derivative in both [INAUDIBLE] axis and second axis,
and then this represents curvature, and then curvature variations,
and then we try to minimize this. And now fortunately this is no linear program. It's not easy to, or efficient to compute. So we approximate this by couple stepwise
linear computations like this. A little bit complicated, but luckily we
have two parts. Two passes. So one is cover up, so left flow computes
curvatures. So we first computer curvatures which is a
scale of values, and then by blending or smoothing out we
get target curvatures. So as you see, originally curvature has
many variations. But by smoothing out, you get a more
uniform target curvature values. So we tried to obtain these curvature
values. And from these curvature values,
multiplied by a surface normal, you get target laplacian
vertices, vectors. So we try to obtain this lapracian
vectors. In parallel, we also compute edge lengths. So free for us to compute current edge
lengths. And then we compute target edge lengths,
by blending or smoothing out. And then, multiply this target edge
lengths with current edge vectors, you get target edge
vectors. And by combining these target laplacian
vectors and target edge vectors, we solve earliest square problem
and you updated geometry. And the way you repeat multiple times, and
then you get optimized smooth shape. So original paper was called FiberMesh designing free-form surfaces with 3D
curves. And similar technique that he's trying to gradually changing the safe considering
local details was originally a presented at sketched based interface for
detail-preserving mesh editing. And also our technique is kind of also
learning surface fairing continuously. And it was inspired by work by geometric
fairing or or irregular meshes for three, for
free-from surface design. And we recommend to take a look at these
works.