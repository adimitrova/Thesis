our next topic is shape control by curves.
and what we introduce here is called fibermesh.
and what we propose is an extension of the previous technique, which called sketch 3d modeling.
the difference is that original sketch stays and works as a handle.
so here, the input is very similar.
you draw something and you get 3d shape.
however, unlike previous system, this curve stays on the surface, and then you can graph them and move them around and then they form the shape.
let me show you a demo.
so again, input is very similar.
here's a just draw a line, and the system inflates it.
however, as you see, your input stroke stays there and this serves as a handle.
so you can grab them, and move upwards.
and then, soft continuously changes.
you can see it from the top, and then you can pull it sideways to see the shape.
in this way, you can get more control, and you can get more smooth shapes, which was not possible in the polygon based system.
and you can also add more contour curves in this way.
and then you can grab this thing, to change the shape.
and then like previously same you can also add an arm.
and from the sideways, you can pull it down to change the shape.
and here, as you see, we have two kinds of curves.
the blue curves is a kind of smooth constraint, and the red curve is, as you see, a sharp constraint.
and of course, you can change the categories.
for example, if you change them to a blue, you know, as you see.
you will get a smooth rendition and, if you want you can also erase them to remove any constraint.
and you will get a very smooth shape.
as an example is here.
you draw a shape here, and then you draw a shape here.
and here this is to literally to motion.
and if you want, you can make them sharp, and then you're going to get this kind of shape.
all right.
let me show you a couple more examples.
here you get this shape, and then you cut it here like this way.
and then you get the shops, shapes.
and then if you erase these parts, you can get shape.
so here, you know, smooth shape, discontinuity here, but so this part is going around.
and then again, you meet at a sharp crease.
this is not easy to do compared to other approaches.
you can use [inaudible] it's always smooth, if you use this they are continuous boundaries and this is not easy.
and after combining these operations, you can get these and other good shapes like these.
you can make this kind of mask or a human body.
or arms and so on.
and the point here is that, traditional methods require the user to design.
is models by manipulating individual control body, but here i use a control over a curves.
and then we hope that this is a more intuitive and more efficient.
and let me describe the algorithm behind the scene.
so basic idea behind it is a user controls a curve.
and the curves define the boundary, and the system automatically generates the smooth surface based on the curves by running a continuous optimization, trying to make a smooth surface as defined by the curves.
so that's the basic idea.
now let me describe the details.
so curve deformation takes handle position as the input, and then generates curve geometry, updated curve geometry.
and the surface optimization takes curve geometry as the input, and then generates a smooth surface.
and let me describe the curve deformation first.
so curve deformation works like this way.
so you have this shape.
input save, and then each segment has three dimensional coordinate frames.
then, if you pull one point upwards, and then an assistant will define the entire curve.
then, as you pull upwards, all coordinate frames also rotate together.
what we do is simultaneously updates its position, its rings, and also quotation coordinate frame for individual segments, curve segments.
this is a quick overview.
please refer to paper for the details.
minimize these functional, right, moving around quadrics positions and digital rotations.
so we try to find very good more smooth quadric position and edgy digital rotations and minimize this.
and what we minimizes here, is that difference.
so this is this is a small laplacian which means, difference observed current position from the surrounding position, and then the current difference is rotated and it is compared to the current updated laplacian.
and this preserves the local details.
and this one tries to minimize the difference between neighboring rotations.
so this tries to achieve smoother rotations.
and then this one is tries to minimize difference between current position and the position of this line positions, the nearby positions.
so, each one is a smooth position.
this, try to minimize the difference between original position and updated position.
similarly, this one tries to minimize previous current rotation and updated rotation.
so by solving this system, system tries to find a smooth deformation.
next one is surface optimization.
and surface optimization takes as input a curve geometry and a mesh topology.
and this is the input.
and then system will automatically generate smooth surface.
to do so system basically tries to minimize variation of curvature.
you know, curvature is how curved the surface is.
and then by minimizing the variation of curvature, system tries to generate a smooth surface.
in a mathematical representation, it looks like this.
so, kn is a curvature, and then kn derivative in both [inaudible] axis and second axis, and then this represents curvature, and then curvature variations, and then we try to minimize this.
and now fortunately this is no linear program.
it's not easy to, or efficient to compute.
so we approximate this by couple stepwise linear computations like this.
a little bit complicated, but luckily we have two parts.
two passes.
so one is cover up, so left flow computes curvatures.
so we first computer curvatures which is a scale of values, and then by blending or smoothing out we get target curvatures.
so as you see, originally curvature has many variations.
but by smoothing out, you get a more uniform target curvature values.
so we tried to obtain these curvature values.
and from these curvature values, multiplied by a surface normal, you get target laplacian vertices, vectors.
so we try to obtain this lapracian vectors.
in parallel, we also compute edge lengths.
so free for us to compute current edge lengths.
and then we compute target edge lengths, by blending or smoothing out.
and then, multiply this target edge lengths with current edge vectors, you get target edge vectors.
and by combining these target laplacian vectors and target edge vectors, we solve earliest square problem and you updated geometry.
and the way you repeat multiple times, and then you get optimized smooth shape.
so original paper was called fibermesh designing free-form surfaces with 3d curves.
and similar technique that he's trying to gradually changing the safe considering local details was originally a presented at sketched based interface for detail-preserving mesh editing.
and also our technique is kind of also learning surface fairing continuously.
and it was inspired by work by geometric fairing or or irregular meshes for three, for free-from surface design.
and we recommend to take a look at these works.
