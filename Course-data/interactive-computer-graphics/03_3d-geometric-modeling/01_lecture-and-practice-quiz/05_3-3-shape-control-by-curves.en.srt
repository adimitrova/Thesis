1
00:00:00,960 --> 00:00:03,860
Our next topic is Shape Control by Curves.

2
00:00:05,720 --> 00:00:08,460
And what we introduce here is called
FiberMesh.

3
00:00:11,700 --> 00:00:13,970
And what we propose is an extension of

4
00:00:13,970 --> 00:00:17,860
the previous technique, which called
sketch 3D modeling.

5
00:00:17,860 --> 00:00:22,930
The difference is that original sketch
stays and works as a handle.

6
00:00:22,930 --> 00:00:24,970
So here, the input is very similar.

7
00:00:24,970 --> 00:00:28,030
You draw something and you get 3D shape.

8
00:00:28,030 --> 00:00:33,600
However, unlike previous system, this
curve stays on the surface, and then you

9
00:00:33,600 --> 00:00:37,320
can graph them and move them around and
then they form the shape.

10
00:00:37,320 --> 00:00:38,380
Let me show you a demo.

11
00:00:40,930 --> 00:00:43,150
So again, input is very similar.

12
00:00:43,150 --> 00:00:47,970
Here's a just draw a line, and the system
inflates it.

13
00:00:47,970 --> 00:00:53,370
However, as you see, your input stroke
stays there and this serves as a handle.

14
00:00:53,370 --> 00:00:55,959
So you can grab them, and move upwards.

15
00:00:57,530 --> 00:01:00,580
And then, soft continuously changes.

16
00:01:00,580 --> 00:01:05,610
You can see it from the top, and then you
can pull it sideways to see the shape.

17
00:01:05,610 --> 00:01:08,770
In this way, you can get more control, and
you can get

18
00:01:08,770 --> 00:01:14,640
more smooth shapes, which was not possible
in the polygon based system.

19
00:01:14,640 --> 00:01:18,600
And you can also add more contour curves
in this way.

20
00:01:18,600 --> 00:01:22,180
And then you can grab this thing, to
change the shape.

21
00:01:26,170 --> 00:01:30,190
And then like previously same you can also
add an arm.

22
00:01:35,560 --> 00:01:40,820
And from the sideways, you can pull it
down to change the shape.

23
00:01:40,820 --> 00:01:44,130
And here, as you see, we have two kinds of
curves.

24
00:01:44,130 --> 00:01:47,470
The blue curves is a kind of smooth
constraint, and

25
00:01:47,470 --> 00:01:51,180
the red curve is, as you see, a sharp
constraint.

26
00:01:51,180 --> 00:01:53,930
And of course, you can change the
categories.

27
00:01:53,930 --> 00:01:59,890
For example, if you change them to a blue,
you know, as you see.

28
00:01:59,890 --> 00:02:02,940
You will get a smooth rendition and, if
you

29
00:02:02,940 --> 00:02:07,070
want you can also erase them to remove any
constraint.

30
00:02:08,120 --> 00:02:10,270
And you will get a very smooth shape.

31
00:02:10,270 --> 00:02:11,840
As an example is here.

32
00:02:11,840 --> 00:02:13,440
You draw a shape here,

33
00:02:15,530 --> 00:02:16,920
and then you draw a shape here.

34
00:02:18,270 --> 00:02:21,290
And here this is to literally to motion.

35
00:02:21,290 --> 00:02:23,940
And if you want, you can make them sharp,

36
00:02:27,950 --> 00:02:29,672
and then you're going to get this kind of
shape.

37
00:02:29,672 --> 00:02:31,520
All right.

38
00:02:31,520 --> 00:02:33,870
Let me show you a couple more examples.

39
00:02:33,870 --> 00:02:39,450
Here you get this shape, and then you cut
it here like this way.

40
00:02:41,860 --> 00:02:43,190
And then you get the shops, shapes.

41
00:02:43,190 --> 00:02:46,650
And then if you erase these parts,

42
00:02:50,380 --> 00:02:51,600
you can get shape.

43
00:02:51,600 --> 00:02:57,200
So here, you know, smooth shape,
discontinuity

44
00:02:57,200 --> 00:03:00,150
here, but so this part is going around.

45
00:03:00,150 --> 00:03:03,150
And then again, you meet at a sharp
crease.

46
00:03:03,150 --> 00:03:09,890
This is not easy to do compared to other
approaches.

47
00:03:09,890 --> 00:03:14,780
You can use [INAUDIBLE] it's always
smooth, if you use this

48
00:03:14,780 --> 00:03:20,020
they are continuous boundaries and this is
not easy.

49
00:03:26,030 --> 00:03:28,470
And after combining these operations, you
can

50
00:03:28,470 --> 00:03:30,690
get these and other good shapes like
these.

51
00:03:30,690 --> 00:03:35,060
You can make this kind of mask or a human
body.

52
00:03:35,060 --> 00:03:37,070
Or arms and so on.

53
00:03:37,070 --> 00:03:42,638
And the point here is that, traditional
methods require the user to design.

54
00:03:42,638 --> 00:03:46,845
Is models by manipulating individual
control body, but

55
00:03:46,845 --> 00:03:49,396
here I use a control over a curves.

56
00:03:49,396 --> 00:03:53,540
And then we hope that this is a more
intuitive and more efficient.

57
00:03:55,950 --> 00:03:58,120
And let me describe the algorithm behind
the scene.

58
00:03:58,120 --> 00:04:02,950
So basic idea behind it is a user controls
a curve.

59
00:04:02,950 --> 00:04:05,780
And the curves define the boundary, and
the

60
00:04:05,780 --> 00:04:09,890
system automatically generates the smooth
surface based on the

61
00:04:09,890 --> 00:04:14,500
curves by running a continuous
optimization, trying to

62
00:04:14,500 --> 00:04:17,610
make a smooth surface as defined by the
curves.

63
00:04:17,610 --> 00:04:19,200
So that's the basic idea.

64
00:04:19,200 --> 00:04:21,610
Now let me describe the details.

65
00:04:21,610 --> 00:04:24,100
So curve deformation takes handle position
as the

66
00:04:24,100 --> 00:04:29,160
input, and then generates curve geometry,
updated curve geometry.

67
00:04:29,160 --> 00:04:32,290
And the surface optimization takes curve
geometry as

68
00:04:32,290 --> 00:04:35,340
the input, and then generates a smooth
surface.

69
00:04:35,340 --> 00:04:37,470
And let me describe the curve deformation
first.

70
00:04:39,290 --> 00:04:42,230
So curve deformation works like this way.

71
00:04:42,230 --> 00:04:44,250
So you have this shape.

72
00:04:44,250 --> 00:04:50,140
Input save, and then each segment has
three dimensional coordinate frames.

73
00:04:50,140 --> 00:04:53,540
Then, if you pull one point upwards, and

74
00:04:53,540 --> 00:04:56,790
then an assistant will define the entire
curve.

75
00:04:56,790 --> 00:05:02,740
Then, as you pull upwards, all coordinate
frames also rotate together.

76
00:05:02,740 --> 00:05:08,870
What we do is simultaneously updates its
position, its rings, and also

77
00:05:08,870 --> 00:05:15,509
quotation coordinate frame for individual
segments, curve segments.

78
00:05:15,509 --> 00:05:17,950
This is a quick overview.

79
00:05:17,950 --> 00:05:23,510
Please refer to paper for the details.

80
00:05:23,510 --> 00:05:26,920
Minimize these functional, right, moving

81
00:05:26,920 --> 00:05:31,440
around quadrics positions and digital
rotations.

82
00:05:31,440 --> 00:05:34,644
So we try to find very good more smooth

83
00:05:34,644 --> 00:05:39,694
quadric position and edgy digital
rotations and minimize this.

84
00:05:39,694 --> 00:05:44,110
And what we minimizes here, is that
difference.

85
00:05:44,110 --> 00:05:44,610
So this is

86
00:05:47,020 --> 00:05:48,980
this is a small laplacian which means,

87
00:05:48,980 --> 00:05:54,420
difference observed current position from
the surrounding position,

88
00:05:54,420 --> 00:05:57,310
and then the current difference is rotated
and

89
00:05:57,310 --> 00:06:01,640
it is compared to the current updated
laplacian.

90
00:06:01,640 --> 00:06:04,390
And this preserves the local details.

91
00:06:04,390 --> 00:06:08,760
And this one tries to minimize the
difference between neighboring rotations.

92
00:06:08,760 --> 00:06:11,452
So this tries to achieve smoother
rotations.

93
00:06:11,452 --> 00:06:16,840
And then this one is tries to minimize
difference between current position and

94
00:06:16,840 --> 00:06:22,660
the position of this line positions, the
nearby positions.

95
00:06:22,660 --> 00:06:25,656
So, each one is a smooth position.

96
00:06:25,656 --> 00:06:28,760
this, try to minimize the difference

97
00:06:28,760 --> 00:06:32,780
between original position and updated
position.

98
00:06:32,780 --> 00:06:34,990
Similarly, this one tries to minimize

99
00:06:34,990 --> 00:06:38,670
previous current rotation and updated
rotation.

100
00:06:38,670 --> 00:06:44,640
So by solving this system, system tries to
find a smooth deformation.

101
00:06:46,960 --> 00:06:48,590
Next one is Surface Optimization.

102
00:06:48,590 --> 00:06:54,870
And surface optimization takes as input a
curve geometry and a mesh topology.

103
00:06:54,870 --> 00:06:56,760
And this is the input.

104
00:06:56,760 --> 00:06:59,940
And then system will automatically
generate smooth surface.

105
00:06:59,940 --> 00:07:05,090
To do so system basically tries to
minimize variation of curvature.

106
00:07:05,090 --> 00:07:07,710
You know, curvature is how curved the
surface is.

107
00:07:07,710 --> 00:07:10,440
And then by minimizing the variation of

108
00:07:10,440 --> 00:07:13,250
curvature, system tries to generate a
smooth surface.

109
00:07:14,340 --> 00:07:18,160
In a mathematical representation, it looks
like this.

110
00:07:18,160 --> 00:07:23,560
So, Kn is a curvature, and then Kn
derivative

111
00:07:23,560 --> 00:07:29,030
in both [INAUDIBLE] axis and second axis,
and then this represents

112
00:07:29,030 --> 00:07:33,940
curvature, and then curvature variations,
and then we try to minimize this.

113
00:07:33,940 --> 00:07:34,440
And

114
00:07:36,180 --> 00:07:39,390
now fortunately this is no linear program.

115
00:07:39,390 --> 00:07:42,870
It's not easy to, or efficient to compute.

116
00:07:42,870 --> 00:07:49,660
So we approximate this by couple stepwise
linear computations like this.

117
00:07:49,660 --> 00:07:53,520
A little bit complicated, but luckily we
have two parts.

118
00:07:53,520 --> 00:07:54,680
Two passes.

119
00:07:54,680 --> 00:08:02,460
So one is cover up, so left flow computes
curvatures.

120
00:08:02,460 --> 00:08:06,325
So we first computer curvatures which is a
scale of values,

121
00:08:06,325 --> 00:08:11,340
and then by blending or smoothing out we
get target curvatures.

122
00:08:11,340 --> 00:08:16,500
So as you see, originally curvature has
many variations.

123
00:08:16,500 --> 00:08:21,460
But by smoothing out, you get a more
uniform target curvature values.

124
00:08:21,460 --> 00:08:25,030
So we tried to obtain these curvature
values.

125
00:08:25,030 --> 00:08:28,060
And from these curvature values,
multiplied by a

126
00:08:28,060 --> 00:08:32,220
surface normal, you get target laplacian
vertices, vectors.

127
00:08:32,220 --> 00:08:36,580
So we try to obtain this lapracian
vectors.

128
00:08:36,580 --> 00:08:40,010
In parallel, we also compute edge lengths.

129
00:08:40,010 --> 00:08:42,920
So free for us to compute current edge
lengths.

130
00:08:42,920 --> 00:08:47,420
And then we compute target edge lengths,
by blending or smoothing out.

131
00:08:47,420 --> 00:08:50,620
And then, multiply this target edge
lengths with

132
00:08:50,620 --> 00:08:54,080
current edge vectors, you get target edge
vectors.

133
00:08:54,080 --> 00:08:58,120
And by combining these target laplacian
vectors and target edge

134
00:08:58,120 --> 00:09:03,910
vectors, we solve earliest square problem
and you updated geometry.

135
00:09:03,910 --> 00:09:08,820
And the way you repeat multiple times, and
then you get optimized smooth shape.

136
00:09:10,520 --> 00:09:13,910
So original paper was called FiberMesh

137
00:09:13,910 --> 00:09:16,809
designing free-form surfaces with 3D
curves.

138
00:09:17,950 --> 00:09:23,620
And similar technique that he's trying to

139
00:09:23,620 --> 00:09:28,620
gradually changing the safe considering
local details was originally a

140
00:09:28,620 --> 00:09:33,640
presented at sketched based interface for
detail-preserving mesh editing.

141
00:09:33,640 --> 00:09:38,660
And also our technique is kind of also
learning surface fairing continuously.

142
00:09:38,660 --> 00:09:42,710
And it was inspired by work by geometric
fairing

143
00:09:42,710 --> 00:09:47,040
or or irregular meshes for three, for
free-from surface design.

144
00:09:47,040 --> 00:09:49,510
And we recommend to take a look at these
works.