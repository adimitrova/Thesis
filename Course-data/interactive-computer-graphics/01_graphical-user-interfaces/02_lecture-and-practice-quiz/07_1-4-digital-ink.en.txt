Our next topic is digital ink. And so what we introduce here is called
Flatland. And the research goal here is design
computational augmented office whiteboard. So, in, work, in many workplaces there is
a whiteboard, near the desk, or near the
walking meeting space. And then you got people take various
notes. So we try to provide computational
support. This kind of computational this kind of
whiteboard. And this work started with an ob,
observation that office whiteboards are used for informer, informal product, pre-production
activities. So examples are note taking while you are
on a phone. Or organizing to do list. Or sketching paper outlines, or discussion
with other office mate. So this kind offi offline informal
discussions is what we want to support. And so this was it was, this was from
users point of view. From system design's point of view, what
we try to do is to design a computational system that
complements client desktop computers. So suppose we have desktop computers, and
then whiteboards. And these very complementary. For example the tasks on the desktop
computer is very goal oriented. You have a space for goal, prepare
document, prepare presentation make a email and so
on. However works, activities on a white board
is very informal and very pre-productive. There is no space for goal in many cases. And then, operation on desktop computers
can be very tedious or complicated because you
have to satisfy many constraints however, white board is
very easy, just pick up a pen, and then write down. So its very lightweight, simple and easy. And then finally visual representation on
desktop computers are very formal and typed you see typed text, but however visuals on disc of white boards are very, very
informal. So these are the differences and then we
try to support these kind of activities. And, so, the system we proposed has three
features. And one, is a way to manage space. The other is to applications running on this surfaces, and also history
management. So let me show you a demo. [SOUND] So suppose you have a whiteboard
and you pick up a pen, and [INAUDIBLE] do writing
here. So I use mouse here, but please assume
that I'm using a pen on a whiteboard. And then you can take various notes, such
as like a phone number or you may want to take a note or about a
schedule. [SOUND] Or you maybe just like drawings,
or you may want to draw a map. And as you see, system starts to cluster. Nearby [UNKNOWN] automatically. And then you can grab a cluster, and then
move around. So, this is very convenient. You do not need [UNKNOWN] to get that one
up. Or you can manually spread. To grab clusters away and so. And one important program seen here is
that visibility is very important. If you have desktop Windows, Windows
starts to overlap each other soon. But however, visibility is important here
so, you should be able to see all information, all the
time. So, as you start dragging and if it
collides with other segment, it starts the push
other segments away. So, in this way, system pretty bends,
overlapping. And if no more space available, it starts
to shrink. So, in this way. You can still see the content of the
[INAUDIBLE], but you can use limited screen space very
efficiently. And you can just click and start drawing,
and click and start drawing. We also support [UNKNOWN] to other seats,
like this way. So this is kind of infinite screen
connected by horizontally infinite screen space. So this is the screen management. And the next feature is applications. So here is a [UNKNOWN]
application we support here. Like we have to sleep or you may want to
eat, and you also need to work. And then you can change priorities, or you
can delete them. So here we can use visceral interaction
using pen gestures. And then another application is map
drawings. So you can do a line, and you can get a map or you can erase and you can get a
map. So you just, just draw a single strokes,
the system automatically makes them a map. And one important feature here is that
application can be removable. Here it becomes to view a simple plain
drawing and you can add other operation
applications like this one. This is a beautification of your. Informal handwriting. [SOUND] Look at this. [SOUND] So another example is [UNKNOWN]. You draw numbers here and you draw lines
and then you look at the result. We also implemented 3D drawing. And you draw something, and you can
rotate, and you can cut, and then you can rotate. And if you remove this guy, then you can
draw notations and so. And finally the last feature is history
management. So system remains, remembers everything
you do on this whiteboard, and then you can get
previous state. For example, if you draw many many lines,
for a long time, then you erase, the system records
everything in the database. And then if you get slider here. You can go back to any previous state, in
the history. And then can go jump, to a previous state. And as our feature is context space
search. So, as I said, system remembers all
activity on whiteboard, and later you can search them, just by time or used
behaviors, or size, or colors, and so on. And here's an example. The system searches for the previous
drawings activities, on this whiteboard. And you can get these instantly. So that's a demo. [SOUND] Yeah, yeah, here's an example of
context-based search. So let me describe the videos here. So user input here consists of two kinds. One is primary input is given by standard
ink strokes, mouse left button, and it is
always ink strokes. And secondary input like the other side of
pen or pen down is bottom down is always a
control strokes and then input strokes is always inking so its
always up growing on the screen and then control stroke is
for controlling applications. So it can be a eraser, or can be dragging or existing object or
splitting over segment. Or a pie and the marking menu. A pie and marking menu is a laterally
arranged menus. And let me briefly describe the
architecture behind the system. So this can be seen as a kind of pen
version. Standard graphical user interface Window
system. So here a comparison, so we have Standard
Graphical User Interface and our Flatland. So Standard Graphical User Interface use a
mouse, but here we use a pen, and then Standard GUI use widgets and pixels and
here everything in strokes. And Graphical User Interface use Windows
but here we use more informal segments, and then Graphical
User Interface applications corresponds behaviors and the important thing here is
that in GUI Windows and applications are very, how to say consis,
persistent object. And application is tightly connected to
Windows, but here, segments can be merged or split. And also, behaviors can be flexibly
attached or removed compared to the Windows and
applications. And here's a structure in Standard
Graphical User Interface Windows system. You know, data is, and handled by
applications. Application encapsulates internal data,
and then take mouse input, and then generates display
output. Using various, rejects. In contrast, in our case. You know, behaviors outside of the strokes
and then it opens up the strokes on the board and then add strokes
and removes strokes and so on. So, behavior works as an attached service
to the whiteboard. [SOUND] yeah, here is a little bit more
details. So here's a code example of a behavior. So this is PlainDrawingBehavior. So this one takes inputstroke, and then
just put in the stroke. And the code looks like this. So, addInputStroke, handle's InputStroke. And then just put, painted stroke to the
segment. So it's plain drawing behavior. And in the case of map behavior, it takes
[INAUDIBLE] stroke and then two sided street, the code
looks like this. So for add input stroke event, the input stroke is divided into left and right
stroke. And then these are individually added to
the segment. So, yeah here's a summary, the program we
want to address is management of multiple
informal tasks on a electronic whiteboard system and then we
presented kind of window system for this link with very,
very flexible structures. And here's further reading. The original work was published as Flatland, New Dimensions in Office
Whiteboards. And if you learn more about gesture recognition, there are a couple pointers
here. The Rubine, specifying gestures by example
is a very original work on example based gesture recognition,
which was published in 91. And the reason to why is one example
reason to why is gesture without libraries, toolkits or training a $1
recognizer for user interface prototypes. And also I showed pie menu and marking
menu here. And this is interesting widget, popular in
pen computing. And you, I also recommend that you take a
look into this literature. Thank you.