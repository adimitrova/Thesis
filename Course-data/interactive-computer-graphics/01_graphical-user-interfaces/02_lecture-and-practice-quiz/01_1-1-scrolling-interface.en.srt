1
00:00:00,828 --> 00:00:03,820
Hello this is Interactive Computer
Graphics week 1.

2
00:00:03,820 --> 00:00:07,970
The topic we discuss this week is
Graphical User Interfaces.

3
00:00:09,820 --> 00:00:14,430
Graphical user interface is windows,
icons, menus and so on,

4
00:00:14,430 --> 00:00:18,640
and it turns computer controlled program
into visual problem solving.

5
00:00:18,640 --> 00:00:21,500
So whenever you interact with computers or
your smart

6
00:00:21,500 --> 00:00:25,119
phone you always have to solve some video
problem solving.

7
00:00:26,640 --> 00:00:27,960
Visual problem.

8
00:00:27,960 --> 00:00:30,940
In this lecture, this week we introduce
five

9
00:00:30,940 --> 00:00:34,650
attempts to improve current graphical user
interface operations.

10
00:00:35,790 --> 00:00:39,330
And here the list of topics we discuss
here in this week.

11
00:00:39,330 --> 00:00:41,010
The first is scrolling interfaces.

12
00:00:41,010 --> 00:00:44,500
The second is manipulation of desktop
icons.

13
00:00:44,500 --> 00:00:47,120
And then pointing by mouse cursor.

14
00:00:47,120 --> 00:00:49,530
And then handling of digital ink.

15
00:00:49,530 --> 00:00:52,960
And then finally we will introduce a
technique for voice interaction.

16
00:00:54,250 --> 00:00:56,090
The first one is scroll interface.

17
00:00:57,270 --> 00:00:59,570
The work we introduce here is called

18
00:00:59,570 --> 00:01:03,199
speed dependent automatic zooming for
browsing large documents.

19
00:01:04,720 --> 00:01:07,380
And the problem we want to address here,
is

20
00:01:07,380 --> 00:01:10,972
that a navigation of a large document is
difficult.

21
00:01:10,972 --> 00:01:14,669
currently, dominant techniques is
scrolling and zooming.

22
00:01:14,669 --> 00:01:17,760
So scrolling usually use a scroll bar.

23
00:01:17,760 --> 00:01:21,910
However, it can be tedious sometimes to
control very small knob.

24
00:01:21,910 --> 00:01:25,532
And you can also use light based speed
depending scrolling.

25
00:01:25,532 --> 00:01:29,130
But it's very hard to control when you are
moving too fast.

26
00:01:29,130 --> 00:01:32,565
Typical approach is to use zooming
interfaces to largen

27
00:01:32,565 --> 00:01:36,790
[UNKNOWN] documents, but we have to
combine scrolling and zooming.

28
00:01:36,790 --> 00:01:38,090
And can be confusing.

29
00:01:38,090 --> 00:01:41,250
Let me describe with specific examples.

30
00:01:41,250 --> 00:01:43,180
So here is an example.

31
00:01:45,820 --> 00:01:50,306
Okay, so here you have a very long
document.

32
00:01:50,306 --> 00:01:57,820
And then, if you want to scroll, if you
first acquire a very small knob.

33
00:01:57,820 --> 00:01:59,820
And then you start logging.

34
00:01:59,820 --> 00:02:02,389
However, if the document is very long,

35
00:02:02,389 --> 00:02:05,620
very small mouse movement, causes a big
jump.

36
00:02:05,620 --> 00:02:07,220
And can be difficult.

37
00:02:07,220 --> 00:02:10,334
And also one difficult, important problem
is that

38
00:02:10,334 --> 00:02:13,540
this kind of chapter structure, is not
visible.

39
00:02:13,540 --> 00:02:16,660
So, if you want to go to, for example,
chapter 9.

40
00:02:16,660 --> 00:02:20,680
And it 's very time consuming to find
chapter 9.

41
00:02:20,680 --> 00:02:24,224
And another possible interface is write
based scrolling

42
00:02:24,224 --> 00:02:27,764
or speed dependent scrolling, so you press
wheel of

43
00:02:27,764 --> 00:02:30,122
a mouse and you get this the widget

44
00:02:30,122 --> 00:02:34,400
and then you can start scrolling without
controlling speed.

45
00:02:34,400 --> 00:02:38,830
And it's okay when you're moving slowly,
but as soon as you move too fast.

46
00:02:38,830 --> 00:02:40,770
You know, you have no idea of what's going
on.

47
00:02:40,770 --> 00:02:42,580
It, it's very difficult to navigate.

48
00:02:42,580 --> 00:02:45,140
For example, if you want to go to Chapter
6,

49
00:02:45,140 --> 00:02:50,425
you know it's very hard to do it using
this interface.

50
00:02:50,425 --> 00:02:52,500
[SOUND]

51
00:02:52,500 --> 00:02:59,380
And The similar program happens in as
operate, applications.

52
00:02:59,380 --> 00:03:03,020
This is an example of map navigation.

53
00:03:03,020 --> 00:03:06,290
And again if you are moving slowly it's
fine.

54
00:03:06,290 --> 00:03:09,360
But as you start moving faster and faster,

55
00:03:09,360 --> 00:03:11,580
it's very hard to understand what's going
on.

56
00:03:11,580 --> 00:03:14,950
So typical approach is to manually zoom
out.

57
00:03:14,950 --> 00:03:20,150
And acquire target and move, and zoom in,
and move, and zoom in.

58
00:03:20,150 --> 00:03:24,290
But you have to switch, go back and forth,
between scrolling and zooming.

59
00:03:24,290 --> 00:03:26,700
And it can be very inefficient and
tedious.

60
00:03:28,360 --> 00:03:28,950
And now.

61
00:03:31,160 --> 00:03:34,321
So what we propose here is to
automatically

62
00:03:34,321 --> 00:03:38,250
zoom in and zoom out depending on your
speed.

63
00:03:38,250 --> 00:03:39,420
So.

64
00:03:39,420 --> 00:03:44,560
If you're moving, you start from slowly,
and then moving fast, and then slow down.

65
00:03:44,560 --> 00:03:46,630
And as you change the speed in this

66
00:03:46,630 --> 00:03:51,090
way, system automatically changes the
scale of the screen.

67
00:03:51,090 --> 00:03:52,840
So in this way, is the user can

68
00:03:52,840 --> 00:03:57,320
navigate through large information space,
just by controlling speed.

69
00:03:57,320 --> 00:04:03,755
So, let me show you a demo again [SOUND]
So here the same

70
00:04:03,755 --> 00:04:11,235
program, but here we enabled automatic
zooming.

71
00:04:11,235 --> 00:04:13,490
So when you are moving slowly, nothing
happens.

72
00:04:13,490 --> 00:04:18,930
But as you move faster and faster, system
automatically changes scale.

73
00:04:18,930 --> 00:04:19,890
So here.

74
00:04:19,890 --> 00:04:23,540
Your speed in the information space is
very fast now.

75
00:04:23,540 --> 00:04:29,450
But thanks to the zooming, the peak cell
flow speed is consistent, constant.

76
00:04:29,450 --> 00:04:33,850
And you move faster, and then acquire
target and slow down.

77
00:04:33,850 --> 00:04:36,100
So in this way, you can navigate through

78
00:04:36,100 --> 00:04:40,510
a large information space very smoothly,
and efficiently.

79
00:04:40,510 --> 00:04:41,960
Just by controlling speed.

80
00:04:44,330 --> 00:04:47,048
And you can do the same thing with a web
browsing.

81
00:04:47,048 --> 00:04:52,990
Again, without zooming, if you move fast,

82
00:04:52,990 --> 00:04:54,870
it's very hard to understand what's going
on.

83
00:04:56,110 --> 00:04:59,500
With automatic zooming, when you're moving
faster.

84
00:04:59,500 --> 00:05:05,460
System starts to shrink, so here, your
speed is already very fast.

85
00:05:05,460 --> 00:05:08,830
So it can be difficult to understand
what's going on without zooming.

86
00:05:08,830 --> 00:05:13,340
But thanks to zooming, pixel flow remains
constant, constant,

87
00:05:13,340 --> 00:05:15,730
and you can keep track of what's going on.

88
00:05:15,730 --> 00:05:18,770
And in addition, the system makes chapter
structures visible.

89
00:05:18,770 --> 00:05:20,350
So it's very easy to.

90
00:05:21,360 --> 00:05:24,189
Go to specific chapter, using this
interface.

91
00:05:24,189 --> 00:05:27,900
Like chapter 4.

92
00:05:27,900 --> 00:05:31,610
And these techniques can be very useful,
[INAUDIBLE] as our applications too.

93
00:05:31,610 --> 00:05:33,960
So this is an image browser.

94
00:05:33,960 --> 00:05:38,670
And again, without zooming, it's very hard
to understand what's going on.

95
00:05:38,670 --> 00:05:44,840
So, neighbouring adjacents, snapshot, and
then, next, and then two blocks.

96
00:05:44,840 --> 00:05:46,980
It's [UNKNOWN] to understand what's going
on.

97
00:05:46,980 --> 00:05:49,070
But with zooming, you know, system

98
00:05:49,070 --> 00:05:51,240
automatically zoom out, depending on
speed.

99
00:05:51,240 --> 00:05:53,990
And it's very easy to understand, what's
going on.

100
00:05:53,990 --> 00:05:59,220
Next image, and then two image, after this
one.

101
00:05:59,220 --> 00:06:02,030
So this is like reading a very big
newspaper.

102
00:06:02,030 --> 00:06:05,790
You know, when you are reading here, and
moving to the next,

103
00:06:05,790 --> 00:06:10,210
you go to see the entire overview, and
then go to the next.

104
00:06:10,210 --> 00:06:14,970
And this interface naturally [UNKNOWN],
represent this kind of interaction.

105
00:06:16,920 --> 00:06:18,280
So that's a demonstration.

106
00:06:20,292 --> 00:06:24,930
And let me briefly describe, discuss some
implementation issues behind the scene.

107
00:06:26,040 --> 00:06:28,590
So, the basic algorithm is very, very
simple.

108
00:06:28,590 --> 00:06:32,210
This is a governing equation, basic
equation.

109
00:06:32,210 --> 00:06:36,650
So a scale, multiplied by speed, remains
constant.

110
00:06:36,650 --> 00:06:40,830
So which means, if your speed is faster,
speed is larger.

111
00:06:40,830 --> 00:06:43,880
Scale get's smaller and then speed is
smaller.

112
00:06:43,880 --> 00:06:45,060
And then scale gets larger.

113
00:06:45,060 --> 00:06:47,280
So it's so simple, and easy to implement.

114
00:06:49,980 --> 00:06:52,160
So, this ensures that the perceptual
scrolling

115
00:06:52,160 --> 00:06:54,400
space, speed, on the screen remains
constant.

116
00:06:54,400 --> 00:07:00,880
However this naive implementation has some
problems.

117
00:07:01,890 --> 00:07:06,090
So, two problems, sudden zoom-out at the
beginning of

118
00:07:06,090 --> 00:07:11,110
scrolling, and then also abrupt swelling
at turning the directions.

119
00:07:11,110 --> 00:07:13,470
Let me describe one by one, the first

120
00:07:13,470 --> 00:07:17,590
one is sudden zoom-out, so let me describe
here.

121
00:07:17,590 --> 00:07:20,830
So naive implementation of this technique
is fast.

122
00:07:20,830 --> 00:07:24,410
We said speed, proportional to mouse
movement.

123
00:07:24,410 --> 00:07:26,950
As in stand out like they're scrolling.

124
00:07:26,950 --> 00:07:31,250
And then scale is calculated based on the
equation 1.

125
00:07:31,250 --> 00:07:32,940
So here's a diagram.

126
00:07:32,940 --> 00:07:39,410
So you change the mouse position and then
speed, linearly increases.

127
00:07:39,410 --> 00:07:40,340
Based on this equation.

128
00:07:40,340 --> 00:07:45,118
Speed equals constant by [SOUND] dy, mouse
position.

129
00:07:45,118 --> 00:07:46,610
And you get speed.

130
00:07:46,610 --> 00:07:50,840
And then based on the equation 1, you get
this speed.

131
00:07:50,840 --> 00:07:53,090
However, look at here.

132
00:07:53,090 --> 00:07:57,710
As soon as you start zooming, scale
suddenly drops.

133
00:07:57,710 --> 00:08:00,440
So this sudden drop is very very

134
00:08:00,440 --> 00:08:03,500
annoying, if you're actually interacting
with a system.

135
00:08:05,210 --> 00:08:10,590
So but thinking about zooming, zooming
should be exponential.

136
00:08:10,590 --> 00:08:14,710
As you move your mouse, scale should be.

137
00:08:14,710 --> 00:08:18,338
Multiplied with the same ratio each time.

138
00:08:18,338 --> 00:08:22,510
For example, as the mouse move here and
then scale [UNKNOWN] half,

139
00:08:22,510 --> 00:08:26,500
and now they move faster and the scale
[UNKNOWN] in a half again.

140
00:08:28,040 --> 00:08:33,100
So revised implementation, is scale is
exponential to

141
00:08:33,100 --> 00:08:38,610
mouse movement first, and then speed is
calculated based on equation first.

142
00:08:38,610 --> 00:08:39,550
So, here's a diagram.

143
00:08:41,430 --> 00:08:44,067
So as soon as you start scaling,

144
00:08:44,067 --> 00:08:48,910
then scale is exponential function of
mouse position.

145
00:08:48,910 --> 00:08:49,670
Like, like this.

146
00:08:49,670 --> 00:08:53,290
So this will show very constant, smooth
scaling.

147
00:08:53,290 --> 00:08:57,780
Then after that, you compute speed, based
on the equation 1.

148
00:08:57,780 --> 00:08:58,280
As a.

149
00:08:59,580 --> 00:09:01,140
You know, inverse proportional.

150
00:09:01,140 --> 00:09:02,610
And then in this way, you will get

151
00:09:02,610 --> 00:09:06,770
a very smooth introduction, as shown in my
demonstration.

152
00:09:09,560 --> 00:09:13,760
And then, second problem is abrupt
swelling at turning.

153
00:09:13,760 --> 00:09:16,890
Suppose you are moving downwards fast.

154
00:09:16,890 --> 00:09:20,290
And then, you moved a mouse upwards.

155
00:09:20,290 --> 00:09:23,830
And then you change the directions, and
then go up.

156
00:09:23,830 --> 00:09:25,610
And then do this.

157
00:09:25,610 --> 00:09:28,372
On here, you know, as you change the

158
00:09:28,372 --> 00:09:34,760
direction, velocity and [UNKNOWN] temp,
temp, temporarily becomes zero.

159
00:09:34,760 --> 00:09:36,030
Which means.

160
00:09:36,030 --> 00:09:39,660
That scale, equals suddenly zero.

161
00:09:39,660 --> 00:09:45,260
Which means that as you change direction
in a screen abruptly it gets larger.

162
00:09:45,260 --> 00:09:47,050
Which is very very annoying.

163
00:09:47,050 --> 00:09:50,350
So one possible solution is like this.

164
00:09:50,350 --> 00:09:54,160
So we introduce delay, in scale change.

165
00:09:54,160 --> 00:09:57,900
So as you change the direction, then

166
00:09:57,900 --> 00:10:01,680
zooming scale changes slowly, and then
when,

167
00:10:01,680 --> 00:10:06,690
when you go back to the ori, original
speed, and then scale will be recovered.

168
00:10:06,690 --> 00:10:09,450
So this way, you will get a smoother
interaction.

169
00:10:11,160 --> 00:10:15,570
So that's a brief description of the paper
we published at the UIST 2000.

170
00:10:15,570 --> 00:10:22,100
Title, speed, speed-dependent automatic
zooming for browsing large documents.

171
00:10:22,100 --> 00:10:25,340
And here is a couple of pointers for
sources of study.

172
00:10:25,340 --> 00:10:26,810
Further study.

173
00:10:26,810 --> 00:10:28,640
So one is zooming interface.

174
00:10:28,640 --> 00:10:32,250
Zooming interface is very interesting.

175
00:10:32,250 --> 00:10:36,700
A popular topic in user interface and
computer graphic research fields.

176
00:10:36,700 --> 00:10:42,960
Original paper was published as an, at
SIGGRAPH 93 by Ken Perlin.

177
00:10:42,960 --> 00:10:46,080
And you can still see demos here.

178
00:10:46,080 --> 00:10:49,760
And then there are also many follow up
studies and techniques.

179
00:10:49,760 --> 00:10:51,500
And also this work is

180
00:10:54,180 --> 00:10:55,952
One, one example of a research

181
00:10:55,952 --> 00:10:59,810
project with the information visualization
techniques.

182
00:10:59,810 --> 00:11:03,500
And information visualization itself is a
large research field, and

183
00:11:03,500 --> 00:11:07,970
you can learn many more from resources
available on the net.

184
00:11:07,970 --> 00:11:11,217
And also there's a very popular textbook
by

185
00:11:11,217 --> 00:11:16,550
Edward Tufte called The Visual Display of
Quantitative Information.

186
00:11:16,550 --> 00:11:19,091
And I recommend you to take a look at that
book.

187
00:11:19,091 --> 00:11:21,120
That`s it in this video.

188
00:11:21,120 --> 00:11:21,700
Thank you.