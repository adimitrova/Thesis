The next topic is Layer Operations. So this work is titled, Apparent Layer Operations for the Manipulation of
Deformable Objects. The problem we discussed discussed here is that interaction with deformable objects
is very difficult. And by deformed object we may hear, this
kind of interrelated stacked closed and also lobs,
and so on. Now typical approach is to round,
continuously, physical assimilation. And then user moves one vortex and then
rely on physics. This is always physically possibly. But this is kind of a little bit
inflexible. You know, you can not penetrate pass an
object and so on. So it's always needs to be physically
bodied. And this can be inflexible in some
situations for modeling purposes. And besides a possibility, it's the
directory control all the vertices one by one. In this way you can do what ever you want. However, it can be very, very, tedious,
right? And you have too many, many control of
vertices. So what we introduce here is one example
of semantic-level operations. By semantics like, layers and so on. So if you look at the physical configuration, here's some want to do sum
operations. But these some operations in some meaning
for operation for the user; like changes order or layers of
this comment. However, from computer to, point of view, this is just a collection of vortex
coordinates. So many, many, numerical values. So additionally we're asked to control
these numerical valued directory. But here we tried to allow the user to
work on this 3D model with semantic-level. Now specifically we want to, we introduce
here is layer a operations for 3D modeling, and I think you know the
three layer operations. So in 2D drawing systems you can always
have a layer ordering. So you can say, go to front or go to back
and so. For example in PowerPoint you can say you
can say go to back and then you will get this
result. And then, go to front and then you will
get this result. So we want to get this kind of operation
for the comments, for the cloth to go front, or front to
back and so on. So so we specifically we introduced two new
techniques here. One is layer swap. So you just click here and then the system
changes the layer ordering. And then the other is, you drag one piece,
and then you can go up, and down, depending on the
user control. So let me show you a demonstration. So you have a three dimensional cloth
placed on the floor, like this one. And then, you can deform it just by
pulling, and pushing, and so on. And here this is just a standard physics
based dragging. So it's always physically bodied. However, for example, if you want to try
to change the layer ordering of this part and this part, it
can be, it suddenly becomes very tedious. You have to move it away. And then move it here, and it comes back. But this takes a lot of steps and then
global configuration changes. And so if you want to swap this blue and
this green, now it's almost impossible. But here what we propose is just a single
click operation to do it. So if you want to swap this layer just, just, click here and the system will
automatically swaps. So it's very subtle but internally the
system do a lot of things. And if you click here, just swap, and
there you will get this instantly. And this operation can be very, very
tedious, if you use standard rigging operation or
robotics space control. Let me show you a couple more examples. So here's an example, so you have green,
purple and blue here. And for example if you try to swap green and purple blue if you click here user want the system to
swap green and blue. But if you, the system do it naively, then
there can be a penetration or intersection
between part one blue. So system automatically analyze it the
same and then try to abort invalid
configurations. So if you click here instead of putting
blue somewhere the system decided to bring the green to the
front to abort intersection. again, the same thing, so if you click
blue, if you want to swap blue and purple, if you just do it, if the purple is on top of green, there'll be a intersection
here, right? So in, in order to prevent an
intersection, or penetration when the user clicks here, the system should push the
purple one all the way to the bottom. And that's what we do here. If you click here, the system
automatically pushes the purple one all the way back. And here is a folded pocket handkerchief. If you click here you still do, you know,
outward penetration and the system will automatically decide to move
the top layer all the way to the bottom. Then you will get this shape. And if you click here the direction of a
spiral completely swaps. And also if you have this one for example
you can do something like this very quickly, just by a successive
breaking, and then you will get the same. So this way of changing the way of making
a knot can be very difficult due to our
traditional approaches. And this is our most complicated case, a
necktie. So we created this shape by many, many
clicks here. And the same operation can be applicable
for a knot or ropes. So if you click here you can swap the
layers and you can quickly change the
configuration of a knot. And then here the same thing you can
change the whole direction of a twist or you can change the configuration
of a net, like this one. [BLANK_AUDIO] Okay, so that's how layer's work. And next operation I will show is layer
hardware dragging. So, in standard dragging, you know, it's a dragged object always on top of existing
one. However, if you press shift key down,
during dragging it will automatically goes below
the colliding clothing. So by combining shift up and shift down,
you go up and then go down and so on. So this is very useful for making a knot
here, so you go up without shift and shift down, and then shift up, and
then shift down, and shift up. So in this way, you can generate a three dimensional knot just by two
dimensional dragging. Okay. So that's a demonstration and let me briefly describe the algorithm behind
this. So layer swap. So, this is a before the layer swap and
then the after the layer swap. Suppose I use a click somewhere here. I use to try to swap yellow with blue. And in order to do the system will
actually do a lot of same inside the box. So first, the system project, 3D
configuration onto the screen space. And then analyze the configuration, and
then, generate a structure for the list graph. List graph is, each subregion represents a
layered structure and then system maintains
adjacency graph of the, regions. And then, depending, starting from this
current configuration. Depending on the user input, system swaps
layers, in this 2.5D representation. The layer is a list graph representation. And then after that, system takes this two
dimensional input configuration, and then
automatically synthesize it, a 3D shape. And then offer a physical acquisition to
get the final, solid shape. So that's what we do. The first step is the project, projection,
and analysis. So projection is from 3D, to 2D vector
representation and the similar technique was presented by
Eisemann is 2009. And then after getting to the
two-dimensional vector, 2.5D representation, we construct a list
graph presentation. And this technique was inspired by a local
layering technique proposed in 2009 here. So in this one call, represents local layering structure and then also adjacency
graph. Okay, so given this list graph you know, 2.5D layer structure, the system updates
the list graph. So this, this is before configuration and
then gets a new configuration. So what it actually do is to change the
ordering of this local layers. However, the important thing is to, to
avoid invalid configurations. So here's an example of invalid
configuration. So type one, invalid configuration is like
this one. So you see the two sub-regions here and
here. And then in the top region about this
region here, blue is on top of purple, and here purple is on
top of blue. So if this kind of configuration happens
then there will be an intersection of penetration
here which means undefinable, so this is type 1 error or
type one invalid configuration, so another
invalid configuration is like this. So this is not so obvious but suppose this
is folded, you know, this is dark blue and the light blue is folded and
connected, and then, and then it's connected layer should
be adjacent. Otherwise, you know, there will be a
penetration, so that's a problem. So what we do is to consider all possible
permutations of layer orders in each region and then tries to find
valid configuration. And to do this we actually do kind of an exhaustive search of all the
combinations in this space. And then after it gets having the updated
list graph, what we do is reconstruct the 3D geometry
from it. And this is two step operation. So first operation is to get geometric reconstruction, so there is no gravity,
there's no physics, just reconstruct
three-dimensional layered structure, just tied up to the computer depths from 2D layer. And then after that, we apply physics you know, apply gravity to get the final
deducted shape. So, in summary, we introduced the layer
operations for cloth and ropes. And them specifically we need to do today a swap single group and change layer
ordering and then change the layer dragging, you can go
above and then go down using a shift key. Then the algorithm for what we do is projection 2.5D representation called
the list graph. So project the order and synthesize go
back to 3D. To learn more, the original paper was published as Apparent Layer Operations for
the Manipulation of Deformable Objects, and 2D
layer operations was introduced as Local
Layering in 2009. So our work is inspired by this work. And also if you want to more about 3D to
2D projection, I recommend you take a look at this Visibility algorithm
for converting 3D meshes into editable 2d
vector graphics. So this one enables to combine from 3D
graphics to 2D vector installations. Thank you.