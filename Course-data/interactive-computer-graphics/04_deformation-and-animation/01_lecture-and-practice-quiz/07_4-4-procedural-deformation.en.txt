Our next topic is procedural deformation. So, that what we introduce here is called ProcDef or Local-to-global Deformation for
Skeleton-free Character Animation. So the goal here is design a flexible
character animation such as jelly fish or worm, or intestine,
like a heart. So important point here is that they are
full body in motion. You know, entire body, every detail is
moving, and also there is a dynamic. You know, it, it's not, how to say freeze
dry animation. They act as a dynamic. If you push, then the formation changes,
and so on. So there are traditional methods. These are the traditional methods. One is skeleton-based. This is most popular skeleton-based
control, like a joint angle control, just we showed in the last
video. This is, technique is useful for character
animation like a human or animals. But you know, if there is no obvious skeleton structure, like a jellyfish, this
technique doesn't work. And [INAUDIBLE] possible approach is
keyframe-based. So, for each timeframe, you specify the shape individually and the system just
[INAUDIBLE] them. However, in order to do this, you have to
specify many, many key poses manually by pushing, allowing,
many vertices, which is very tedious. But more importantly, this kind of keyframe-based cannot calc, handle
dynamics, you know. The motion is kind of fixed animation and it cannot respond to the forces from the
environment. So our approach is the procedure approach. So the user specifies how local regions of
a h, entire body stretch or shrink. And then by assembling them together
system generates a global motion. And the user also designs the patterns of
the local deformations. Like, this is time sequence, you know, stretch, shrink, stretch, shrink,
very quickly. Or slowly, or fast stretch and slowly
shrink, something like that. So let me show you a video. [BLANK_AUDIO] Hm, yes. [BLANK_AUDIO] So here is our result. So this kind of animation is our goal, the full body animation of a flexible body
characters. So the first task is design orientation
field. So given as already said, user first specifies an orientation field. [BLANK_AUDIO] So the the user specifies a layer
structure here actually, so the red layers are intact inside and the
blue is outside. So in this way, user specified the layer
structure. And you will see it like this. So after user paints red inside, blue
outside, system interpolates them to compute a
continuous layers. And after specifyinf layers, user
specifies orientation of extra field on the layer surface. So in here you can specify, user specifies
rotational flow field. So this is a flow field. So now, we have a flow field along this layer surface, and then layer surface
directional vectors, gradient vector. And then you can get the cross-border app
to get a free frame field. So, in this way, you get the global
representation field, inside of an object. Next we define how each individual element
deforms depending on the time. [BLANK_AUDIO] So, in this example we have three fields, this primary direction and second
direction, and third direction. And for each direction, we specify the
pattern, motion pattern. So the top one specifies a change in the
lengths direction and then you [INAUDIBLE] longer
and shorter, longer and shorter. [BLANK_AUDIO] So, yeah, in this way the user specifies a
change in their open shape and then global shape is obtained as a
result of the smaller motions. [BLANK_AUDIO] You can easily represent this kind of
squashing operations as well. So, the previous example, all elements
move simultaneously in the same way. But in order to make it more interesting eh, motion, you can specify it's amplitude
field. So here red and blue has a. We'll put its direction or put it
amplitude. So in this way, if the blue stretches, red
shrinks, and red stretches, blue shrinks. So in this way, you can get this kind of
bending motion. And the previous one is a fixed body for
the entire body. But the next one is propagation. So in this way you can introduce delay. So the formation starts from here and then
slowly [UNKNOWN] slightly data, the formation propagates
here and later and later. So there's a delay in the propagation and
then you will get this kind of, of motion. Propagation of motion. So by combining this kind of phase shift
and amplitude, and orientation field you can get leech
infor, leech animations. So here is a couple results. So this is a worm walking around. And the important thing here is that this
is dynamically computing. Dynamically computed considered in
physics, so as I use [INAUDIBLE] with it, the system continues animation with the formation, but also responding to the
environment. This is not animational pre-programmer
fixed animation. This is different way of making motion. [BLANK_AUDIO] So, there's another [UNKNOWN] as you see we have a collision of [UNKNOWN]
continuously running. So they're in division and moving around,
but also collide with each other and then animation
changes, depending on the collision. And this demonstration is to demonstrate
how fast the algorithm is. [BLANK_AUDIO] And here's another example of a response
to user input. So as the user touches, and then deformation propagates starting from the
user instruction. So you can get this kind of interesting
motion. Yeah, this is a propagation. This an example of heart animation. The user manipulates it. But this is orientation field. [BLANK_AUDIO] And then you can get the heart works as a
pump. [BLANK_AUDIO] So that's it. So as I said, deformation design consists
of two phases. One is the design of the orientation
fields. You have space for a layer structure and a
space for an orientation field. And the after space finds orientation, the user specifies for each orie, each
direction. User specifies a stretch and shrink
pattern, time sequence pattern. So now we will, I will discuss algorithms
seen as global motion from a speci,
user-specified local motions. And in the preprocess is the algorism
consists of the preprocessing part and the animation
seen as process. In the preprocessing, the user inputs,
input is a tetrahedral volumetric mesh. And having the tetrahedral mesh for
individual vertix, individual vertix and we compute a local
region, N. Like this one for individual vertix by
connecting a one beam. One beam is a connection of vertices next
and neighboring to each individual vertex. And after having this local regions in the
animation process, we define local region N depend, depending on the orientation
field and also the timing chart, you know the orientation field defines the
orientation of the stretch squash and then times sequence chart defines, times
sequence pattern defines whether to stretch or
shrink. So in this way, you first deform the individual regions, one by one, stretch or
shrink. And after that, the system assembled them
together to get a robot shape. So that's the basic form. Let me describe in a little bit more
detail. So this is original rest shape. And then this is the current form of the
shape in physical assimilation. And then the task is to define the motion
of the next time frame, starting from this
current time frame shape. So let me describe how to do it. So the original shape, you first compute
the local regions in the free computation. And for each local region, we compute the next time step local regional target
shape. Some part should be shrinked, some parts
will be squa, stretched, and so. So this is deformed local shape. And after that, what the system do is
shape matching. This is the most important part. Shape matching. For each local region, we try to find the
most, best matching position. You know, if you get these three, it tries to match these three by rotating like this
way. So, shape matching applied to find the best matching position now changed,
rotation and translation. And after matching, you know the current
position and desired position. So a system applies force from the current
position to the much desired position. Defined by deformed local shape. And then applied force. After that this is just the standard
physical assimilation. Applied force will [UNKNOWN] applied force
moves towards the position. So here's a summary. So I just introduced animation of
deformable characters like jellyfish, a worm, and so
on. And [UNKNOWN] is a local to global
approach, so user specifies orientation field and
then the deformation pattern, and then each local region
changes accordingly, and then global motion appears as a result of
application. And inside we use a shape matching
dynamics, because it's very fast and stable, fast
and stable. So to learn more, the original paper was
published as processional deformation ProDef,
Local-to-global Deformation for Skeleton-free Character
Animation. And design of orientation is actually
discussing a separate paper called Lapped Solid Textures: Filling a
Model with Anisotropic Textures. So, they used an orientation field to put,
paste textures inside of an object. And that, dynamic simulation we use is
called shape matching. And this is very popular technique in
graphic community, because it's, it's not necessarily physically
accurate, but it's very, very stable. Depending [UNKNOWN] put this very eh,
contradictory, and so on. And I recommend to take a look at these
papers, because they can be very useful. Thank you.