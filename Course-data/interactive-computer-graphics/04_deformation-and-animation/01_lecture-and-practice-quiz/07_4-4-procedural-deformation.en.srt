1
00:00:00,360 --> 00:00:02,580
Our next topic is procedural deformation.

2
00:00:03,630 --> 00:00:05,820
So, that what we introduce here is called

3
00:00:05,820 --> 00:00:12,460
ProcDef or Local-to-global Deformation for
Skeleton-free Character Animation.

4
00:00:12,460 --> 00:00:16,020
So the goal here is design a flexible
character animation

5
00:00:16,020 --> 00:00:20,820
such as jelly fish or worm, or intestine,
like a heart.

6
00:00:20,820 --> 00:00:24,657
So important point here is that they are
full body in motion.

7
00:00:24,657 --> 00:00:29,090
You know, entire body, every detail is
moving, and also there is a dynamic.

8
00:00:29,090 --> 00:00:34,760
You know, it, it's not, how to say freeze
dry animation.

9
00:00:34,760 --> 00:00:37,140
They act as a dynamic.

10
00:00:37,140 --> 00:00:39,760
If you push, then the formation changes,
and so on.

11
00:00:41,480 --> 00:00:43,110
So there are traditional methods.

12
00:00:43,110 --> 00:00:44,380
These are the traditional methods.

13
00:00:44,380 --> 00:00:45,556
One is skeleton-based.

14
00:00:45,556 --> 00:00:49,645
This is most popular skeleton-based
control, like a joint

15
00:00:49,645 --> 00:00:53,020
angle control, just we showed in the last
video.

16
00:00:54,190 --> 00:00:59,080
This is, technique is useful for character
animation like a human or animals.

17
00:00:59,080 --> 00:01:00,460
But you know, if there is no obvious

18
00:01:00,460 --> 00:01:05,042
skeleton structure, like a jellyfish, this
technique doesn't work.

19
00:01:05,042 --> 00:01:08,580
And [INAUDIBLE] possible approach is
keyframe-based.

20
00:01:08,580 --> 00:01:11,830
So, for each timeframe, you specify the

21
00:01:11,830 --> 00:01:14,800
shape individually and the system just
[INAUDIBLE] them.

22
00:01:16,100 --> 00:01:19,370
However, in order to do this, you have to
specify many, many

23
00:01:19,370 --> 00:01:24,746
key poses manually by pushing, allowing,
many vertices, which is very tedious.

24
00:01:24,746 --> 00:01:27,034
But more importantly, this kind of

25
00:01:27,034 --> 00:01:31,250
keyframe-based cannot calc, handle
dynamics, you know.

26
00:01:31,250 --> 00:01:33,750
The motion is kind of fixed animation and

27
00:01:33,750 --> 00:01:37,350
it cannot respond to the forces from the
environment.

28
00:01:39,130 --> 00:01:42,350
So our approach is the procedure approach.

29
00:01:42,350 --> 00:01:49,370
So the user specifies how local regions of
a h, entire body stretch or shrink.

30
00:01:49,370 --> 00:01:54,950
And then by assembling them together
system generates a global motion.

31
00:01:54,950 --> 00:01:57,980
And the user also designs the patterns of
the local deformations.

32
00:01:57,980 --> 00:01:59,520
Like, this is time sequence, you

33
00:01:59,520 --> 00:02:02,290
know, stretch, shrink, stretch, shrink,
very quickly.

34
00:02:02,290 --> 00:02:09,727
Or slowly, or fast stretch and slowly
shrink, something like that.

35
00:02:09,727 --> 00:02:11,368
So let me show you a video.

36
00:02:11,368 --> 00:02:17,730
[BLANK_AUDIO]

37
00:02:17,730 --> 00:02:19,110
Hm, yes.

38
00:02:19,110 --> 00:02:29,864
[BLANK_AUDIO]

39
00:02:29,864 --> 00:02:31,320
So here is our result.

40
00:02:31,320 --> 00:02:33,710
So this kind of animation is our goal,

41
00:02:34,880 --> 00:02:39,190
the full body animation of a flexible body
characters.

42
00:02:45,670 --> 00:02:49,019
So the first task is design orientation
field.

43
00:02:50,280 --> 00:02:55,613
So given as already said, user first

44
00:02:55,613 --> 00:03:00,609
specifies an orientation field.

45
00:03:00,609 --> 00:03:11,167
[BLANK_AUDIO]

46
00:03:11,167 --> 00:03:14,602
So the the user specifies a layer
structure here actually, so

47
00:03:14,602 --> 00:03:17,780
the red layers are intact inside and the
blue is outside.

48
00:03:17,780 --> 00:03:20,680
So in this way, user specified the layer
structure.

49
00:03:24,370 --> 00:03:25,640
And you will see it like this.

50
00:03:25,640 --> 00:03:28,797
So after user paints red inside, blue
outside,

51
00:03:28,797 --> 00:03:32,650
system interpolates them to compute a
continuous layers.

52
00:03:36,040 --> 00:03:39,449
And after specifyinf layers, user
specifies orientation

53
00:03:39,449 --> 00:03:41,620
of extra field on the layer surface.

54
00:03:41,620 --> 00:03:49,050
So in here you can specify, user specifies
rotational flow field.

55
00:03:49,050 --> 00:03:49,945
So this is a flow field.

56
00:03:52,240 --> 00:03:54,250
So now, we have a flow field along this

57
00:03:54,250 --> 00:03:59,970
layer surface, and then layer surface
directional vectors, gradient vector.

58
00:03:59,970 --> 00:04:06,280
And then you can get the cross-border app
to get a free frame field.

59
00:04:10,280 --> 00:04:14,950
So, in this way, you get the global
representation field, inside of an object.

60
00:04:14,950 --> 00:04:20,858
Next we define how each individual element
deforms depending on the time.

61
00:04:20,858 --> 00:04:25,032
[BLANK_AUDIO]

62
00:04:25,032 --> 00:04:28,677
So, in this example we have three fields,

63
00:04:28,677 --> 00:04:35,090
this primary direction and second
direction, and third direction.

64
00:04:35,090 --> 00:04:38,700
And for each direction, we specify the
pattern, motion pattern.

65
00:04:40,518 --> 00:04:44,072
So the top one specifies a change in the
lengths

66
00:04:44,072 --> 00:04:49,922
direction and then you [INAUDIBLE] longer
and shorter, longer and shorter.

67
00:04:49,922 --> 00:04:59,922
[BLANK_AUDIO]

68
00:05:01,694 --> 00:05:06,914
So, yeah, in this way the user specifies a
change in their open shape

69
00:05:06,914 --> 00:05:12,143
and then global shape is obtained as a
result of the smaller motions.

70
00:05:12,143 --> 00:05:18,203
[BLANK_AUDIO]

71
00:05:18,203 --> 00:05:22,958
You can easily represent this kind of
squashing operations as well.

72
00:05:26,390 --> 00:05:30,850
So, the previous example, all elements
move simultaneously in the same way.

73
00:05:30,850 --> 00:05:34,528
But in order to make it more interesting

74
00:05:34,528 --> 00:05:39,659
eh, motion, you can specify it's amplitude
field.

75
00:05:39,659 --> 00:05:43,150
So here red and blue has a.

76
00:05:43,150 --> 00:05:45,650
We'll put its direction or put it
amplitude.

77
00:05:45,650 --> 00:05:52,490
So in this way, if the blue stretches, red
shrinks, and red stretches, blue shrinks.

78
00:05:52,490 --> 00:05:55,390
So in this way, you can get this kind of
bending motion.

79
00:05:58,130 --> 00:06:01,690
And the previous one is a fixed body for
the entire body.

80
00:06:01,690 --> 00:06:03,909
But the next one is propagation.

81
00:06:05,570 --> 00:06:08,560
So in this way you can introduce delay.

82
00:06:10,760 --> 00:06:13,822
So the formation starts from here and then
slowly [UNKNOWN]

83
00:06:13,822 --> 00:06:17,540
slightly data, the formation propagates
here and later and later.

84
00:06:17,540 --> 00:06:23,420
So there's a delay in the propagation and
then you will get this kind of, of motion.

85
00:06:23,420 --> 00:06:24,780
Propagation of motion.

86
00:06:27,220 --> 00:06:30,980
So by combining this kind of phase shift
and amplitude,

87
00:06:30,980 --> 00:06:35,620
and orientation field you can get leech
infor, leech animations.

88
00:06:35,620 --> 00:06:37,310
So here is a couple results.

89
00:06:39,670 --> 00:06:42,130
So this is a worm walking around.

90
00:06:43,820 --> 00:06:47,090
And the important thing here is that this
is dynamically computing.

91
00:06:47,090 --> 00:06:51,746
Dynamically computed considered in
physics, so as I use [INAUDIBLE] with it,

92
00:06:51,746 --> 00:06:54,182
the system continues animation with the

93
00:06:54,182 --> 00:06:57,492
formation, but also responding to the
environment.

94
00:06:57,492 --> 00:07:01,630
This is not animational pre-programmer
fixed animation.

95
00:07:01,630 --> 00:07:04,273
This is different way of making motion.

96
00:07:04,273 --> 00:07:14,273
[BLANK_AUDIO]

97
00:07:17,813 --> 00:07:20,009
So, there's another [UNKNOWN] as you see

98
00:07:20,009 --> 00:07:23,016
we have a collision of [UNKNOWN]
continuously running.

99
00:07:23,016 --> 00:07:26,080
So they're in division and moving around,
but also collide

100
00:07:26,080 --> 00:07:29,570
with each other and then animation
changes, depending on the collision.

101
00:07:31,240 --> 00:07:35,623
And this demonstration is to demonstrate
how fast the algorithm is.

102
00:07:35,623 --> 00:07:40,793
[BLANK_AUDIO]

103
00:07:40,793 --> 00:07:44,540
And here's another example of a response
to user input.

104
00:07:44,540 --> 00:07:47,170
So as the user touches, and then

105
00:07:47,170 --> 00:07:52,170
deformation propagates starting from the
user instruction.

106
00:07:52,170 --> 00:07:54,670
So you can get this kind of interesting
motion.

107
00:07:56,370 --> 00:07:57,890
Yeah, this is a propagation.

108
00:08:04,160 --> 00:08:07,976
This an example of heart animation.

109
00:08:07,976 --> 00:08:09,410
The user manipulates it.

110
00:08:09,410 --> 00:08:10,908
But this is orientation field.

111
00:08:10,908 --> 00:08:14,814
[BLANK_AUDIO]

112
00:08:14,814 --> 00:08:17,527
And then you can get the heart works as a
pump.

113
00:08:17,527 --> 00:08:27,527
[BLANK_AUDIO]

114
00:08:31,088 --> 00:08:32,680
So that's it.

115
00:08:36,690 --> 00:08:40,005
So as I said, deformation design consists
of two phases.

116
00:08:40,005 --> 00:08:41,940
One is the design of the orientation
fields.

117
00:08:41,940 --> 00:08:46,520
You have space for a layer structure and a
space for an orientation field.

118
00:08:46,520 --> 00:08:48,986
And the after space finds orientation, the

119
00:08:48,986 --> 00:08:52,598
user specifies for each orie, each
direction.

120
00:08:52,598 --> 00:08:58,740
User specifies a stretch and shrink
pattern, time sequence pattern.

121
00:08:58,740 --> 00:09:01,995
So now we will, I will discuss algorithms
seen

122
00:09:01,995 --> 00:09:06,178
as global motion from a speci,
user-specified local motions.

123
00:09:06,178 --> 00:09:09,131
And in the preprocess is the algorism
consists of

124
00:09:09,131 --> 00:09:12,740
the preprocessing part and the animation
seen as process.

125
00:09:13,880 --> 00:09:19,750
In the preprocessing, the user inputs,
input is a tetrahedral volumetric mesh.

126
00:09:19,750 --> 00:09:23,511
And having the tetrahedral mesh for
individual vertix,

127
00:09:23,511 --> 00:09:27,250
individual vertix and we compute a local
region, N.

128
00:09:27,250 --> 00:09:31,290
Like this one for individual vertix by
connecting a one beam.

129
00:09:31,290 --> 00:09:37,150
One beam is a connection of vertices next
and neighboring to each individual vertex.

130
00:09:38,680 --> 00:09:45,120
And after having this local regions in the
animation process, we define local region

131
00:09:45,120 --> 00:09:51,500
N depend, depending on the orientation
field and also the timing chart,

132
00:09:51,500 --> 00:09:56,480
you know the orientation field defines the
orientation of the stretch squash and

133
00:09:56,480 --> 00:09:59,880
then times sequence chart defines, times
sequence

134
00:09:59,880 --> 00:10:02,940
pattern defines whether to stretch or
shrink.

135
00:10:02,940 --> 00:10:04,780
So in this way, you first deform the

136
00:10:04,780 --> 00:10:08,250
individual regions, one by one, stretch or
shrink.

137
00:10:08,250 --> 00:10:13,490
And after that, the system assembled them
together to get a robot shape.

138
00:10:13,490 --> 00:10:16,460
So that's the basic form.

139
00:10:16,460 --> 00:10:19,170
Let me describe in a little bit more
detail.

140
00:10:19,170 --> 00:10:22,700
So this is original rest shape.

141
00:10:22,700 --> 00:10:27,540
And then this is the current form of the
shape in physical assimilation.

142
00:10:27,540 --> 00:10:30,480
And then the task is to define the motion
of

143
00:10:30,480 --> 00:10:35,960
the next time frame, starting from this
current time frame shape.

144
00:10:35,960 --> 00:10:37,790
So let me describe how to do it.

145
00:10:37,790 --> 00:10:44,890
So the original shape, you first compute
the local regions in the free computation.

146
00:10:44,890 --> 00:10:47,337
And for each local region, we compute

147
00:10:47,337 --> 00:10:50,990
the next time step local regional target
shape.

148
00:10:50,990 --> 00:10:54,540
Some part should be shrinked, some parts
will be squa, stretched, and so.

149
00:10:54,540 --> 00:10:57,090
So this is deformed local shape.

150
00:10:57,090 --> 00:11:00,790
And after that, what the system do is
shape matching.

151
00:11:00,790 --> 00:11:02,030
This is the most important part.

152
00:11:02,030 --> 00:11:03,190
Shape matching.

153
00:11:03,190 --> 00:11:10,010
For each local region, we try to find the
most, best matching position.

154
00:11:10,010 --> 00:11:12,630
You know, if you get these three, it tries

155
00:11:12,630 --> 00:11:15,940
to match these three by rotating like this
way.

156
00:11:15,940 --> 00:11:18,150
So, shape matching applied to find the

157
00:11:18,150 --> 00:11:22,720
best matching position now changed,
rotation and translation.

158
00:11:22,720 --> 00:11:27,870
And after matching, you know the current
position and desired position.

159
00:11:27,870 --> 00:11:34,140
So a system applies force from the current
position to the much desired position.

160
00:11:34,140 --> 00:11:37,040
Defined by deformed local shape.

161
00:11:37,040 --> 00:11:38,600
And then applied force.

162
00:11:38,600 --> 00:11:42,040
After that this is just the standard
physical assimilation.

163
00:11:42,040 --> 00:11:46,080
Applied force will [UNKNOWN] applied force
moves towards the position.

164
00:11:48,420 --> 00:11:49,470
So here's a summary.

165
00:11:49,470 --> 00:11:52,862
So I just introduced animation of
deformable

166
00:11:52,862 --> 00:11:56,530
characters like jellyfish, a worm, and so
on.

167
00:11:56,530 --> 00:11:59,218
And [UNKNOWN] is a local to global
approach,

168
00:11:59,218 --> 00:12:03,104
so user specifies orientation field and
then the deformation

169
00:12:03,104 --> 00:12:07,138
pattern, and then each local region
changes accordingly, and

170
00:12:07,138 --> 00:12:10,669
then global motion appears as a result of
application.

171
00:12:10,669 --> 00:12:13,849
And inside we use a shape matching
dynamics,

172
00:12:13,849 --> 00:12:17,710
because it's very fast and stable, fast
and stable.

173
00:12:19,650 --> 00:12:22,361
So to learn more, the original paper was
published

174
00:12:22,361 --> 00:12:25,519
as processional deformation ProDef,
Local-to-global

175
00:12:25,519 --> 00:12:29,480
Deformation for Skeleton-free Character
Animation.

176
00:12:29,480 --> 00:12:33,560
And design of orientation is actually
discussing a separate paper

177
00:12:33,560 --> 00:12:38,290
called Lapped Solid Textures: Filling a
Model with Anisotropic Textures.

178
00:12:38,290 --> 00:12:43,820
So, they used an orientation field to put,
paste textures inside of an object.

179
00:12:43,820 --> 00:12:48,330
And that, dynamic simulation we use is
called shape matching.

180
00:12:48,330 --> 00:12:51,674
And this is very popular technique in
graphic community, because

181
00:12:51,674 --> 00:12:56,150
it's, it's not necessarily physically
accurate, but it's very, very stable.

182
00:12:56,150 --> 00:13:03,090
Depending [UNKNOWN] put this very eh,
contradictory, and so on.

183
00:13:03,090 --> 00:13:08,283
And I recommend to take a look at these
papers, because they can be very useful.

184
00:13:08,283 --> 00:13:08,333
Thank you.