1
00:00:00,025 --> 00:00:02,854
[SOUND].

2
00:00:02,854 --> 00:00:09,906
[BLANK_AUDIO]

3
00:00:09,906 --> 00:00:13,952
hello, this is week two of interactive
computer graphics.

4
00:00:13,952 --> 00:00:17,959
And the topic of this week is, 2D Drawings
and Animations.

5
00:00:19,640 --> 00:00:23,720
And here's a list of topics, we discuss in
this week.

6
00:00:23,720 --> 00:00:27,680
The Diagram Beautification, Pen-and-ink
textures,

7
00:00:27,680 --> 00:00:31,810
Shape Manipulation, and then Dynamic
Illustrations.

8
00:00:31,810 --> 00:00:34,370
The first one, is Diagram Beautification.

9
00:00:35,790 --> 00:00:38,690
The work we introduce here, is called
Pegasus.

10
00:00:39,860 --> 00:00:44,160
And the problem we discuss here, is a
drawing of this kind of geometric

11
00:00:44,160 --> 00:00:47,960
drawings, and it's very tedious to draw

12
00:00:47,960 --> 00:00:52,160
this kind of diagram, using traditional
drawing systems.

13
00:00:52,160 --> 00:00:54,480
For example, if you want to draw, this

14
00:00:54,480 --> 00:00:57,900
kind of symmetric diagram, you have to
draw

15
00:00:57,900 --> 00:01:01,270
first half draw, draw half of it and

16
00:01:01,270 --> 00:01:04,840
duplicate it, and then flip it and move
it.

17
00:01:04,840 --> 00:01:10,010
So, you have to combine three, two or
three commands to do a symmetric drawing.

18
00:01:10,010 --> 00:01:12,850
If you do something like, like this, like

19
00:01:12,850 --> 00:01:18,460
symmetric, perpendicular, and the same gap
and connect it.

20
00:01:18,460 --> 00:01:22,700
And then, it becomes too difficult to do
it, with combining appropriate commands.

21
00:01:23,700 --> 00:01:27,440
So, what we propose is to automatically,
have the

22
00:01:27,440 --> 00:01:30,630
system automatically take care of these
kind of constraints.

23
00:01:33,230 --> 00:01:34,760
Here is our demonstration.

24
00:01:34,760 --> 00:01:37,048
So, this is again designed for pen
computing.

25
00:01:37,048 --> 00:01:39,020
So, you directly draw a line on

26
00:01:39,020 --> 00:01:42,270
the whiteboard, and the system
automatically provides feedback.

27
00:01:42,270 --> 00:01:47,610
So here, you draw a line, and then the
system automatically beautifies it.

28
00:01:47,610 --> 00:01:50,610
And if you draw a line, system
automatically beautifies it.

29
00:01:50,610 --> 00:01:54,430
So, this point is automatically aligned to
this point.

30
00:01:54,430 --> 00:01:56,180
And then you draw a line here.

31
00:01:56,180 --> 00:01:59,250
And the system automatically beautifies
it.

32
00:01:59,250 --> 00:02:04,490
And if you do a line here, this is almost
perpendicular to the slope.

33
00:02:04,490 --> 00:02:07,790
The system makes it perfectly
perpendicular.

34
00:02:07,790 --> 00:02:10,900
So, in this way, you just draw freeform
lines.

35
00:02:10,900 --> 00:02:14,578
And then you will get this kind of
diagram.

36
00:02:14,578 --> 00:02:18,030
Traditional, in, in traditional systems,
you have to draw rectangle

37
00:02:18,030 --> 00:02:22,110
separately and then move it, rotate,
connect, and so on.

38
00:02:22,110 --> 00:02:23,300
So, it can be very tedious.

39
00:02:23,300 --> 00:02:28,227
But here, you just draw six lines and the
system automatically beautifies it.

40
00:02:29,600 --> 00:02:31,560
And you can do many more things.

41
00:02:31,560 --> 00:02:36,085
For example, if you draw, almost symmetric
line.

42
00:02:36,085 --> 00:02:39,000
System makes it, perfect mirror image.

43
00:02:39,000 --> 00:02:42,420
And you just draw three more strokes and
then you'll get this diagram.

44
00:02:42,420 --> 00:02:47,670
And if you draw right here, this is
identical, very similar to the

45
00:02:47,670 --> 00:02:52,750
previous one, and the assistant makes it
an exact copy, of the previous stroke.

46
00:02:52,750 --> 00:02:55,530
So again, you draw three lines.

47
00:02:55,530 --> 00:03:02,530
And you'll get, you will get a copy
without

48
00:03:02,530 --> 00:03:06,720
using Copy or Duplicate command and we
also provide equal distance between

49
00:03:06,720 --> 00:03:10,190
lines, so in this way, you can get this
wizard specifying

50
00:03:10,190 --> 00:03:14,362
grid, before hand and also, you can do
something like this.

51
00:03:14,362 --> 00:03:19,460
System automatically makes the distance,
between two lines are identical.

52
00:03:19,460 --> 00:03:23,540
So traditionally, you have to draw two
lines duplicate it,

53
00:03:23,540 --> 00:03:26,450
rotate it and trim it, so it can be very
tedious.

54
00:03:28,070 --> 00:03:30,943
And one important aspect of this kind of

55
00:03:30,943 --> 00:03:35,610
automatic system is that, user input can
be ambiguous.

56
00:03:35,610 --> 00:03:38,660
So, if you draw a line here, this is
ambiguous, right?

57
00:03:38,660 --> 00:03:42,710
So, user may want to draw a mirror image
here or you

58
00:03:42,710 --> 00:03:46,850
may want to connect these points or user
may want to do this.

59
00:03:46,850 --> 00:03:52,325
So, system automatically infers multiple
candidates and then presents a user and

60
00:03:52,325 --> 00:03:57,736
you can choose one of them later, and this
is very important to handle ambiguity.

61
00:03:57,736 --> 00:04:00,130
And that's beautification.

62
00:04:00,130 --> 00:04:04,070
And we also implemented a prediction in,
in this system.

63
00:04:04,070 --> 00:04:05,970
So, suppose, you have this kind of

64
00:04:05,970 --> 00:04:10,240
illustration already and you draw a line
here.

65
00:04:10,240 --> 00:04:16,380
So, here, system knows that this red
segment is identical to this one.

66
00:04:16,380 --> 00:04:21,560
So, system automatically predicts or
infers that, now that, you draw the

67
00:04:21,560 --> 00:04:26,130
same thing, you probably, want to draw the
same thing around it.

68
00:04:26,130 --> 00:04:28,030
So, here's a prediction.

69
00:04:28,030 --> 00:04:32,060
And if you like one of them, just click
it, and the next prediction appears.

70
00:04:32,060 --> 00:04:37,120
So, as long as the prediction is correct,
you complete drawing

71
00:04:37,120 --> 00:04:41,490
just by successive clicking, and if you
prediction is not use,

72
00:04:41,490 --> 00:04:44,390
useful, you can just ignore them and you
draw it by

73
00:04:44,390 --> 00:04:48,700
yourself, and you again, activate
prediction and then click and draw.

74
00:04:49,840 --> 00:04:50,630
Yeah.

75
00:04:50,630 --> 00:04:52,600
And this prediction is very useful

76
00:04:52,600 --> 00:04:56,860
for multiple purposes, like drawing
repetitive illustration.

77
00:04:58,520 --> 00:05:00,752
Then you can again click here and

78
00:05:00,752 --> 00:05:04,511
then type, touch, [UNKNOWN] segment, and
[UNKNOWN].

79
00:05:04,511 --> 00:05:07,360
So, this very useful for repetitive
drawing.

80
00:05:09,420 --> 00:05:13,860
And this is also useful for symmetric
drawing like this one.

81
00:05:13,860 --> 00:05:16,269
So, you can tap, and then prediction
appears.

82
00:05:20,190 --> 00:05:22,170
And then tap, tap, tap.

83
00:05:22,170 --> 00:05:23,900
And then you will get this kind

84
00:05:23,900 --> 00:05:26,140
of symmetry doing, just by drawing and
prediction.

85
00:05:26,140 --> 00:05:26,640
So,

86
00:05:30,610 --> 00:05:31,690
that's the demonstration.

87
00:05:31,690 --> 00:05:35,150
Let me briefly describe the algorithm
behind it.

88
00:05:35,150 --> 00:05:37,920
The beautification algorithm and
prediction onwards.

89
00:05:37,920 --> 00:05:40,690
So beautification, works this way.

90
00:05:42,260 --> 00:05:45,310
So far, user input is this red one.

91
00:05:45,310 --> 00:05:47,839
And then, looking at this input, system

92
00:05:47,839 --> 00:05:51,900
first the first, learns constraint
inference engine.

93
00:05:51,900 --> 00:05:55,300
And then, getting segment coordinates
positions.

94
00:05:55,300 --> 00:05:58,110
And then, infer multiple constraints.

95
00:05:58,110 --> 00:06:03,510
So, in this case, the system infers that
this should be connected,

96
00:06:03,510 --> 00:06:08,940
this should be perpendicular, this should
be, horizontally aligned and so on.

97
00:06:08,940 --> 00:06:15,350
Given this possible geometric constraints,
then constraint solver,

98
00:06:15,350 --> 00:06:18,409
tries to combine them and then solve it
here.

99
00:06:18,409 --> 00:06:22,150
An interesting point here, is that

100
00:06:22,150 --> 00:06:26,120
these constraints can be, contradictory
features.

101
00:06:26,120 --> 00:06:31,380
So, constraint solver needs to find valid
combinations and after having multiple

102
00:06:31,380 --> 00:06:36,350
candidate system, evaluate them, in which
is most closer

103
00:06:36,350 --> 00:06:41,430
to the user input and then pick some more,
plausible one

104
00:06:41,430 --> 00:06:43,900
as a first candidate and then return it to
the user.

105
00:06:45,430 --> 00:06:49,340
And let me, more describe constraint
solvability more.

106
00:06:51,050 --> 00:06:55,681
So, Constraint Solver, as I said, takes
multiple infer for the constraints, and

107
00:06:55,681 --> 00:06:57,965
then identified by the combination, and

108
00:06:57,965 --> 00:07:01,460
then returns the result, for each
combination.

109
00:07:01,460 --> 00:07:07,000
And, the details, let me describe the
details using one example.

110
00:07:07,000 --> 00:07:11,031
Suppose you have these four constraints.

111
00:07:11,031 --> 00:07:15,830
x equal 1, y equal 2, x minus y equal 0, x
plus y equal 2.

112
00:07:15,830 --> 00:07:18,880
So, suppose you have these four
constraints

113
00:07:18,880 --> 00:07:21,930
and then tries to find valid combinations.

114
00:07:21,930 --> 00:07:24,190
One combination, is one and two.

115
00:07:24,190 --> 00:07:29,330
So, if you combine these two, you would
get one and two and it's here.

116
00:07:29,330 --> 00:07:32,776
And if you combine this first and third
one, x

117
00:07:32,776 --> 00:07:37,050
equals 1, and y equals 1 and you get this.

118
00:07:37,050 --> 00:07:39,820
However, you cannot combine these three
because it's

119
00:07:39,820 --> 00:07:43,230
contradictory, so that's what we try to do
here.

120
00:07:43,230 --> 00:07:47,160
And in the system, the algorithm works as
follows.

121
00:07:47,160 --> 00:07:51,785
For each constraint you apply, you make up
[INAUDIBLE]

122
00:07:53,890 --> 00:07:57,130
We have a set of intermediate valuations
like

123
00:07:57,130 --> 00:08:00,110
this, so far as no valuation is given.

124
00:08:00,110 --> 00:08:05,110
And then for x first constraint, you apply
it or not apply it.

125
00:08:05,110 --> 00:08:07,490
So, if you do not apply it same thing.

126
00:08:07,490 --> 00:08:11,590
If you apply it, you get one and not
valuated.

127
00:08:11,590 --> 00:08:16,100
So, in this way, you just kind of
basically binary tree and you can sort of.

128
00:08:17,460 --> 00:08:20,620
Intermediate valuations grows
exponentially.

129
00:08:20,620 --> 00:08:22,909
However, in some cases.

130
00:08:24,580 --> 00:08:25,800
Variations can be the same.

131
00:08:25,800 --> 00:08:31,790
For example, this variation combining fast
one and this other one,

132
00:08:31,790 --> 00:08:38,160
is identical to combining this one and
this one.

133
00:08:38,160 --> 00:08:42,340
So, some solutions are merged together.

134
00:08:42,340 --> 00:08:45,327
So, this is a kind of thing happening
behind the consonant solver.

135
00:08:48,490 --> 00:08:51,280
And let me briefly describe the prediction
algorithm.

136
00:08:51,280 --> 00:08:53,930
Prediction works as follows, so you have
these kind

137
00:08:53,930 --> 00:08:57,920
of existing segments and you get the new
input segments.

138
00:08:57,920 --> 00:09:00,980
At first, system searches for identical

139
00:09:00,980 --> 00:09:04,270
segments, identical to the new input
segment.

140
00:09:04,270 --> 00:09:08,898
And after identifying the matched existing
segment.

141
00:09:08,898 --> 00:09:13,612
Then system collect, aggregate, nearby
segment to the different

142
00:09:13,612 --> 00:09:17,900
stroke and they copy them to the new,
segment.

143
00:09:17,900 --> 00:09:24,070
And the addition to that, we add vertical
and horizontal flip, over the predictions.

144
00:09:24,070 --> 00:09:27,108
So, that's the way, the prediction work,
works.

145
00:09:27,108 --> 00:09:33,153
So, that's a,a system and its original
paper was published as Interactive

146
00:09:33,153 --> 00:09:38,460
Beautification, a technique for rapid
geometric design in 97.

147
00:09:38,460 --> 00:09:42,100
Constraint based drawing, is a popular
topic.

148
00:09:42,100 --> 00:09:47,040
An original paper was published as
Sketchpad and this is,

149
00:09:47,040 --> 00:09:51,830
a very old paper published in 1963, but
this is still.

150
00:09:51,830 --> 00:09:53,760
Very powerful tool.

151
00:09:53,760 --> 00:09:56,160
And I recommend you to take a look at the
video.

152
00:09:56,160 --> 00:09:58,830
This was a very fast computer graphics

153
00:09:58,830 --> 00:10:01,980
and also very fast interactive computer
graphics.

154
00:10:01,980 --> 00:10:05,040
And if you want to see the recent one

155
00:10:05,040 --> 00:10:08,350
I'd recommend you to take a look the
Cinderella system.

156
00:10:08,350 --> 00:10:12,680
This is this kind of constraint-based,
geometric drawing system.

157
00:10:12,680 --> 00:10:15,890
And this is very useful for mathematical
education and so on.

158
00:10:16,980 --> 00:10:17,280
Thank you.