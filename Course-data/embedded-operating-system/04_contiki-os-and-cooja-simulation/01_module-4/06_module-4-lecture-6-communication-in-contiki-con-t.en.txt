[MUSIC] Hello. I am glad to see you back for this lesson. This time we will explore the details
of micro IP communication and stacking Contiki. By the end of the lesson,
you should understand the benefits and challenges of using Contiki's
micro IP communication stack. The micro IP stack is a communication
library provided in Contiki for supporting TCP/IP protocols
on small micro-controllers. Some of the benefits of using micro
IP stack are its small code size and that it requires only a few
hundred of bytes of RAM. Although it is lightweight, it is
important to notice that the necessary RFC requirements affecting host to
host communication are fulfilled. However, some complicated communication
mechanisms have been removed from micro IP in order to make it suitable for
embedded systems. For example,
the soft error reporting mechanism and the dynamically configurable type of
service bids for TCP connections. Are not present since these
mechanisms are not required in most wireless sensor
network applications. It is important to notice
that removing these services does not affect the quality of service. The micro IP stack can be
executed either as a task in a multitasking system or as the main
program in a single task system. In multitasking implementations,
it is common to implement two tests. The first one is constantly checking for
incoming packets. Whereas the second one is verifying
the occurrence of a periodic timeout. Once a packet arrives,
the micro IP input function is called. Then the receiving application may
create a message for replying. Periodic timeouts play important roles
in TCP because many activities and functions require this information for
performing their task. For example, retransmission and round trip
time estimation requires periodic timers. Instead of using explicit dynamic memory,
micro IP uses a single global buffer for restoring incoming packets and a fixed
table for holding connection state. The size of the global buffer is designed
to fit the maximum size of a packet. When a message reaches to a destination, the message is stored in the global
buffer and wait for a TCP/IP stack. In cases where the packet contains data,
the TCP/IP stack will notify the appropriate
application to process the data. The application which the incoming
packet is targeted to can immediately process the data or copy it to
another buffer for future processing. The global buffer is used for
both incoming and outgoing packets, as well as for headers. Therefore, this tech can use the part
of the buffer that is not reserved for headers as a temporary memory for dealing
with applications sending dynamic data. The memory footprint for implementing micro IP varies dramatically
depending on the application. For example, there are less requirements
in terms of memory usage for a simple Telnet server. Than for other complex applications
which perform very complicated tasks. It is possible to implement micro
IP with a very low memory overhead. As for example, with the memory
size of less than 300 bytes. However, this implementation will affect
other features or reduce service quality. To interact with the micro IP stack,
an application program interface or API is used. The API comprises a set of software and functions to make application
development easier. Currently, the BSD socket API seems to
be one of the most popular APIs for TCP/IP, since it is used in many Unix and
Linux systems. However, the BSD API is not suitable for micro IPs tech due to its requirements
of support from an underlying multi-tasking operating system and
the overhead of memory usage. Instead of using a BSD API,
Contiki provides two simple APIs that include proto-sockets and a simpler
version of BSD with low overhead. Similar to Rhyme Stack, the micro IP
stack is designed in ledgered fashion, where each functionality will be
performed by a particular protocol. While interactions between the protocol
layers are strictly defined. Using the layerds structure for designing
protocols and stacks is a good approach. However, it is not ideal for
implementing them. In micro IP, the protocol implementations are tightly
coupled in order to save code space. This is the end of the lesson about
Contiki's micro IP communication stack. I hope by now you have a good idea about
the structure of Contiki's micro IP stack and how it works. Thanks for watching. [MUSIC]