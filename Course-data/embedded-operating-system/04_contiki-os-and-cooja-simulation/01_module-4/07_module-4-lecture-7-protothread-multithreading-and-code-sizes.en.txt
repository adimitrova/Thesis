[MUSIC] Welcome. In our previous videos, we examine
the many structure of Contiki core and other features. Now, we are going to discuss one of
the most important features of Contiki that is Contiki protothreads. In order to provide sequential flow of
control, Contiki provides protothreads instead of using complex state machines or
full multi-threading. Protothreads are lightweight and stand as stackless threads with only
two bytes of memory per thread. One of the benefits of using
Contiki's protothreads is that systems overhead can be small
compared to other kernels. This comes as a result of sharing
the stack by old protothreads. This has the additional benefit that
context switching can be done easily by stack rewinding. It is more efficient to implement Contiki
protothreads than applying traditional ways of multithreading on wireless
sensor network applications. Contiki's protothreads
are extremely lightweight. Similar to other modules and processes in Contiki, protothreads
are completely written in standard C. This avoids any extra requirement for
using and compiling protothreads. Now you have some idea of
the structure of protothreads, you may wonder how they really work. A protothread basically works
within a single function and cannot span over other functions. It is possible for
a protothread to call another function, however it cannot plug the flow
inside the called function. Some of the popular applications using
protothreads are memory constraint systems, event driven protocol stacks, deeply embedded systems and
sensor network nodes. In order to give you a complete
view of Contiki protothreads, we are going to discuss
how they are implemented. Protothreads are implemented using
local continuations, which are used to present the current execution state
of a program at the specific places. A local continuation can be implemented
using one of the following three ways. These are machine specific assembler code, standard C constructs,
or compiler extensions. The first way can be done by saving and restoring the processor state,
except for the stack pointers. As a result, each proto-thread uses
around 16 to 32 bytes of memory. The second way of using a standard C for implementation requires only 2 bytes
of state information per protothread. Although this approach has slower memory
overhead it still has some challenges and restrictions. The last method is to
use certain C compilers which have a specific C extensions for
implementing protothreads. For example, a GCC version supporting label pointers
can be a good candidate to perform this. As a result, only four bytes of
RAM per protothread are required. Now, I will show you an example of sealed
code of protothreads in this slide. Please take your time and
look at the construct in detail. We are now going to explore another
important concept supported in Contiki, that is preemptive multi-threading. Instead of implementing multi-threading
in the core, Kontiki implements multi-threading as a library on
the top of the event based kernel. This gives the advantage that
the library is only linked with applications built with the need for
multi-threading support. Multi-threading is implemented
by using timer interrupts. The implementation is
divided in two parts. A platform specific part and
a platform independent part. Unlike a conventional Contiki
processes discussed previously, each thread in multi-threading
requires a separate stack. They run in separate threads until they
yield explicitly or get preempted. The multi-threading library provides
a set of API's for easy interaction. Some example methods of multi-threading
API are shown in this slide. Have you ever heard of
Over-the-air programming? Over-the-air programming is
a simple Contiki protocol to program the entire network of sensors. Basically, the protocol sends a single
program binary to a destination node or concentrate node via
point-to-point communication. Their received binary is stored in first. When the whole program
is completely received, the protocol continues to propagate the
binary program to other neighboring nodes. In cases of packet loss, negative acknowledgment is
sent to the concentrate node. Then the node starts to
repair data packets. It is convenient to use the protocol
to upgrade the whole network of sensors quickly. Let's start to analyze
the code size of Contiki. To see how large it is and to do code
size comparisons between Contiki and other embedded OSs,
there are some strict requirements for an operating system of embedded
wireless sensor network devices. These requirements arise due
to resource constraints. Memory, which is one of the most
precious resources of embedded devices, must be considered when
choosing a suitable OS. Let's examine the minimum RAM and ROM required to run a simple
wireless sensor network application. Note that RAM and ROM usage vary
depending on the actual application. For instance, a simple wireless
sensor network application takes less than 2 kilobytes and
30 kilobytes respectively. Please take your time to see this slide
which shows detailed compile code size and RAM usage of a Contiki always compile for
two architectures. The Texas Instruments MSP430 and
the Atmel AVR. So this brings us to the end of the video. I hope that you got a good understanding
of Contiki protothreads and multi-threading. Thank you for participating and
I hope to see you in upcoming videos. [SOUND]