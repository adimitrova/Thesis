1
00:00:00,039 --> 00:00:05,809
[MUSIC]

2
00:00:05,809 --> 00:00:07,213
Hello.

3
00:00:07,213 --> 00:00:09,741
I am glad to see you back for this lesson.

4
00:00:09,741 --> 00:00:14,392
This time we will explore the details
of micro IP communication and

5
00:00:14,392 --> 00:00:15,811
stacking Contiki.

6
00:00:15,811 --> 00:00:19,249
By the end of the lesson,
you should understand the benefits and

7
00:00:19,249 --> 00:00:22,699
challenges of using Contiki's
micro IP communication stack.

8
00:00:23,700 --> 00:00:28,901
The micro IP stack is a communication
library provided in Contiki for

9
00:00:28,901 --> 00:00:33,690
supporting TCP/IP protocols
on small micro-controllers.

10
00:00:33,690 --> 00:00:39,080
Some of the benefits of using micro
IP stack are its small code size and

11
00:00:39,080 --> 00:00:41,990
that it requires only a few
hundred of bytes of RAM.

12
00:00:43,370 --> 00:00:48,250
Although it is lightweight, it is
important to notice that the necessary RFC

13
00:00:48,250 --> 00:00:53,050
requirements affecting host to
host communication are fulfilled.

14
00:00:54,300 --> 00:00:59,300
However, some complicated communication
mechanisms have been removed from micro

15
00:00:59,300 --> 00:01:03,019
IP in order to make it suitable for
embedded systems.

16
00:01:04,020 --> 00:01:07,750
For example,
the soft error reporting mechanism and

17
00:01:07,750 --> 00:01:12,860
the dynamically configurable type of
service bids for TCP connections.

18
00:01:12,860 --> 00:01:16,710
Are not present since these
mechanisms are not required

19
00:01:16,710 --> 00:01:19,420
in most wireless sensor
network applications.

20
00:01:20,750 --> 00:01:24,290
It is important to notice
that removing these services

21
00:01:24,290 --> 00:01:26,239
does not affect the quality of service.

22
00:01:27,600 --> 00:01:31,580
The micro IP stack can be
executed either as a task

23
00:01:31,580 --> 00:01:36,370
in a multitasking system or as the main
program in a single task system.

24
00:01:37,950 --> 00:01:43,080
In multitasking implementations,
it is common to implement two tests.

25
00:01:44,110 --> 00:01:47,880
The first one is constantly checking for
incoming packets.

26
00:01:47,880 --> 00:01:52,300
Whereas the second one is verifying
the occurrence of a periodic timeout.

27
00:01:53,860 --> 00:01:58,280
Once a packet arrives,
the micro IP input function is called.

28
00:01:59,550 --> 00:02:03,450
Then the receiving application may
create a message for replying.

29
00:02:05,060 --> 00:02:10,310
Periodic timeouts play important roles
in TCP because many activities and

30
00:02:10,310 --> 00:02:15,230
functions require this information for
performing their task.

31
00:02:15,230 --> 00:02:21,389
For example, retransmission and round trip
time estimation requires periodic timers.

32
00:02:22,420 --> 00:02:28,550
Instead of using explicit dynamic memory,
micro IP uses a single global buffer for

33
00:02:28,550 --> 00:02:33,440
restoring incoming packets and a fixed
table for holding connection state.

34
00:02:34,650 --> 00:02:39,900
The size of the global buffer is designed
to fit the maximum size of a packet.

35
00:02:41,330 --> 00:02:44,170
When a message reaches to a destination,

36
00:02:44,170 --> 00:02:49,530
the message is stored in the global
buffer and wait for a TCP/IP stack.

37
00:02:51,210 --> 00:02:55,420
In cases where the packet contains data,
the TCP/IP stack

38
00:02:55,420 --> 00:02:58,840
will notify the appropriate
application to process the data.

39
00:03:00,160 --> 00:03:04,860
The application which the incoming
packet is targeted to can immediately

40
00:03:04,860 --> 00:03:09,660
process the data or copy it to
another buffer for future processing.

41
00:03:11,240 --> 00:03:14,590
The global buffer is used for
both incoming and

42
00:03:14,590 --> 00:03:17,189
outgoing packets, as well as for headers.

43
00:03:18,350 --> 00:03:22,540
Therefore, this tech can use the part
of the buffer that is not reserved for

44
00:03:22,540 --> 00:03:27,930
headers as a temporary memory for dealing
with applications sending dynamic data.

45
00:03:29,640 --> 00:03:31,130
The memory footprint for

46
00:03:31,130 --> 00:03:36,760
implementing micro IP varies dramatically
depending on the application.

47
00:03:36,760 --> 00:03:41,730
For example, there are less requirements
in terms of memory usage for

48
00:03:41,730 --> 00:03:43,610
a simple Telnet server.

49
00:03:43,610 --> 00:03:48,090
Than for other complex applications
which perform very complicated tasks.

50
00:03:49,430 --> 00:03:54,760
It is possible to implement micro
IP with a very low memory overhead.

51
00:03:54,760 --> 00:03:58,880
As for example, with the memory
size of less than 300 bytes.

52
00:04:00,080 --> 00:04:05,190
However, this implementation will affect
other features or reduce service quality.

53
00:04:06,390 --> 00:04:11,670
To interact with the micro IP stack,
an application program interface or

54
00:04:11,670 --> 00:04:13,089
API is used.

55
00:04:14,600 --> 00:04:17,567
The API comprises a set of software and

56
00:04:17,567 --> 00:04:21,752
functions to make application
development easier.

57
00:04:21,752 --> 00:04:28,383
Currently, the BSD socket API seems to
be one of the most popular APIs for

58
00:04:28,383 --> 00:04:33,725
TCP/IP, since it is used in many Unix and
Linux systems.

59
00:04:33,725 --> 00:04:36,738
However, the BSD API is not suitable for

60
00:04:36,738 --> 00:04:41,788
micro IPs tech due to its requirements
of support from an underlying

61
00:04:41,788 --> 00:04:46,937
multi-tasking operating system and
the overhead of memory usage.

62
00:04:47,980 --> 00:04:53,680
Instead of using a BSD API,
Contiki provides two simple APIs

63
00:04:53,680 --> 00:04:58,940
that include proto-sockets and a simpler
version of BSD with low overhead.

64
00:05:00,360 --> 00:05:06,080
Similar to Rhyme Stack, the micro IP
stack is designed in ledgered fashion,

65
00:05:06,080 --> 00:05:10,710
where each functionality will be
performed by a particular protocol.

66
00:05:10,710 --> 00:05:14,270
While interactions between the protocol
layers are strictly defined.

67
00:05:15,838 --> 00:05:21,260
Using the layerds structure for designing
protocols and stacks is a good approach.

68
00:05:21,260 --> 00:05:24,240
However, it is not ideal for
implementing them.

69
00:05:25,360 --> 00:05:26,720
In micro IP,

70
00:05:26,720 --> 00:05:31,629
the protocol implementations are tightly
coupled in order to save code space.

71
00:05:32,770 --> 00:05:38,270
This is the end of the lesson about
Contiki's micro IP communication stack.

72
00:05:38,270 --> 00:05:43,670
I hope by now you have a good idea about
the structure of Contiki's micro IP stack

73
00:05:43,670 --> 00:05:45,200
and how it works.

74
00:05:45,200 --> 00:05:46,715
Thanks for watching.

75
00:05:46,715 --> 00:05:50,689
[MUSIC]