1
00:00:00,025 --> 00:00:05,921
[SOUND].

2
00:00:05,921 --> 00:00:09,680
Welcome, I am glad to see you back for
this lesson.

3
00:00:09,680 --> 00:00:13,770
In this video we will discuss
the details of how Contiki implements

4
00:00:13,770 --> 00:00:15,490
network communication.

5
00:00:15,490 --> 00:00:18,690
By the end of the lesson you should
understand the structure and

6
00:00:18,690 --> 00:00:21,280
functioning of Contiki's
communications stack.

7
00:00:22,650 --> 00:00:26,870
But perhaps the best question
to start this lecture with is,

8
00:00:26,870 --> 00:00:28,800
what is communication in Contiki.

9
00:00:29,950 --> 00:00:31,860
Before answering this question,

10
00:00:31,860 --> 00:00:35,480
we are going to talk about communication
in wireless sensor networks.

11
00:00:36,700 --> 00:00:41,520
Communication plays an essential role
in any wireless sensor network system.

12
00:00:42,530 --> 00:00:46,760
Basically, communication in a wireless
sensor network architecture

13
00:00:46,760 --> 00:00:48,046
includes three parts.

14
00:00:48,046 --> 00:00:53,883
Sensor nodes, a gateway,
and the backend system.

15
00:00:53,883 --> 00:00:58,593
Sensors collect data and
send it to the gateway wirelessly.

16
00:00:58,593 --> 00:01:01,368
Depending on the network characteristics,

17
00:01:01,368 --> 00:01:04,294
a particular communication
protocol is used.

18
00:01:04,294 --> 00:01:08,630
For example, Wi-Fi or
Bluetooth can be used for

19
00:01:08,630 --> 00:01:12,662
sending data from sensor
nodes to a getaway.

20
00:01:12,662 --> 00:01:18,250
Then the data is forward via
the internet and reach the cloud.

21
00:01:18,250 --> 00:01:23,370
Finally end-users can access data or
use services offered by the cloud.

22
00:01:24,810 --> 00:01:25,940
In this lecture,

23
00:01:25,940 --> 00:01:29,780
we will focus on communication
between sensor nodes and the gateway.

24
00:01:30,790 --> 00:01:34,880
In other words, the communication
between devices using Contiki.

25
00:01:36,330 --> 00:01:40,830
In Contiki,
communication is implemented as a service.

26
00:01:40,830 --> 00:01:44,460
Therefore it has all the features
of Contiki services,

27
00:01:44,460 --> 00:01:46,170
such as run time replacement.

28
00:01:47,480 --> 00:01:53,390
As a result, it allows to simultaneously
load multiple communication stacks.

29
00:01:53,390 --> 00:01:57,240
This helps to reduce the latency
of loading modules one by one.

30
00:01:58,820 --> 00:02:01,290
In addition, this feature can be used for

31
00:02:01,290 --> 00:02:03,639
comparing different
communication protocols.

32
00:02:04,940 --> 00:02:07,910
To have a better understanding
of such protocols,

33
00:02:07,910 --> 00:02:10,730
we will explore them in
depth later in this video.

34
00:02:12,150 --> 00:02:16,010
But now, we are going to focus on
the loosely coupled communication

35
00:02:16,010 --> 00:02:17,050
stack in Contiki.

36
00:02:18,530 --> 00:02:22,049
Communication in Contiki may be
divided into different services.

37
00:02:23,370 --> 00:02:26,650
The communication stack
uses synchronous events

38
00:02:26,650 --> 00:02:28,650
to communicate with a program application.

39
00:02:29,920 --> 00:02:32,510
Here, an interesting question is,

40
00:02:32,510 --> 00:02:37,260
why using synchronous events instead
of asynchronous events, or polling?

41
00:02:38,550 --> 00:02:42,850
The answer is that it is possible
to use a single buffer for

42
00:02:42,850 --> 00:02:44,980
all communication processing,

43
00:02:44,980 --> 00:02:49,500
since it is necessary that synchronous
event handlers run to completion.

44
00:02:50,960 --> 00:02:56,432
This approach ensures that there is no
need to copy data to intermediate buffers.

45
00:02:57,530 --> 00:03:03,512
The bias drivers operate between
the communication stack and the hardware.

46
00:03:03,512 --> 00:03:06,805
Device drivers would in come in packets,
place them into

47
00:03:06,805 --> 00:03:11,690
the communication buffer and then call
the upper layer's communication service.

48
00:03:12,910 --> 00:03:17,410
When the communication service is awaken,
it inspects the packet in the buffer.

49
00:03:18,740 --> 00:03:23,570
Based on the content of the packet header,
the service searches for

50
00:03:23,570 --> 00:03:26,500
the application which is
the destination of the packet.

51
00:03:27,700 --> 00:03:30,494
When it finds the exact application,

52
00:03:30,494 --> 00:03:34,871
it posts a synchronous event
to that application program.

53
00:03:34,871 --> 00:03:39,019
After receiving the event generated
by the communication stack,

54
00:03:39,019 --> 00:03:42,660
the application program
proceeds to process the packet.

55
00:03:43,680 --> 00:03:48,760
In some cases, it is necessary for
the application program to replay

56
00:03:48,760 --> 00:03:54,320
by posting some data to the communication
stack before returning the control to it.

57
00:03:55,580 --> 00:04:00,590
Then, when the communication stack
takes control, it places the reply

58
00:04:00,590 --> 00:04:05,340
in the communication buffer and
appends its header to the outgoing packet.

59
00:04:06,700 --> 00:04:10,380
Finally, it gives control
to the device driver, so

60
00:04:10,380 --> 00:04:11,930
that the packet can be transmitted.

61
00:04:13,730 --> 00:04:18,316
After understanding the big picture
of Contiki's communication stack,

62
00:04:18,316 --> 00:04:21,310
let's examine its
structure with more detail.

63
00:04:22,670 --> 00:04:29,211
There are two types of communication
stacks in Contiki, Micro IP and Rime.

64
00:04:29,211 --> 00:04:36,353
In this lesson, we will only discuss Rime
and leave micro IP for the next video.

65
00:04:36,353 --> 00:04:38,580
What is the Rime communication stack?

66
00:04:39,710 --> 00:04:43,910
Rime is a lightweight communication
stack with a layered design

67
00:04:43,910 --> 00:04:48,779
where the more complex communication
protocols can reuse the simpler ones.

68
00:04:49,970 --> 00:04:54,330
When using Rime there is no rule
that compels an application

69
00:04:54,330 --> 00:04:57,930
to go through all the layers of
the stack in order to communicate.

70
00:04:58,960 --> 00:05:03,110
Instead it can use any primitive or
protocol that it requires.

71
00:05:04,420 --> 00:05:08,570
Both single hop and
multi-hop communication primitives

72
00:05:08,570 --> 00:05:11,859
are fully supported in
Contiki's Rime communication stack.

73
00:05:13,070 --> 00:05:17,650
However there is no packet routing in
the multihub communication primitives.

74
00:05:18,670 --> 00:05:23,340
This task is specified by the application
or the upper layer protocol.

75
00:05:25,420 --> 00:05:31,310
One of the benefits of Rime stack is that
users can implement all their protocols,

76
00:05:31,310 --> 00:05:34,060
which do not belong to
Rime on the top of it.

77
00:05:35,670 --> 00:05:40,247
So now let's take a look at some of
the primitives available in the set of

78
00:05:40,247 --> 00:05:42,858
communication abstractions in glide.

79
00:05:42,858 --> 00:05:46,478
First is single-hop broadcast.

80
00:05:46,478 --> 00:05:50,700
Where the sender's address is
added to the outgoing packet

81
00:05:50,700 --> 00:05:54,084
before sending it to all
local area neighbors.

82
00:05:54,084 --> 00:05:57,356
Then we have single-hop unicast,

83
00:05:57,356 --> 00:06:02,598
which is used to send packets
to a specific destination.

84
00:06:02,598 --> 00:06:07,548
The reliable unicast is another
type of single-hop unicast that

85
00:06:07,548 --> 00:06:13,038
repeatedly sends a packet to a particular
destination while waiting for

86
00:06:13,038 --> 00:06:16,641
an acknowledgement packet
from the receiver.

87
00:06:16,641 --> 00:06:22,206
Finally, the multi-hop unicast
primitive is used for sending packets

88
00:06:22,206 --> 00:06:27,780
to an identified node in the network
which is located several hops away.

89
00:06:29,360 --> 00:06:34,080
In this case, a rooting function must
be provided by the application or

90
00:06:34,080 --> 00:06:37,000
protocol to choose
the next hop destination.

91
00:06:38,140 --> 00:06:39,240
This is the end for

92
00:06:39,240 --> 00:06:44,190
the lesson about Contiki communication and
ground communication stack.

93
00:06:44,190 --> 00:06:47,660
By now, I hope you have a deeper
understanding on the way Contiki's

94
00:06:47,660 --> 00:06:51,150
communication is structured and
how it works.

95
00:06:51,150 --> 00:06:52,813
See you in the next video.

96
00:06:52,813 --> 00:06:53,313
[SOUND]