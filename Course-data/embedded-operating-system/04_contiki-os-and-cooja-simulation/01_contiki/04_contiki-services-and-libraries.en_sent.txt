[music] hello, i am glad to see you back for this lesson.
in previous lessons, we explored contiki's kernel architecture.
now we will look into the details of contiki's services and libraries.
by the end of the lesson, you should understand the benefits and challenges of using and developing services and libraries in contiki.
first of all, i will go directly to a question.
what is a service in contiki?
as we mentioned before, services are implemented as modules.
so when a particular service is required the corresponding module is loaded thus making contiki run efficiently.
from a certain point of view, a service is different from other application programs since a service can be used by several application programs in other words, a service is a type of shared library.
one of the benefits of contiki services is that they can be dynamically replaced at random.
as mentioned before, with this strategy contiki minimizes the number of modules to be loaded during booting time.
as a result, memory researches can be used more efficiently.
as an example, some popular and hag intensive use services in kentucky are communication stacks and sensor device drivers.
these kind of services will be discussed in depth in coming videos.
after this short introduction, i assume that you already have a basic idea of contiki services.
now, we are going to take a look under the skin of contiki services and other components related to services.
in every operating system, each service should have a unique identifier, defined by the system or users.
the format of the identifier can write depending on a particular operating system.
in contiki, a service identifier is a textual string that describes the functionality of the service identifiers are used when application programs invoke a service.
when a service is requested, the service layer uses ordinary string matching for querying the installed services.
you may now be wondering, what is a service layer?
the surface layer is a component located between the kernel and services.
when a process wants to call a service, it posts an event to the colonial, which in turn sends a command and information related to their requested service to the service leader.
this layer uses this data for querying a matching services.
instead of searching services in the kernel, the searching job will be doing by the service layer.
everything we have discussed so far does not unveiled the actual structure of a service in contiki.
therefore, now we are going to explore the structure of a service.
a service includes a service interface and a process.
a service interface provides an entry point that an application uses to access the functionality exposed by the service.
the service interface includes a version number and a list of functions with pointers to the functions that implement the interface.
services and application programs use a stub library to communicate.
how does a stub library work?
a stub library that has been linked with an application utilizes the service layer for the purpose of finding the corresponding service process.
after a service has been located, the service is stopped, gets the process identifier, which will be used for later requests.
by using a stub library an application does not need to know the exact location in memory of the service, or the implementation details of the service.
when a service is called for the first time the stub library queries the service layer for searching for the necessary service.
as a result, if there is an instance of the service in the system, the service layer will return a pointer to the service interface.
after this, the version number in the service interface will be compared to the stub interface's number.
if they are identical, the implementation of the requested service will be delivered.
next, i am going to explain about service replacement.
what is service replacement in contiki?
as we know, services in contiki can be dynamically loaded and replaced.
however, it would become unmanageable if the process identifier would be changed.
therefore, in order to avoid this issue, the service identifier must remain the same even if the process is replaced.
a reasonable question would be, why is the process replaced but the process identifier is still kept?
to answer this question, we are going to explore the mechanism that performs this task in contiki.
when a service is about to be replaced, a special event is sent from the kernel to the service process to inform the running version of the service about the changes.
accordingly, the service is automatically removed from the system.
however, there are some cases that many services have internal stage that may need to be transferred to the new process.
in order to deal with those cases, a pointer and a stage description are used for passing to the new service process.
in short, this stage description, which is stored as a shared memory, is a tag with the motion number of the service.
the reason for this is to avoid that an incorrect version of this same service is loaded.
now let's talk about libraries in contiki.
as we know, the kernel in contiki is minimal and only performs vital functions such as event handling features and cpu multipliers.
the rest of the system is build as a library.
when the program needs to use a function provided by a library it can link with a library that implements the required function.
there are three types of linking between an application and a library.
the first one is a static link between an application and libraries which are part of the core.
the second one is a static link between an application and libraries which are part of loadable program.
the last one is the application can call the service that implements a specific library.
as a result of the last method, the library implemented as services can be replaced at random.
what is the difference between these linking types?
libraries are part of the core.
this means that when the system is booted or rebooted, these libraries are always automatically loaded along with the system.
other type of libraries are loadable program libraries, these libraries are only loaded when a program application requires their functions.
these libraries are rarely used, or are very application-specific libraries.
the last term is runtime libraries, which are implemented as services.
this runtime libraries can be replaced when the system is running and these libraries are frequently used.
to give you a more comprehensive understanding of different types of libraries, i will discuss some examples.
let's discuss two functions commonly used in contiki applications memcpy and atoi.
the memcpy function is used for copying data between two memory regions, while atoi function is used for converting strings into integers.
memcpy is frequently used in contiki, therefor it is considered as a part of the core.
whereas atoi is less frequently used, and therefore it is not included in the system core.
it is implemented in loadable program libraries.
this is all for the lesson about contiki service, service replacement, and libraries.
i hope by now you have a good idea about how these contiki features work.
thanks for watching.
[music]
