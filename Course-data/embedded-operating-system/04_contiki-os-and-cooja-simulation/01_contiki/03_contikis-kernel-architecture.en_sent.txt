[music] welcome.
it is good to see you back for this lesson.
in the previous module, we explored the contiki operating system.
now, we will take a look at contiki's kernel architecture and explore the details of its characteristics.
by the end of the lesson, you should understand the benefits and challenges faced when developing applications in contiki.
let's start with contiki's kernel architecture.
as we know from previous videos, contiki is based on a modular kernel architecture.
therefore, the kernel is minimal.
due to this reason, the kernel comprises only a few lines of code that perform vital functions.
for example, the kernel consists of an event scheduler, which is light in terms of code size.
in contiki, all program execution is triggered either through the polling mechanism or by events which are sent by the kernel.
in contiki, the kernel supports two types of events, synchronous and asynchronous.
asynchronous events are not delivered to the receiving process immediately after being posted.
instead, they are stored in an event queue.
the events in the queue are delivered to the receiving process by the kernel.
the kernel delivers an event from the event queue by looping through it.
the receiver of an asynchronous event can be either a specific process or all running processes.
when the receiver is a specific process, the kernel invokes this process to deliver the event.
when the receiver of an event is set to be processes in the system, the kernel delivers the same event to all processes sequentially.
this is one after another.
the process post function is used for posting an asynchronous event.
actually this function is very simple.
first, the size of the event queue is evaluated and if there is room for the new event, then the event is added to the queue.
otherwise, the function will return zero.
synchronous events work differently from asynchronous events.
in the sense that when a synchronous event is dispatched, it is delivered to the receiving process immediately.
another difference between asynchronous and synchronous events is the type of receiver.
while asynchronous events can be received either by a specific process or all running processes, a synchronous event can only be received by a specific process.
the mechanism for invoking a synchronous receiver is similar to calling a function.
a synchronous receiver is called, so it performs it's task, after which it returns control to the posting process.
besides events, the kernel supports a polling mechanism.
in short, the polling mechanism behaves as high priority events that are scheduled between asynchronous events.
typically, processes operating close to the hardware level use polling for evaluating hardware status.
when a poll is scheduled, all processes that implement a poll handler are called sequentially according to their priority.
in a similar way to event posting functions, contiki also provides a process poll function for posting a poll.
posting a poll has a similar effect as an interrupt.
it causes the receiving process to be scheduled as soon as possible.
contiki's kernel uses a single shared stack for all process execution.
the use of asynchronous events reduce a stack's space requirements as the stack is rewound between each invocation of event handlers.
at this point, you may have questions regarding events such as is an event unique?
or how are we best identify it?
to answer these questions, let's talk about event identifiers.
an event identifier is an 8-bit number used as a unique identifier for an event.
when a process receives an event it uses the event identifier to determine the actions to perform.
there are several event identifiers reserved by the contiki kernel to handle process control, inter-process communication, and peripheral access.
to get better acquainted with the available identifiers, i suggest you go through the suggested materials.
now, let's take a look at the way contiki implements the scheduling.
contiki schedules all events using a single level hierarchy, and events cannot be preempted by other events.
the only way to preempt an event is using interrupts.
it is important to notice the interrupt must be supported by an underlying real-time executive.
correspondingly, interrupt handlers cannot post any event.
the reason behind this policy is to avoid possible race conditions in the event handler.
instead, a polling flag is used to request a poll event.
this flag provides interrupt handlers with a way to request immediate polling.
next, we are going to discuss about loadable programs in contiki.
to implement loadable programs, contiki uses a binary format that includes relocation information and a run-time relocation function.
but, how does a loadable program work?
when a program is loaded, the loader uses the relocation information provided by the binary format to allocate memory.
in case that there is not enough memory, the loading is aborted.
in case of successful loading, the function for initialization is called for starting or replacing other processes.
finally, we're going to look at power saving in contiki.
in general, power can be saved by putting inactive nodes to sleep.
in some cases, choosing appropriate level protocols may also reduce power consumption.
contiki also provides a mechanism for reducing power consumption even though there is no explicit abstraction for it.
the mechanism works by checking the size of the systems event queue.
if the event queue is empty, the micro-controller goes into a sleep mode until it's woken up by an interrupt.
this is all for the lesson about contiki kernel architecture.
i hope now you have a better insight on how contiki's kernel is structured and how it works.
thanks for watching and see you in the next video.
[music]
