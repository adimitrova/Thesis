[
sound
]
.
welcome
,
i
am
glad
to
see
you
back
for
this
lesson
.
in
this
video
we
will
discuss
the
details
of
how
contiki
implements
network
communication
.
by
the
end
of
the
lesson
you
should
understand
the
structure
and
functioning
of
contiki
's
communications
stack
.
but
perhaps
the
best
question
to
start
this
lecture
with
is
,
what
is
communication
in
contiki
.
before
answering
this
question
,
we
are
going
to
talk
about
communication
in
wireless
sensor
networks
.
communication
plays
an
essential
role
in
any
wireless
sensor
network
system
.
basically
,
communication
in
a
wireless
sensor
network
architecture
includes
three
parts
.
sensor
nodes
,
a
gateway
,
and
the
backend
system
.
sensors
collect
data
and
send
it
to
the
gateway
wirelessly
.
depending
on
the
network
characteristics
,
a
particular
communication
protocol
is
used
.
for
example
,
wi-fi
or
bluetooth
can
be
used
for
sending
data
from
sensor
nodes
to
a
getaway
.
then
the
data
is
forward
via
the
internet
and
reach
the
cloud
.
finally
end-users
can
access
data
or
use
services
offered
by
the
cloud
.
in
this
lecture
,
we
will
focus
on
communication
between
sensor
nodes
and
the
gateway
.
in
other
words
,
the
communication
between
devices
using
contiki
.
in
contiki
,
communication
is
implemented
as
a
service
.
therefore
it
has
all
the
features
of
contiki
services
,
such
as
run
time
replacement
.
as
a
result
,
it
allows
to
simultaneously
load
multiple
communication
stacks
.
this
helps
to
reduce
the
latency
of
loading
modules
one
by
one
.
in
addition
,
this
feature
can
be
used
for
comparing
different
communication
protocols
.
to
have
a
better
understanding
of
such
protocols
,
we
will
explore
them
in
depth
later
in
this
video
.
but
now
,
we
are
going
to
focus
on
the
loosely
coupled
communication
stack
in
contiki
.
communication
in
contiki
may
be
divided
into
different
services
.
the
communication
stack
uses
synchronous
events
to
communicate
with
a
program
application
.
here
,
an
interesting
question
is
,
why
using
synchronous
events
instead
of
asynchronous
events
,
or
polling
?
the
answer
is
that
it
is
possible
to
use
a
single
buffer
for
all
communication
processing
,
since
it
is
necessary
that
synchronous
event
handlers
run
to
completion
.
this
approach
ensures
that
there
is
no
need
to
copy
data
to
intermediate
buffers
.
the
bias
drivers
operate
between
the
communication
stack
and
the
hardware
.
device
drivers
would
in
come
in
packets
,
place
them
into
the
communication
buffer
and
then
call
the
upper
layer
's
communication
service
.
when
the
communication
service
is
awaken
,
it
inspects
the
packet
in
the
buffer
.
based
on
the
content
of
the
packet
header
,
the
service
searches
for
the
application
which
is
the
destination
of
the
packet
.
when
it
finds
the
exact
application
,
it
posts
a
synchronous
event
to
that
application
program
.
after
receiving
the
event
generated
by
the
communication
stack
,
the
application
program
proceeds
to
process
the
packet
.
in
some
cases
,
it
is
necessary
for
the
application
program
to
replay
by
posting
some
data
to
the
communication
stack
before
returning
the
control
to
it
.
then
,
when
the
communication
stack
takes
control
,
it
places
the
reply
in
the
communication
buffer
and
appends
its
header
to
the
outgoing
packet
.
finally
,
it
gives
control
to
the
device
driver
,
so
that
the
packet
can
be
transmitted
.
after
understanding
the
big
picture
of
contiki
's
communication
stack
,
let
's
examine
its
structure
with
more
detail
.
there
are
two
types
of
communication
stacks
in
contiki
,
micro
ip
and
rime
.
in
this
lesson
,
we
will
only
discuss
rime
and
leave
micro
ip
for
the
next
video
.
what
is
the
rime
communication
stack
?
rime
is
a
lightweight
communication
stack
with
a
layered
design
where
the
more
complex
communication
protocols
can
reuse
the
simpler
ones
.
when
using
rime
there
is
no
rule
that
compels
an
application
to
go
through
all
the
layers
of
the
stack
in
order
to
communicate
.
instead
it
can
use
any
primitive
or
protocol
that
it
requires
.
both
single
hop
and
multi-hop
communication
primitives
are
fully
supported
in
contiki
's
rime
communication
stack
.
however
there
is
no
packet
routing
in
the
multihub
communication
primitives
.
this
task
is
specified
by
the
application
or
the
upper
layer
protocol
.
one
of
the
benefits
of
rime
stack
is
that
users
can
implement
all
their
protocols
,
which
do
not
belong
to
rime
on
the
top
of
it
.
so
now
let
's
take
a
look
at
some
of
the
primitives
available
in
the
set
of
communication
abstractions
in
glide
.
first
is
single-hop
broadcast
.
where
the
sender
's
address
is
added
to
the
outgoing
packet
before
sending
it
to
all
local
area
neighbors
.
then
we
have
single-hop
unicast
,
which
is
used
to
send
packets
to
a
specific
destination
.
the
reliable
unicast
is
another
type
of
single-hop
unicast
that
repeatedly
sends
a
packet
to
a
particular
destination
while
waiting
for
an
acknowledgement
packet
from
the
receiver
.
finally
,
the
multi-hop
unicast
primitive
is
used
for
sending
packets
to
an
identified
node
in
the
network
which
is
located
several
hops
away
.
in
this
case
,
a
rooting
function
must
be
provided
by
the
application
or
protocol
to
choose
the
next
hop
destination
.
this
is
the
end
for
the
lesson
about
contiki
communication
and
ground
communication
stack
.
by
now
,
i
hope
you
have
a
deeper
understanding
on
the
way
contiki
's
communication
is
structured
and
how
it
works
.
see
you
in
the
next
video
.
[
sound
]
