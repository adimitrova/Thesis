[
music
]
welcome
.
it
is
good
to
see
you
back
for
this
lesson
.
previously
,
we
explored
contiki
as
a
hybrid
system
.
now
we
will
look
into
more
details
of
the
operating
system
to
discover
other
characteristics
in
depth
.
at
the
end
of
this
lesson
,
you
will
be
able
to
understand
what
benefits
and
challenges
contiki
presents
when
developing
iot
applications
.
first
of
all
,
let
's
discuss
the
main
components
of
contiki
.
a
contiki
system
includes
the
kernel
,
libraries
and
applications
or
services
,
of
which
applications
and
services
are
implemented
as
modules
.
they
are
only
loaded
when
an
application
requires
them
.
as
discussed
before
,
this
is
one
of
the
main
positive
characteristics
of
contiki
.
if
you
do
not
remember
details
about
this
,
i
recommend
you
go
back
to
other
videos
,
we
let
it
to
modular
kernel
design
and
contiki
.
in
contiki
,
it
is
possible
to
dynamically
replace
all
processes
at
run-time
,
thus
helping
to
save
resources
.
processes
in
this
case
can
be
either
services
or
application
programs
.
so
far
in
our
discussion
,
we
have
n't
addressed
what
applications
and
services
are
and
their
differences
.
from
the
point
of
view
of
contiki
,
they
are
all
modules
which
are
loaded
when
needed
.
however
,
from
the
point
of
view
of
a
programmer
,
a
service
is
implemented
to
provide
a
functionality
which
is
used
work
for
one
or
more
application
processes
.
all
communication
between
processes
are
done
through
the
kernel
.
we
mentioned
in
the
previous
lesson
that
there
is
no
hardware
obstruction
layer
in
contiki
.
as
a
result
of
this
,
device
drivers
and
applications
communicate
directly
with
the
hardware
.
if
you
do
n't
know
or
remember
why
contiki
does
not
provide
a
hardware
abstraction
layer
,
i
suggest
you
to
go
back
to
the
previews
lesson
titled
contiki
,
a
hybrid
system
.
all
processes
share
the
same
address
and
space
and
all
run
in
the
same
protection
domain
.
this
enables
contiki
to
run
in
memory
constrained
devices
.
in
order
to
give
you
a
deeper
understanding
of
this
idea
,
we
will
have
a
lesson
threads
and
multi-threading
.
in
that
lesson
,
you
will
get
an
idea
of
why
and
how
contiki
achieves
it
.
but
let
's
now
examine
how
a
process
is
created
and
treated
in
contiki
.
a
process
is
a
piece
of
program
code
which
is
executed
by
contiki
's
system
.
a
process
is
started
in
two
ways
.
the
first
is
when
contiki
starts
,
and
the
second
when
the
module
loaded
.
a
process
runs
when
an
event
related
to
the
process
occurs
,
such
as
a
timer
event
or
an
external
one
.
for
example
,
consider
an
application
that
prints
hello
world
to
the
terminal
every
second
.
this
application
process
runs
whenever
a
timer
event
is
triggered
at
every
second
.
it
means
that
a
counter
of
the
timer
will
count
down
every
second
,
and
when
it
reaches
zero
,
the
event
is
triggered
.
countdown
frequency
is
based
on
the
particular
type
of
timer
event
used
.
in
order
to
have
a
closer
view
of
a
timer
event
,
i
recommend
that
you
stay
with
me
for
the
upcoming
videos
.
in
those
videos
,
different
types
of
time
or
events
,
and
other
types
of
events
will
be
deeply
discussed
.
there
are
two
types
of
execution
modes
in
contiki
.
these
are
cooperative
and
preemptive
modes
.
cooperative
process
code
runs
sequentially
in
a
queue
.
this
means
that
the
first
process
has
the
right
to
use
the
cpu
,
while
other
processors
wait
for
their
right
to
access
the
cpu
.
after
the
process
which
occupied
the
cpu
is
finished
,
then
the
next
waiting
process
in
the
queue
gets
the
right
to
use
the
cpu
.
in
contrast
,
preemptive
mode
handles
process
differently
.
in
the
preemptive
context
,
a
running
process
can
be
stopped
by
an
interrupt
,
and
the
higher
priority
test
immediately
takes
over
the
right
to
use
the
cpu
.
after
finishing
its
job
,
it
returns
the
right
to
access
the
cpu
to
the
interrupted
process
.
a
process
is
defined
by
an
event
handler
function
and
an
optional
poll
handler
function
.
in
order
to
give
you
a
better
view
of
a
process
,
and
how
it
is
defining
contiki
,
we
're
going
to
look
at
the
internal
structure
of
a
contiki
process
.
the
contiki
process
is
a
combination
of
two
different
parts
.
these
are
process
control
block
and
the
process
threat
.
in
this
lesson
,
we
only
focus
on
contiki
system
and
contiki
processes
.
therefore
a
process
thread
will
be
discussed
in
following
videos
.
the
process
control
blog
is
composed
of
information
about
each
process
such
as
the
state
of
the
process
,
the
pointer
to
the
next
process
,
name
of
the
process
,
a
pointer
to
a
process
thread
,
the
state
of
the
proto
thread
and
internal
flags
.
the
slide
shows
a
structure
of
a
process
in
contiki
.
the
structure
is
written
in
a
standard
c
language
.
the
process
,
control
block
,
is
only
used
by
the
kernel
.
therefore
,
users
do
not
have
any
right
to
access
the
control
block
directly
.
this
helps
the
system
protect
the
process
and
avoid
unexpected
mistakes
or
bugs
caused
by
programmers
.
actually
,
the
kernel
only
keeps
a
pointer
to
the
process
of
state
which
is
health
in
the
process
'
private
memory
.
this
means
that
every
process
has
its
own
state
,
and
the
state
can
not
be
accessed
by
other
processes
.
as
you
can
see
in
this
slide
,
the
process
control
block
's
structure
is
quite
simple
,
and
it
does
not
contain
complex
information
.
therefore
,
it
is
lightweight
,
and
it
just
occupies
a
few
bytes
of
memory
.
in
contiki
,
a
process
control
block
can
not
be
declared
or
defined
directly
.
the
block
is
defined
via
the
process
macro
.
in
order
to
give
you
a
better
view
of
this
macro
,
i
am
going
to
take
an
example
of
hello
world
processing
.
as
you
can
see
,
the
process
macro
has
two
parameters
,
the
name
of
the
process
control
block
and
the
textural
description
.
the
variable
name
of
the
process
control
block
is
used
for
accessing
the
process
,
while
the
description
text
of
the
process
is
used
by
programmers
for
debugging
.
as
mentioned
in
previous
videos
,
contiki
uses
posting
events
for
interprocess
communication
.
this
mechanism
is
also
similar
to
the
messaging
mechanism
in
microkernel
described
before
.
contiki
's
system
is
partitioned
in
two
parts
.
the
first
part
is
the
core
,
and
the
second
is
the
loaded
program
section
.
the
partitioning
is
made
at
compiled
time
,
and
it
's
specific
to
the
deployment
in
which
contiki
is
used
.
typically
,
the
core
consists
of
contiki
kernel
,
the
program
loader
,
most
commonly
used
parts
of
the
language
run-time
,
support
libraries
,
and
a
communication
stack
with
device
drivers
for
the
communication
hardware
.
the
core
is
compiled
into
a
single
binary
image
that
is
stored
in
the
deploy
devices
.
it
is
generally
not
modified
after
deployment
.
although
it
is
possible
to
overwrite
or
patch
the
core
by
a
special
boot
loader
.
programs
are
loaded
into
the
system
by
the
program
loader
.
which
gets
the
program
binaries
by
using
directly
attached
storage
,
or
using
the
communications
tech
.
typically
,
programs
to
be
loaded
into
the
system
are
first
stored
in
the
eeprom
before
they
are
moved
into
the
code
memory
.
this
is
all
for
this
lesson
on
contiki
system
and
contiki
processes
.
i
hope
that
you
have
now
a
better
understanding
of
contiki
system
's
structure
and
how
it
works
.
i
hope
to
see
you
in
the
next
videos
,
which
will
explain
many
other
advanced
features
of
contiki
,
such
as
contiki
's
kernel
architecture
and
threats
.
[
sound
]
