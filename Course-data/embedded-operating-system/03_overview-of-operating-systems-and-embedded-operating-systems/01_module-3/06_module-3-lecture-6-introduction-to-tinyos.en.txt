[MUSIC] Hello, good to see you back for
this lesson. In previous videos, we explored Contiki, a popular IoT embedded OS,
its features, and advantages. Now, we're going to another
flavor of IoT embedded OS. Tiny OS, which can be seen as
an example of a monolithic kernel. First of all, I will give you
an introduction to Tiny OS, followed by its features and advantages. Tiny OS is an open source
embedded operating system. It is designed for network and
memory constrained systems. It mainly focuses on low power
wireless sensor network systems and Internet-of-Things devices. Consequently, Tiny OS
is lightweight enough to satisfy their requirements of
an embedded device with not so powerful micro-controller with a small
memory, and that operates on battery. Tiny OS was created at
Berkeley University in 1999, and later developed by many companies and
universities. Tiny OS and
its applications are written using nesC. NesC is a structure component
based extension of the C language. Now we will discuss the five
basic concepts of NesC. The first one is the separation
of construction and composition. This is achieved by the fact
that all programs in Tiny OS are built as components, and then they
are assembled to form a whole program. Components have internal
concurrency in the form of tasks. A component may be called
via its interfaces. Second is the specification of component
behavior using a set of interfaces. This means, in other words,
the provided interface is just for representing the functionality
of a particular component. The third one is regarding
bidirectional interfaces. This implies that interfaces
define functions, which can be implemented by
both commands and events. This provides the benefit
that a single interface can represent a complex
interaction between components. Four, is the static linking of components
with each other and via their interfaces. This enhances run time efficiency,
promotes robust design and allows for
better static analysis of program code. Finally, a whole program compiler. In NesC, code is generated by whole
program compilers instead of blocks. Therefore, it is better for
code generation and analysis. After this introduction,
I hope you have main ideas of Tiny OS. Now, we go into the internals of
Tiny OS features and advantages. Absolute size, compared to other popular
embedded wireless sensor networks, Tiny OS requires minimal RAM and
ROM for performing a basic task. It needs less than one kilobyte of RAM and
four kilobytes of ROM. Now, you may wonder how it can happen. Previously, I mentioned the whole
program compiler in NesC. It is used to remove dead code and
applies cross-component optimization to remove redundant operations and
minimize the overhead of module crosses. In Tiny OS, context switch
overhead corresponds to both, the cost of test scheduling and
interrupt handling overheads. The interrupt overheads consists
of both switching overhead and function overhead of the handler, which
varies with the number of saved registers. In contrast to the other traditional
multimedia applications, sensor network applications are different
in terms of time and criticality of work. Instead of chorusing a priority scheme to
allow the correct ordering of the task, Tiny OS uses a simple scheduler to
schedule based on a set of deadlines. Tiny OS with NesC compiler
support debugging and helps to detect race conditions. In order to do this, synchronous and asynchronous codes
are considered in Tiny OS. In order to give you a better
understanding of this process, synchronous and
asynchronous code will be explained. Synchronous Code or SC is a code
that is only reachable from tasks, while Asynchronous Code or AC is a code that is reachable from
at least one interrupt handler. The primary goal of Tiny OS is to
allow developers build responsive and concurrent data structures that can
safely share data between AC and SC. So components often have a mix of SC and
AC code. As a result,
there are potential causes of races. It is clear that non-preemption almost
eliminates races between tasks. However, there are some cases of
potential races between AC and SC or between AC and AC. There are two options
to avoiding such cases. The first one is to convert all
the conflicting code to tasks only for SC. The second option is to use atomic
sections to update the shared state. Next, I will discuss about active
messages, which can be considered as the main communication
abstraction model of Tiny OS. Active messages are small packets. About 36 bytes also shared
with one byte handler ID. Now you may wonder how
active messages work. Let us see. A node dispatches a message
using an event to one or more handlers that are reducer
to receive messages. Handler registration is carried
out using static wiring and a parameterized interface. Moreover, single hold
datagram protocol and unified communication
interface are provided by AM. Higher level protocols providing
multi-hub communication, are readily built on the top
of the AM interface. Now we continue to discuss
Tiny OS flexibility. To give you a comprehensive
understanding of this feature, I will explain characteristics which
justify the flexibility of Tiny OS. First, Tiny OS supports
fine-grained components. This implies that a complex application
is composed from a large number or very fine grain components. For example, the main code of
Tiny OS consists of 401 components. In addition, other 42 applications in the
source tree use about 74 components each. A component is built with
a small number of modules. And each module is from seven
to around 2,000 lines of code. Second, Tiny OS provides
concurrent components. As I mentioned early, any component
can be the source of concurrency. Events can be automatically generated
by any component via by directional interfaces. In addition,
concurrency bugs can be removed with the help of a static
raise detection of NesC. Third, Tiny OS supports hardware and
software transparency. Basically, the idea behind is to replace
software components with more efficient hardware implementations to
reduce energy consumption. For example, using a single chip which
consists of microcontroller, memory, radio transceiver and radio acceleration,
consumes around 100 microamps, while the standard server radio
stack consumes 3.6 milliamps. Last but not least is interposition. One aspect of flexibility is the ability
to insert components between other components. Whenever a component provides and uses the same interface type, it can
be inserted or removed transparently. Another feature of Tiny OS is support for
low power operation. To give you a comprehensive view of this
property, we discuss three concepts. These are CPU power usage,
power management interfaces and hardware software transparencies. First, in order to achieve
low CPU power consumption, Tiny OS has a sleep mode to which
it transitions when it is idle. Tiny OS tries to sleep as long as
possible to minimize power consumption. For example,
when listening to incoming packets, the power consumption of the CPU
is about 4.6 milliamps and 2.4 milliamps in active and
idle state respectively. Second, it is difficult to
save energy in cases of long-term wireless sensor
network applications. In order to perform the tasks
successfully, Tiny OS provides power management interfaces to allow self
systems to be put in low power idle state. For example, by powering down hardware or
disabling periodic tasks, power consumption can be
dramatically reduced. This job can be done via set of
commands provide by Tiny OS. Finally, Tiny OS supports
Hardware/Software Transparency which is already discussed above. There are many interesting
features of Tiny OS. However, we cannot
discuss all of them here. In order to cover all these features and
advantages of Tiny OS in detail, I suggest that you go through
documentations in the suggested materials. Before ending this section, we're going to take a look at the classic
Helloworld example for Tiny OS. In this example, Helloworld will be
printed out the terminal of the device. To learn details on how to write
a program and run application in Tiny OS, you should come back later to our
lectures, which have more detailed videos. Thank you for watching. [MUSIC]