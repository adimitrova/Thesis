[MUSIC] Hello, it is good to see you back. In previous videos,
we explored several kernel architectures, such as monolithic,
microkernel, and modular. Now, we're going to focus on an embedded
operating system intended for IoT devices named Contiki. Contiki is a good example of
a modular kernel, and in this video, we will discuss it's
most important features. Contiki was originally
created by Adam Dunkels in 2002 as an open source
embedded operating system. Contiki is designed for networked and
memory constraint systems. It's main focus is a low power
wireless sensor systems and Internet-of-Things devices. Therefore, Contiki always is
lightweight enough to fulfill the requirements of an embedded device
equipped with a low end micro controller, small memory and battery powered. A good example of this is
Contiki's code foot print, which only needs about 10 kilobytes
of ram and 30 kilobytes of rom. Currently there are a lot of companies and
universities involved in Contiki's development, such as
Texas Instruments Atmel, ETA Surik, Oxford University, and others. After this introduction, let's take a look
at the most important features of Contiki. Contiki uses protothreads,
software flow control. But, what is a protothread? For now, it suffices to say that
protothreats is a mechanism that mixes an event-driven model and threats to provide sequential flow control
without using complex state machines. Protothreats are an extensive topic that
we will cover in depth in another video. As we mentioned earlier, Contiki is
built for embedded network systems. Therefore, it provides powerful,
low power Internet communication stack that includes Internet standards IPv6 and IPv4 along with the recent
low power wireless standards, such as 6LoWPAN, RPL and CoAP. In addition,
due to the limited power supply and resource constraints in
embedded network system, Contiki provides mechanisms for
efficient memory allocation. Furthermore, Contiki is based on a modular
kernel that supports dynamic loading and linking at. As a result,
software modules are loaded only when the system requires their
particular functionality. It is an advantage for
system administrators and users to know for
how long a system has been running, or the system's working hours when
a particular power supply is used. In order to address this issue,
Contiki provides a mechanism for estimating the system's power consumption. Contiki can run in different types
of embedded networked drives, such as and other arm based devices. These hardware are popular and
easy to buy with low prices. In addition, it is possible to port Contiki to
new hardware with a little effort. As we all know, it is not easy to
set up a large wireless network. It requires a lot of time and
effort to debug and deploy devices. To address this issue, Contiki
provides the Cooja Network Simulator. Cooja allows simulator large
scale networks comprising 10s of nodes running on fully
emulated hardware devices. Using Contiki's examples is
the easiest way to implement simple or complicated applications in a short time. Some examples show how to
develop application code, while others demonstrate system features. In addition, there is a common line shell,
suitable for debugging operations. Shell commands can be combined in
powerful ways using Unix style pipelines. It is also possible for an application to define its own shell commands that
work together with the existing ones. There are other interesting
features of Contiki that it was not possible
to cover in these lessons. Therefore we strongly encourage you
to read the recommended materials. Before ending this video,
I would like to show you how to implement the classic
hello world example in Contiki. If you run this code,
the phrase hello world, will be printed to
the terminal of the device. To get the details on how
to write a program and drawn an application in Contiki. You should come back to our lectures
who have more detail be use. Thank you for watching and
see in next videos. [MUSIC]