[MUSIC] Hello. It is good to see you back for
this lesson. In previous videos we explored,
with a bird's eye view, what operating systems are and
how they execute their tasks. Now we will take a look
into the Linux Kernel to discuss some of its characteristics. At the end of the lesson you should
understand the main Linux Kernel functions and it's advantages. Let's begin with some questions. What is a Linux process? How does a process operate? And how many processes are there? In order to deal with these questions,
we first define what are Linux processes. A process is one of the fundamental
abstractions in Linux. In short it can be considered
a program in execution. A process encompasses a set of
resources such as processor state, address space, threats and data section. The Linux Kernel implements a process
manager to keep track of each process. It does so using processes
scriptors which store information such as run state of the process,
address space, list of open files, process priority, etc. A process can be in one
of four possible states. A running state means the process is
already running or it is ready to run. The waiting state is used for
processes waiting for an event or a particular resource. There are two types of waiting, including interruptible waiting and
uninterruptible waiting. A process is in a stopped state when
it's not eligible for running anymore. Often, as a result of
receiving a system signal. However, in some cases a process
that is being debugged can be in the stopped state. Finally, a zombie state
is a process occurs when the process is terminated but the
Kernel has not removed its resources yet. Next we will focus on memory
management in the Linux Kernel. Actually the memory management system in
the Kernel is a virtual memory system. This means that all memory
addresses as seen by user processes are not the physical addresses
used by the hardware. To give you a better idea of
memory management in Linux, I will discuss its main features. First is large address spaces. This means the Kernel allows running
programs to allocate more virtual memory than the system's physical memory. The Kernel also provides
memory protection. This way every process has its
own virtual addressed space. Virtual addresses spaces are completely
separated unless a result process running concurrently
do not effect one another. Next is memory mapping, which is used for mapping the image of data files
to a process addresses space. This way, the content of a file is directly linked
to a process virtual addresses space. Linux also has a mechanism for
fair physical memory allocation. Which ensures that running
processes receive a fair share of the system's physical memory. And last but not least,
there is a shared virtual memory. As mentioned before, each process has
a separate virtual address space. However, in some cases,
a shared virtual memory is necessary. Let's take a look at an example. When many processors run, a VAS come in shell instead of
replicating many copies of VAS. It is better to have only one
copy in physical memory and those processes can share it. Now, let's talk about
scheduling in the Linux Kernel. Scheduling is very important, since it defines the policy
on when a process can run. This is which process runs first and
which one runs later. The Linux scheduler is
a priority scheduler. Meaning, it's policy is based
on the priority of processes. Every time the scheduler runs, the priority of all processes
in the wrong cue is analyzed. And the process with the highest
priority is allowed to run next. In systems with many processors,
each processor has a separate run queue. And each processor selects
processes only from it's own queue. However, there may be the case that
a processor has along waiting queue. When compared to other processors. In this case the Linux scheduler will
move processors from the long queue to the shorter queues. Does getting a balanced
workload as a result. In previous videos we define an interrupt
as an event generated by a hardware component that causes change in
the sequence of executed instructions. Interrupts can be classified in
two categories, synchronous and asynchronous interrupts. Synchronous interrupts are produced
by the CPU control unit while executing instructions. They are called synchronous
because the control unit issues them only after terminating
the execution of an instruction. On the other hand,
asynchronous interrupts are generated by other hardware devices at arbitrary
times regarding the CPU clock signals. The Linux Kernel handles interrupt
signals using interrupt handlers, also called interrupt service routines. The main difference between
interrupt handlers and other functions in the Kernel
is that an interrupt handler is executed in a special context
named Interrupt Context. To finalize today's talk, I will list
some of the advantages of Linux Kernel. The Linux Kernel is open source and
anyone can contribute to it's code base. Individuals and organizations alike. As a result of this. There is a large community that provides
support and has produced large quantities of documentation, most of it
freely available in the Internet. The Linux Kernel can be easily customized. Therefore, there is wide variety
of computer architectures where you can use it. From small sized microcontrollers to
full fledged minicore processors. The Linux Kernel is a very
complex piece of software. Unfortunately, many of its details
were not covered in this video due to lack of time. Functions such as input-output
device management. Interprocess communication. Security and protection
management are now describe here. However, to get a comprehensive view
of them, I recommend you to read the Linux Kernel Development book
third edition written by Robert Love. Thanks for watching and
see you again in the coming lectures. [MUSIC]