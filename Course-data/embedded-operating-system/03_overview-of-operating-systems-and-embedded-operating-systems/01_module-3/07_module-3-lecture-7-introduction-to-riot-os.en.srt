1
00:00:00,000 --> 00:00:05,895
[MUSIC]

2
00:00:05,895 --> 00:00:08,670
Hello, it is good to see you back for
this lesson.

3
00:00:09,670 --> 00:00:16,730
In previous videos we explored Kontiki and
Tanjores, their features and advantages.

4
00:00:16,730 --> 00:00:21,560
Now we're going to address
another type of IOT embedded OS.

5
00:00:21,560 --> 00:00:25,860
Right, which can be seen as an example
of a micro current of design.

6
00:00:26,900 --> 00:00:30,040
First of all I will give you
an introduction to Riot and

7
00:00:30,040 --> 00:00:32,520
then I will discuss its features and
advantages.

8
00:00:33,940 --> 00:00:37,770
Riot is an open source
embedded operating system.

9
00:00:37,770 --> 00:00:41,719
It is designed for networked and
memory constrained embedded systems.

10
00:00:42,980 --> 00:00:47,900
Its primary focus is on low-power
wireless sensor network systems and

11
00:00:47,900 --> 00:00:49,200
Internet of Things devices.

12
00:00:50,430 --> 00:00:54,190
As a result of this,
it is made lightweight enough to satisfy

13
00:00:54,190 --> 00:00:59,210
the requirements of embedded devices
having limited processing capacity,

14
00:00:59,210 --> 00:01:02,780
small main memory and storage,
and powered by battery.

15
00:01:04,120 --> 00:01:09,730
The kernel of Riot was first developed by
several European academic institutions

16
00:01:09,730 --> 00:01:15,540
in 1999, and later by various companies,
individuals and universities.

17
00:01:16,650 --> 00:01:19,910
Riot and
its applications are written in ANSI C.

18
00:01:21,260 --> 00:01:25,820
Riot implements a microkernel of
architecture, inherited from Fire Kernal.

19
00:01:27,260 --> 00:01:33,140
In addition to Fire Kernel's original
features, powerful C++ libraries such as,

20
00:01:33,140 --> 00:01:39,310
the Wise Leaf algorithm framework and
tcpip network stack are added in to riot.

21
00:01:40,930 --> 00:01:46,710
As primly mentioned, Riot is built for
networked and memory constrained systems.

22
00:01:46,710 --> 00:01:50,520
Therefore it needs to save memory and
reduce the size of it's can.

23
00:01:51,890 --> 00:01:55,330
In order to address this,
Riot is designed in a modular way.

24
00:01:56,750 --> 00:02:00,770
It also tries to limit dependencies
between the modules as small as possible.

25
00:02:02,400 --> 00:02:06,610
In addition, the configuration of
the system can be customized to meet

26
00:02:06,610 --> 00:02:10,650
a particular specification,
thereby minimizing the size of the kernel.

27
00:02:12,120 --> 00:02:17,660
For instance, a Riot kernel can require as
small as a few hundred bytes of RAM and

28
00:02:17,660 --> 00:02:18,530
program storage.

29
00:02:20,040 --> 00:02:22,710
Another benefit of modularity is

30
00:02:22,710 --> 00:02:25,640
the effect of bugs is
limited in the module itself.

31
00:02:27,290 --> 00:02:31,790
Similar to Kontiki a bug in a module
cannot mess up with the whole system.

32
00:02:33,460 --> 00:02:38,030
In contrast to many other operating
systems, write a scheduler

33
00:02:38,030 --> 00:02:42,060
works without periodic events and
it's consider a tickles scheduler.

34
00:02:43,680 --> 00:02:48,650
One benefit of this is, to switch to idle
threat, when there are no pending tests.

35
00:02:49,790 --> 00:02:55,040
In addition, the idle threat contains
a function to decide this looping duration

36
00:02:55,040 --> 00:02:56,470
of a device, or system.

37
00:02:58,560 --> 00:03:03,200
This decision is made, based on
the peripheral devices in use, this

38
00:03:03,200 --> 00:03:07,860
gives the advantage that the system can
stay in sleep state as long as possible.

39
00:03:09,160 --> 00:03:12,480
Subsequently, energy consumption
can be significantly minimized.

40
00:03:13,540 --> 00:03:16,990
Only interrupts wake the system
up from the idle state.

41
00:03:18,100 --> 00:03:22,610
Moreover, all kernel functions
are kept as small as possible

42
00:03:22,610 --> 00:03:27,550
thus allowing the kernel to run even on a
small systems with very low clock speeds.

43
00:03:29,320 --> 00:03:34,330
The scheduler is the sign to minimize
the occurrences of threats which

44
00:03:34,330 --> 00:03:36,660
thereby reducing the overhead by switch

45
00:03:38,430 --> 00:03:42,960
questions related to interrupts may
have popped out in your main software.

46
00:03:44,000 --> 00:03:48,940
For instance, how do interrupts
awaken the system from a sleep state?

47
00:03:48,940 --> 00:03:50,000
How this would get handled?

48
00:03:51,060 --> 00:03:52,710
In order to give you answers for

49
00:03:52,710 --> 00:03:56,790
such questions, I'm going to
explain interrupt handling in Riot.

50
00:03:58,420 --> 00:04:02,930
Interrupt handling is an important
part of Riot because failure to handle

51
00:04:02,930 --> 00:04:06,990
interrupts well has a serious impact
on the performance of the system.

52
00:04:08,320 --> 00:04:12,950
It is known that most device drivers for
common real time and

53
00:04:12,950 --> 00:04:18,070
wireless network are designed
to directly use interrupts.

54
00:04:18,070 --> 00:04:21,213
However using interrupts
is not straightforward.

55
00:04:21,213 --> 00:04:26,010
For example,
in a pre-emptively scheduled system,

56
00:04:26,010 --> 00:04:30,460
interrupt is passed through kernel and
context switching must be carried out.

57
00:04:31,870 --> 00:04:36,300
Before switching to the interrupt, the
context of the running task must be saved

58
00:04:37,770 --> 00:04:42,280
as you can see,
it is complicated to work with.

59
00:04:42,280 --> 00:04:45,790
In order to help programmers
achieve this easily,

60
00:04:45,790 --> 00:04:50,560
Riot provides an API which is similar
to common sensor net programming model.

61
00:04:52,030 --> 00:04:56,330
In addition, Riot is built
targeting the lowest possible

62
00:04:56,330 --> 00:05:00,580
interrupt latencies so that real
time requirements can be fulfilled.

63
00:05:01,830 --> 00:05:07,220
Similar to other embedded wireless
network operating systems, Riot supports

64
00:05:07,220 --> 00:05:14,540
various types of hardware such as
16 bit MSP430 or 32 bit ARM server.

65
00:05:16,090 --> 00:05:19,230
One of the benefits of Riot
is it's small footprint.

66
00:05:20,580 --> 00:05:23,790
It only requires less than
five kilobytes of ROM and

67
00:05:23,790 --> 00:05:27,940
two kilobytes of RAM to run a basic
wireless sensor network application.

68
00:05:29,360 --> 00:05:33,750
Compare to Contiki, Riot is better
in terms of required minimum RAM and

69
00:05:33,750 --> 00:05:35,340
ROM for a basic task.

70
00:05:36,490 --> 00:05:39,740
Another advantage of Riot
related to portability

71
00:05:39,740 --> 00:05:43,020
is in using advance
features of processors.

72
00:05:43,020 --> 00:05:46,360
For instance,
ARM processors are powerful and

73
00:05:46,360 --> 00:05:51,310
provide many complex features
like vector interrupt controller.

74
00:05:51,310 --> 00:05:56,060
These features may not be suitable for
other embedded network OSs.

75
00:05:56,060 --> 00:06:01,020
However, Riot utilizes,
by virtue of separation of CPU code

76
00:06:01,020 --> 00:06:07,250
from the kernel implementation
Riot's kernel is built in the target

77
00:06:07,250 --> 00:06:13,210
of achieving maximum reliability and
strong realtime characteristics.

78
00:06:13,210 --> 00:06:18,860
Therefore, Riot supports multithreading
with zero-latency interrupt handlers and

79
00:06:18,860 --> 00:06:20,640
minimum context-switching times.

80
00:06:21,940 --> 00:06:27,490
In order to assist system developers
take advantage of really easily.

81
00:06:27,490 --> 00:06:30,070
Riot provides a developer friendly API.

82
00:06:31,910 --> 00:06:34,440
Another advantage of Riot is that

83
00:06:34,440 --> 00:06:37,760
is allows developers to create
as many threads as possible.

84
00:06:38,980 --> 00:06:42,740
In addition, distributed systems
can be easily implemented

85
00:06:42,740 --> 00:06:44,660
using the kernel messaging API.

86
00:06:46,120 --> 00:06:50,950
The maximum number of threads is only
limited by the available memory and

87
00:06:50,950 --> 00:06:55,340
the size of the stack for threads,
while the computational and

88
00:06:55,340 --> 00:06:56,700
memory overhead is minimum.

89
00:06:58,700 --> 00:07:03,220
Similar to other embedded
network operating systems,

90
00:07:03,220 --> 00:07:05,780
Riot supports different
network protocols for

91
00:07:05,780 --> 00:07:11,236
resource constrains systems
Such as 6LoWPAN and RPL.

92
00:07:11,236 --> 00:07:15,124
In addition, IPv4,

93
00:07:15,124 --> 00:07:19,510
IPv6, UDP and
TCP are also fully supported.

94
00:07:20,900 --> 00:07:25,020
Similar to Kontiki,
network stack in Riot is also modular.

95
00:07:26,020 --> 00:07:30,790
This gives the flexibility to exchange
protocol layers at any hierarchy.

96
00:07:30,790 --> 00:07:33,940
In addition,
an adaptation layer is provided

97
00:07:33,940 --> 00:07:38,070
that offers an IEEE 802.15.4
complete interface.

98
00:07:38,070 --> 00:07:43,660
There are many interesting things of Riot.

99
00:07:43,660 --> 00:07:46,089
Unfortunately we cannot
discuss them all here.

100
00:07:47,360 --> 00:07:51,060
In order to cover more features,
advantages of Riot and

101
00:07:51,060 --> 00:07:53,910
learn to program for it in detail,

102
00:07:53,910 --> 00:07:57,330
i suggest you to go through the
commentation in the suggested materials.

103
00:07:59,100 --> 00:08:00,710
Before ending this section,

104
00:08:00,710 --> 00:08:04,199
we're going to take a look at
the classic Helloworld example in Riot.

105
00:08:05,340 --> 00:08:09,890
In this example, 'Hello World' will be
printed out to the terminal of the device.

106
00:08:11,020 --> 00:08:14,770
In order to know the details
on how to write a program and

107
00:08:14,770 --> 00:08:18,600
run applications in Riot,
please come back to our lecture.

108
00:08:18,600 --> 00:08:20,255
Who have more detailed videos.

109
00:08:21,450 --> 00:08:25,670
With this lesson, we concluded
the embedded operation systems model.

110
00:08:25,670 --> 00:08:26,870
I hope you enjoyed watching.