1
00:00:00,290 --> 00:00:05,879
[MUSIC]

2
00:00:05,879 --> 00:00:06,980
Welcome.

3
00:00:06,980 --> 00:00:08,810
It is good to see you back for
this lesson.

4
00:00:09,810 --> 00:00:14,970
In previous videos, we explored
a monolithic kernel and its main features.

5
00:00:14,970 --> 00:00:19,560
Now, we will move into another
kind of kernel, the Microkernel.

6
00:00:19,560 --> 00:00:23,150
In this video, we will cover
the definition of microkernel,

7
00:00:23,150 --> 00:00:27,720
how it compares to the monolithic kernel,
and its advantages and disadvantages.

8
00:00:29,510 --> 00:00:31,800
Let's begin with some
interesting questions.

9
00:00:32,840 --> 00:00:35,220
What is microkernel, and

10
00:00:35,220 --> 00:00:39,710
what is the main difference between
a monolithic kernel and the microkernel?

11
00:00:41,120 --> 00:00:43,160
Before answering these questions,

12
00:00:43,160 --> 00:00:47,300
let's go back briefly to our
lesson monolithic Linux Kernel.

13
00:00:48,550 --> 00:00:53,670
In a monolithic kernel, all important
functions and services of the operating

14
00:00:53,670 --> 00:00:59,830
system, such as file system and device
drivers, are executed in kernel mode.

15
00:01:01,270 --> 00:01:06,530
As a result, the kernel is very large
with millions of lines of code inside.

16
00:01:07,990 --> 00:01:12,050
In contrast, in a Microkernel,
almost all functions and

17
00:01:12,050 --> 00:01:17,380
services are removed from the kernel
mode and relocated into the user mode.

18
00:01:18,830 --> 00:01:21,450
As a result, the kernel size is minimal.

19
00:01:23,070 --> 00:01:26,200
At this point, there may be
a question raising in your mind.

20
00:01:27,220 --> 00:01:29,800
What is the main function of the kernel,
and

21
00:01:29,800 --> 00:01:33,840
what does it do if almost all
functions are removed out of it?

22
00:01:35,250 --> 00:01:40,190
When comparing a Microkernel based
system with a conventional one,

23
00:01:40,190 --> 00:01:44,400
the main difference is that most
of the operating systems code

24
00:01:44,400 --> 00:01:48,480
runs as a separate process,
mostly outside the kernel.

25
00:01:50,170 --> 00:01:54,488
Then, the tasks left for
the kernel are only interrupt handling,

26
00:01:54,488 --> 00:01:58,430
low-level process management and
message passing handling.

27
00:01:59,640 --> 00:02:03,800
Now, let's talk about interprocess
communication in Microkernels.

28
00:02:05,200 --> 00:02:09,390
A common communication method in
Microkernels is message passing.

29
00:02:10,610 --> 00:02:14,210
To better understand it,
we must address three issues.

30
00:02:15,380 --> 00:02:18,320
What is interprocess communication?

31
00:02:18,320 --> 00:02:22,030
What is a message, and
how does message passing work?

32
00:02:23,490 --> 00:02:26,380
Interprocess communication, or IPC for

33
00:02:26,380 --> 00:02:31,810
short, refers to the mechanism that
an operating system provides for

34
00:02:31,810 --> 00:02:37,130
exchanging information among
processes a message is simply

35
00:02:37,130 --> 00:02:42,130
the data that is transferred from
one process to another using IPC.

36
00:02:43,840 --> 00:02:49,260
In a Microkernel, messages
are passed using message registers.

37
00:02:49,260 --> 00:02:54,100
This is a sending process,
writes a message to the register of

38
00:02:54,100 --> 00:02:59,320
the receiving process, and only then
the receiving process can read the data.

39
00:03:00,510 --> 00:03:05,860
Sometimes the data to be sent can be
larger than the receiver's register,

40
00:03:05,860 --> 00:03:09,270
in which case,
the message contains a reference

41
00:03:09,270 --> 00:03:12,838
to a shared memory region
where the data is stored.

42
00:03:12,838 --> 00:03:16,830
IPC is synchronous,

43
00:03:16,830 --> 00:03:21,690
meaning that when a message is
sent from one process to another,

44
00:03:21,690 --> 00:03:25,820
both processes must call
the corresponding IPC operation.

45
00:03:27,190 --> 00:03:33,450
A sender will log until either
the receiver has performed the IPC call,

46
00:03:33,450 --> 00:03:36,570
or a specified time of
interval has lapsed.

47
00:03:38,600 --> 00:03:43,670
It is important to mention that IPC
does not use intermediate buffers.

48
00:03:43,670 --> 00:03:48,400
Therefore, improving efficiency and
reducing the complexity of the operation.

49
00:03:50,770 --> 00:03:53,379
Let's move on to the advantages
of Microkernels.

50
00:03:54,870 --> 00:03:59,710
One of the main advantages of
a Microkernel is that its code is minimal.

51
00:04:01,080 --> 00:04:04,720
It is often the case that
the less code is written,

52
00:04:04,720 --> 00:04:07,050
the less probability
that an error can occur.

53
00:04:08,740 --> 00:04:14,170
Other benefits, due to a minimal kernel
are small trusted computing base and

54
00:04:14,170 --> 00:04:15,930
suitability for verification.

55
00:04:17,180 --> 00:04:20,270
Trusted computing base
is related to security.

56
00:04:21,660 --> 00:04:24,810
In computer security terminology,

57
00:04:24,810 --> 00:04:30,000
the trusted computing base is the set
of all hardware, software and

58
00:04:30,000 --> 00:04:33,950
procedural components that
enforce the security policy.

59
00:04:35,290 --> 00:04:38,730
This means that in order
to break security,

60
00:04:38,730 --> 00:04:42,050
an attacker must subvert one or
more of them.

61
00:04:43,620 --> 00:04:49,840
Regarding verification, the benefit
of a small quote size is obvious.

62
00:04:49,840 --> 00:04:53,310
The less code we have,
the simpler it is verifying it.

63
00:04:54,980 --> 00:04:58,390
Finally, due to the modularity
of Microkernel,

64
00:04:58,390 --> 00:05:03,800
it is easy to add software to the system,
thus making it scalable and extensible.

65
00:05:06,110 --> 00:05:10,050
We have already talked about
the advantages of Microkernels, but

66
00:05:10,050 --> 00:05:11,197
what are their drawbacks?

67
00:05:11,197 --> 00:05:15,000
Why didn't Microkernel
actually win the race?

68
00:05:15,000 --> 00:05:19,620
Although they seemed to
be a better idea in 1992.

69
00:05:19,620 --> 00:05:24,620
To answer this question, let's go through
a simple example like creating a file.

70
00:05:26,050 --> 00:05:29,370
In order to create a file
in a monolithic kernel,

71
00:05:29,370 --> 00:05:33,610
It is necessary to perform
a context to switch only two times.

72
00:05:34,690 --> 00:05:39,030
The first one occurs when the system
switches from the application

73
00:05:39,030 --> 00:05:42,570
to the kernel, so
the file operation can be executed.

74
00:05:43,770 --> 00:05:48,799
The second one occurs when the kernel
gives control back to the calling process.

75
00:05:49,950 --> 00:05:52,970
Now, in the case of a Microkernel,

76
00:05:52,970 --> 00:05:57,510
how expensive is the file operation
in terms of context switching?

77
00:05:58,710 --> 00:06:04,230
Well, it turns out it takes a lot more
context switching between kernel and

78
00:06:04,230 --> 00:06:05,170
the user process.

79
00:06:06,540 --> 00:06:07,120
The reason for

80
00:06:07,120 --> 00:06:12,970
this is that now it is necessary to
switch among multiple processors.

81
00:06:12,970 --> 00:06:15,210
Each one controlling a small function.

82
00:06:16,520 --> 00:06:21,370
In this particular example, one process
may be in charge of the file system

83
00:06:21,370 --> 00:06:23,580
while another handles the device driver.

84
00:06:24,910 --> 00:06:28,420
As a result, the overall system
response becomes slower.

85
00:06:30,290 --> 00:06:34,740
This overhead is not limited
to input-output operations.

86
00:06:34,740 --> 00:06:39,440
Other kernel services, such inter-process
communication, are also affected.

87
00:06:41,300 --> 00:06:46,350
In this video, we'll describe the most
important features of Microkernels.

88
00:06:46,350 --> 00:06:50,350
However, to get a deeper
understanding of its details,

89
00:06:50,350 --> 00:06:52,559
I recommend you go through
the suggested materials.

90
00:06:54,020 --> 00:06:59,682
Thanks for watching, and
see you in coming videos.

91
00:06:59,682 --> 00:07:00,709
[SOUND]