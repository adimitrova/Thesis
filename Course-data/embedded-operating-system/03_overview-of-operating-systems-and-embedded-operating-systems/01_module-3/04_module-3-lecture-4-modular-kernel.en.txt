[MUSIC] Hello, it is good to see you back for
this lesson. Previously, we explored with
an eagle's eye what Linux kernel is and why it is important. Now, we will look into
another type of kernel to discover it's detailed
characteristics and advantages. At the end of the lesson, you should
understand the differences between all three types of kernel and
their features. As a result, you will be able to
utilize a specific kernel type for a particular application requirements. Let's begin describing what
the modular kernel is. A modular kernel It's a sort of hybrid
between a monolithic kernel and a microkernel. it aims to get the best features
of both types of architectures. So in concrete,
a modular kernel can perform tasks as good as a monolithic kernel while the stability
is similar as a microkernel. As a result, we obtain a kernel with
very efficient memory utilization and good overall performance at the same time. A modular kernel comprises
a multitude of modules, each one dedicated to
a specific system task. A key feature of these systems
is that modules are loaded only when the functionality is needed. For example,
a particular device driver is loaded only if there is a process that
needs access to that device. Loading a module does not
take a large amount of time. However, this strategy could
generate a severe overhead if multiple modules are constantly
loaded and unloaded. The system would have spent most
of the time managing the modules instead of executing actual work, and
thus yielding very poor performance. To address this issue, once a module is loaded it will remain in
the kernel until it is explicitly removed. In most cases, a module is required
by only one particular process. However, it is possible that several
processes require the same module. In which case,
the colonel creates multiple copies of it. The main reason for
doing this is to prevent the overhead cost by constantly loading and
unloading modules. In other kernel architectures
when new functionality is added, the kernel must be revealed. However, this is not the case for
modular kernels, where new models can be easily added
without recompiling thus saving time. Filing and fixing bugs in a monolithic
kernel is a very hard task. It is time consuming and
demands a lot of effort. For example, a bug in a device
driver which is bound to the kernel may prevent the system from booting. In this situation, it is hard to say what
part of the kernel is causing the problem? This situation can easily be avoided when
a device driver is a loadable module. Since the kernel must boot
before loading any module. In case the system does not
perform correctly after the kernel is successfully booted,
it's simple to find the fault module. As we discussed before, the kernel
loads modules only when necessary. Therefore, the system's memory
can be efficiently managed. Due to these advantages
of modular kernels, we can conclude that
with the modular kernel, the overall system performance increases
and the kernel size is not large. Although a modular system provides
a multitude of advantages, it still has some drawbacks. As mentioned before, the modular kernel
inherits stability from microkernel. However, this stability cannot be
warranted in cases of fragmentation. Another disadvantage is that
security may be vulnerable when many interspaces are passed through. Finally, it is not easy to
maintain a large number of modules when they are created by
several third parties. This is the end of our lesson today. Hopefully by now, you have a better
idea of what a modular kernel is, what makes it different from other
kernels and what it's advantages are. In the next video, we will discuss
how a modular kernel is implemented. Thank you for watching and see you again. [MUSIC]