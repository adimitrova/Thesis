[music] hello.
it is good to see you back for this lesson.
in previous videos we explored, with a bird's eye view, what operating systems are and how they execute their tasks.
now we will take a look into the linux kernel to discuss some of its characteristics.
at the end of the lesson you should understand the main linux kernel functions and it's advantages.
let's begin with some questions.
what is a linux process?
how does a process operate?
and how many processes are there?
in order to deal with these questions, we first define what are linux processes.
a process is one of the fundamental abstractions in linux.
in short it can be considered a program in execution.
a process encompasses a set of resources such as processor state, address space, threats and data section.
the linux kernel implements a process manager to keep track of each process.
it does so using processes scriptors which store information such as run state of the process, address space, list of open files, process priority, etc.
a process can be in one of four possible states.
a running state means the process is already running or it is ready to run.
the waiting state is used for processes waiting for an event or a particular resource.
there are two types of waiting, including interruptible waiting and uninterruptible waiting.
a process is in a stopped state when it's not eligible for running anymore.
often, as a result of receiving a system signal.
however, in some cases a process that is being debugged can be in the stopped state.
finally, a zombie state is a process occurs when the process is terminated but the kernel has not removed its resources yet.
next we will focus on memory management in the linux kernel.
actually the memory management system in the kernel is a virtual memory system.
this means that all memory addresses as seen by user processes are not the physical addresses used by the hardware.
to give you a better idea of memory management in linux, i will discuss its main features.
first is large address spaces.
this means the kernel allows running programs to allocate more virtual memory than the system's physical memory.
the kernel also provides memory protection.
this way every process has its own virtual addressed space.
virtual addresses spaces are completely separated unless a result process running concurrently do not effect one another.
next is memory mapping, which is used for mapping the image of data files to a process addresses space.
this way, the content of a file is directly linked to a process virtual addresses space.
linux also has a mechanism for fair physical memory allocation.
which ensures that running processes receive a fair share of the system's physical memory.
and last but not least, there is a shared virtual memory.
as mentioned before, each process has a separate virtual address space.
however, in some cases, a shared virtual memory is necessary.
let's take a look at an example.
when many processors run, a vas come in shell instead of replicating many copies of vas.
it is better to have only one copy in physical memory and those processes can share it.
now, let's talk about scheduling in the linux kernel.
scheduling is very important, since it defines the policy on when a process can run.
this is which process runs first and which one runs later.
the linux scheduler is a priority scheduler.
meaning, it's policy is based on the priority of processes.
every time the scheduler runs, the priority of all processes in the wrong cue is analyzed.
and the process with the highest priority is allowed to run next.
in systems with many processors, each processor has a separate run queue.
and each processor selects processes only from it's own queue.
however, there may be the case that a processor has along waiting queue.
when compared to other processors.
in this case the linux scheduler will move processors from the long queue to the shorter queues.
does getting a balanced workload as a result.
in previous videos we define an interrupt as an event generated by a hardware component that causes change in the sequence of executed instructions.
interrupts can be classified in two categories, synchronous and asynchronous interrupts.
synchronous interrupts are produced by the cpu control unit while executing instructions.
they are called synchronous because the control unit issues them only after terminating the execution of an instruction.
on the other hand, asynchronous interrupts are generated by other hardware devices at arbitrary times regarding the cpu clock signals.
the linux kernel handles interrupt signals using interrupt handlers, also called interrupt service routines.
the main difference between interrupt handlers and other functions in the kernel is that an interrupt handler is executed in a special context named interrupt context.
to finalize today's talk, i will list some of the advantages of linux kernel.
the linux kernel is open source and anyone can contribute to it's code base.
individuals and organizations alike.
as a result of this.
there is a large community that provides support and has produced large quantities of documentation, most of it freely available in the internet.
the linux kernel can be easily customized.
therefore, there is wide variety of computer architectures where you can use it.
from small sized microcontrollers to full fledged minicore processors.
the linux kernel is a very complex piece of software.
unfortunately, many of its details were not covered in this video due to lack of time.
functions such as input-output device management.
interprocess communication.
security and protection management are now describe here.
however, to get a comprehensive view of them, i recommend you to read the linux kernel development book third edition written by robert love.
thanks for watching and see you again in the coming lectures.
[music]
