music 
hello, good to see you back 
this lesson 
in previous videos, we explored contiki, 
a popular iot embedded os, 
features, advantages 
now, going to another 
flavor iot embedded os 
tiny os, seen 
an example a monolithic kernel 
first all, i will give you 
an introduction to tiny os, 
followed features advantages 
tiny os is an open source 
embedded operating system 
is designed network 
memory constrained systems 
mainly focuses low power 
wireless sensor network systems 
internetofthings devices 
consequently, tiny os 
is lightweight enough 
to satisfy requirements 
an embedded device so 
powerful microcontroller a small 
memory, that operates battery 
tiny os created 
berkeley university in , 
later developed many companies 
universities 
tiny os 
applications written using nesc 
nesc is a structure component 
based extension c language 
we will discuss five 
basic concepts nesc 
first one is separation 
construction composition 
this is achieved fact 
that programs in tiny os 
built components, 
assembled to form a whole program 
components internal 
concurrency in form tasks 
a component may called 
via interfaces 
second is specification component 
behavior using a set interfaces 
this means, in words, 
provided interface is 
representing functionality 
a particular component 
third one is regarding 
bidirectional interfaces 
this implies that interfaces 
define functions, 
implemented 
commands events 
this provides benefit 
that a single interface 
represent a complex 
interaction between components 
four, is static linking components 
via interfaces 
this enhances run time efficiency, 
promotes robust design 
allows 
better static analysis program code 
finally, a whole program compiler 
in nesc, code is generated whole 
program compilers instead blocks 
therefore, is better 
code generation analysis 
this introduction, 
i hope you main ideas tiny os 
now, we go internals 
tiny os features advantages 
absolute size, compared to popular 
embedded wireless sensor networks, 
tiny os requires minimal ram 
rom performing a basic task 
needs less one kilobyte ram 
four kilobytes rom 
now, you may wonder happen 
previously, i mentioned whole 
program compiler in nesc 
is used to remove dead code 
applies crosscomponent optimization to 
remove redundant operations 
minimize overhead module crosses 
in tiny os, context switch 
overhead corresponds to both, 
cost test scheduling 
interrupt handling overheads 
interrupt overheads consists 
switching overhead 
function overhead handler, 
varies number saved registers 
in contrast to traditional 
multimedia applications, 
sensor network applications different 
in terms time criticality work 
instead chorusing a priority scheme to 
allow correct ordering task, 
tiny os uses a simple scheduler to 
schedule based a set deadlines 
tiny os nesc compiler 
support debugging 
helps to detect race conditions 
in order to this, synchronous 
asynchronous codes 
considered in tiny os 
in order to give you a better 
understanding this process, 
synchronous 
asynchronous code will explained 
synchronous code sc is a code 
that is reachable tasks, 
while asynchronous code 
ac is a code that is reachable 
least one interrupt handler 
primary goal tiny os is to 
allow developers build responsive 
concurrent data structures that 
safely share data between ac sc 
so components often a mix sc 
ac code 
a result, 
there potential causes races 
is clear that nonpreemption almost 
eliminates races between tasks 
however, there cases 
potential races between ac 
sc between ac ac 
there two options 
to avoiding cases 
first one is to convert 
conflicting code to tasks sc 
second option is to use atomic 
sections to update shared state 
next, i will discuss active 
messages, considered 
main communication 
abstraction model tiny os 
active messages small packets 
bytes also shared 
one byte handler id 
you may wonder 
active messages work 
let us see 
a node dispatches a message 
using an event to one 
handlers that reducer 
to receive messages 
handler registration is carried 
using static wiring 
a parameterized interface 
moreover, single hold 
datagram protocol 
unified communication 
interface provided 
higher level protocols providing 
multihub communication, 
readily built top 
interface 
we continue to discuss 
tiny os flexibility 
to give you a comprehensive 
understanding this feature, 
i will explain characteristics 
justify flexibility tiny os 
first, tiny os supports 
finegrained components 
this implies that a complex application 
is composed a large number 
fine grain components 
example, main code 
tiny os consists components 
in addition, applications in 
source tree use components 
a component is built 
a small number modules 
module is seven 
to around , lines code 
second, tiny os provides 
concurrent components 
i mentioned early, component 
source concurrency 
events automatically generated 
component via directional 
interfaces 
in addition, 
concurrency bugs removed 
help a static 
raise detection nesc 
third, tiny os supports hardware 
software transparency 
basically, idea behind is to replace 
software components efficient 
hardware implementations to 
reduce energy consumption 
example, using a single chip 
consists microcontroller, memory, 
radio transceiver radio acceleration, 
consumes around microamps, 
while standard server radio 
stack consumes milliamps 
last least is interposition 
one aspect flexibility is ability 
to insert components between 
components 
whenever a component provides 
uses interface type, 
inserted removed transparently 
another feature tiny os is support 
low power operation 
to give you a comprehensive view this 
property, we discuss three concepts 
cpu power usage, 
power management interfaces 
hardware software transparencies 
first, in order to achieve 
low cpu power consumption, 
tiny os a sleep mode to 
transitions is idle 
tiny os tries to sleep long 
possible to minimize power consumption 
example, 
listening to incoming packets, 
power consumption cpu 
is milliamps 
milliamps in active 
idle state respectively 
second, is difficult to 
save energy in cases 
longterm wireless sensor 
network applications 
in order to perform tasks 
successfully, tiny os provides power 
management interfaces to allow self 
systems to put in low power idle state 
example, powering hardware 
disabling periodic tasks, 
power consumption 
dramatically reduced 
this job done via set 
commands provide tiny os 
finally, tiny os supports 
hardwaresoftware transparency 
is already discussed 
there many interesting 
features tiny os 
however, we cannot 
discuss here 
in order to cover features 
advantages tiny os in detail, 
i suggest that you go 
documentations in suggested materials 
ending this section, 
going to take a look classic 
helloworld example tiny os 
in this example, helloworld will 
printed terminal device 
to learn details to write 
a program run application in tiny os, 
you come back later to 
lectures, detailed videos 
thank you watching 
music 
