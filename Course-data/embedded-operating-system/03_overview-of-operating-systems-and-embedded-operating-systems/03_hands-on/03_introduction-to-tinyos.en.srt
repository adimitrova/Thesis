1
00:00:00,027 --> 00:00:05,392
[MUSIC]

2
00:00:05,392 --> 00:00:08,330
Hello, good to see you back for
this lesson.

3
00:00:09,390 --> 00:00:11,620
In previous videos, we explored Contiki,

4
00:00:11,620 --> 00:00:18,210
a popular IoT embedded OS,
its features, and advantages.

5
00:00:18,210 --> 00:00:22,720
Now, we're going to another
flavor of IoT embedded OS.

6
00:00:22,720 --> 00:00:28,150
Tiny OS, which can be seen as
an example of a monolithic kernel.

7
00:00:28,150 --> 00:00:31,860
First of all, I will give you
an introduction to Tiny OS,

8
00:00:31,860 --> 00:00:34,030
followed by its features and advantages.

9
00:00:35,890 --> 00:00:39,320
Tiny OS is an open source
embedded operating system.

10
00:00:40,450 --> 00:00:43,689
It is designed for network and
memory constrained systems.

11
00:00:44,810 --> 00:00:49,339
It mainly focuses on low power
wireless sensor network systems and

12
00:00:49,339 --> 00:00:51,361
Internet-of-Things devices.

13
00:00:52,690 --> 00:00:56,580
Consequently, Tiny OS
is lightweight enough

14
00:00:56,580 --> 00:01:00,320
to satisfy their requirements of
an embedded device with not so

15
00:01:00,320 --> 00:01:05,500
powerful micro-controller with a small
memory, and that operates on battery.

16
00:01:07,030 --> 00:01:10,640
Tiny OS was created at
Berkeley University in 1999,

17
00:01:10,640 --> 00:01:14,990
and later developed by many companies and
universities.

18
00:01:16,190 --> 00:01:19,779
Tiny OS and
its applications are written using nesC.

19
00:01:21,030 --> 00:01:25,490
NesC is a structure component
based extension of the C language.

20
00:01:26,620 --> 00:01:30,000
Now we will discuss the five
basic concepts of NesC.

21
00:01:31,090 --> 00:01:34,800
The first one is the separation
of construction and composition.

22
00:01:35,950 --> 00:01:39,970
This is achieved by the fact
that all programs in Tiny OS

23
00:01:39,970 --> 00:01:44,890
are built as components, and then they
are assembled to form a whole program.

24
00:01:46,180 --> 00:01:49,980
Components have internal
concurrency in the form of tasks.

25
00:01:51,120 --> 00:01:54,270
A component may be called
via its interfaces.

26
00:01:55,490 --> 00:02:00,800
Second is the specification of component
behavior using a set of interfaces.

27
00:02:02,100 --> 00:02:05,960
This means, in other words,
the provided interface is just for

28
00:02:05,960 --> 00:02:09,010
representing the functionality
of a particular component.

29
00:02:10,490 --> 00:02:13,490
The third one is regarding
bidirectional interfaces.

30
00:02:14,800 --> 00:02:18,090
This implies that interfaces
define functions,

31
00:02:18,090 --> 00:02:21,559
which can be implemented by
both commands and events.

32
00:02:22,710 --> 00:02:25,780
This provides the benefit
that a single interface

33
00:02:25,780 --> 00:02:29,290
can represent a complex
interaction between components.

34
00:02:30,730 --> 00:02:36,820
Four, is the static linking of components
with each other and via their interfaces.

35
00:02:37,960 --> 00:02:42,220
This enhances run time efficiency,
promotes robust design and

36
00:02:42,220 --> 00:02:44,880
allows for
better static analysis of program code.

37
00:02:46,220 --> 00:02:48,630
Finally, a whole program compiler.

38
00:02:49,980 --> 00:02:55,320
In NesC, code is generated by whole
program compilers instead of blocks.

39
00:02:55,320 --> 00:02:58,769
Therefore, it is better for
code generation and analysis.

40
00:03:00,390 --> 00:03:04,390
After this introduction,
I hope you have main ideas of Tiny OS.

41
00:03:05,570 --> 00:03:09,920
Now, we go into the internals of
Tiny OS features and advantages.

42
00:03:11,410 --> 00:03:15,839
Absolute size, compared to other popular
embedded wireless sensor networks,

43
00:03:17,000 --> 00:03:21,300
Tiny OS requires minimal RAM and
ROM for performing a basic task.

44
00:03:22,320 --> 00:03:26,460
It needs less than one kilobyte of RAM and
four kilobytes of ROM.

45
00:03:27,560 --> 00:03:29,370
Now, you may wonder how it can happen.

46
00:03:30,480 --> 00:03:34,255
Previously, I mentioned the whole
program compiler in NesC.

47
00:03:35,410 --> 00:03:40,149
It is used to remove dead code and
applies cross-component optimization to

48
00:03:40,149 --> 00:03:44,900
remove redundant operations and
minimize the overhead of module crosses.

49
00:03:46,610 --> 00:03:51,430
In Tiny OS, context switch
overhead corresponds to both,

50
00:03:51,430 --> 00:03:55,530
the cost of test scheduling and
interrupt handling overheads.

51
00:03:56,580 --> 00:04:01,480
The interrupt overheads consists
of both switching overhead and

52
00:04:01,480 --> 00:04:06,380
function overhead of the handler, which
varies with the number of saved registers.

53
00:04:07,780 --> 00:04:12,060
In contrast to the other traditional
multimedia applications,

54
00:04:12,060 --> 00:04:16,953
sensor network applications are different
in terms of time and criticality of work.

55
00:04:18,950 --> 00:04:24,750
Instead of chorusing a priority scheme to
allow the correct ordering of the task,

56
00:04:24,750 --> 00:04:29,809
Tiny OS uses a simple scheduler to
schedule based on a set of deadlines.

57
00:04:31,530 --> 00:04:35,024
Tiny OS with NesC compiler
support debugging and

58
00:04:35,024 --> 00:04:37,500
helps to detect race conditions.

59
00:04:38,780 --> 00:04:41,000
In order to do this, synchronous and

60
00:04:41,000 --> 00:04:44,720
asynchronous codes
are considered in Tiny OS.

61
00:04:44,720 --> 00:04:47,810
In order to give you a better
understanding of this process,

62
00:04:47,810 --> 00:04:50,810
synchronous and
asynchronous code will be explained.

63
00:04:52,650 --> 00:04:58,037
Synchronous Code or SC is a code
that is only reachable from tasks,

64
00:04:58,037 --> 00:05:00,250
while Asynchronous Code or

65
00:05:00,250 --> 00:05:05,650
AC is a code that is reachable from
at least one interrupt handler.

66
00:05:06,890 --> 00:05:12,266
The primary goal of Tiny OS is to
allow developers build responsive and

67
00:05:12,266 --> 00:05:18,900
concurrent data structures that can
safely share data between AC and SC.

68
00:05:18,900 --> 00:05:25,150
So components often have a mix of SC and
AC code.

69
00:05:25,150 --> 00:05:27,970
As a result,
there are potential causes of races.

70
00:05:29,150 --> 00:05:35,050
It is clear that non-preemption almost
eliminates races between tasks.

71
00:05:35,050 --> 00:05:39,620
However, there are some cases of
potential races between AC and

72
00:05:39,620 --> 00:05:42,400
SC or between AC and AC.

73
00:05:43,970 --> 00:05:47,210
There are two options
to avoiding such cases.

74
00:05:47,210 --> 00:05:52,540
The first one is to convert all
the conflicting code to tasks only for SC.

75
00:05:53,860 --> 00:05:58,270
The second option is to use atomic
sections to update the shared state.

76
00:06:00,510 --> 00:06:05,390
Next, I will discuss about active
messages, which can be considered

77
00:06:05,390 --> 00:06:09,060
as the main communication
abstraction model of Tiny OS.

78
00:06:10,430 --> 00:06:13,350
Active messages are small packets.

79
00:06:13,350 --> 00:06:17,400
About 36 bytes also shared
with one byte handler ID.

80
00:06:18,590 --> 00:06:22,710
Now you may wonder how
active messages work.

81
00:06:23,850 --> 00:06:24,350
Let us see.

82
00:06:25,660 --> 00:06:29,310
A node dispatches a message
using an event to one or

83
00:06:29,310 --> 00:06:33,004
more handlers that are reducer
to receive messages.

84
00:06:33,004 --> 00:06:37,880
Handler registration is carried
out using static wiring and

85
00:06:37,880 --> 00:06:39,390
a parameterized interface.

86
00:06:40,540 --> 00:06:43,560
Moreover, single hold
datagram protocol and

87
00:06:43,560 --> 00:06:46,910
unified communication
interface are provided by AM.

88
00:06:48,740 --> 00:06:52,920
Higher level protocols providing
multi-hub communication,

89
00:06:52,920 --> 00:06:55,539
are readily built on the top
of the AM interface.

90
00:06:57,530 --> 00:07:01,070
Now we continue to discuss
Tiny OS flexibility.

91
00:07:02,360 --> 00:07:05,990
To give you a comprehensive
understanding of this feature,

92
00:07:05,990 --> 00:07:11,130
I will explain characteristics which
justify the flexibility of Tiny OS.

93
00:07:12,270 --> 00:07:16,129
First, Tiny OS supports
fine-grained components.

94
00:07:17,220 --> 00:07:22,539
This implies that a complex application
is composed from a large number or

95
00:07:22,539 --> 00:07:24,700
very fine grain components.

96
00:07:24,700 --> 00:07:32,550
For example, the main code of
Tiny OS consists of 401 components.

97
00:07:32,550 --> 00:07:38,960
In addition, other 42 applications in the
source tree use about 74 components each.

98
00:07:40,310 --> 00:07:43,560
A component is built with
a small number of modules.

99
00:07:43,560 --> 00:07:47,030
And each module is from seven
to around 2,000 lines of code.

100
00:07:49,410 --> 00:07:53,290
Second, Tiny OS provides
concurrent components.

101
00:07:53,290 --> 00:07:56,810
As I mentioned early, any component
can be the source of concurrency.

102
00:07:57,980 --> 00:08:02,390
Events can be automatically generated
by any component via by directional

103
00:08:02,390 --> 00:08:03,230
interfaces.

104
00:08:04,400 --> 00:08:08,086
In addition,
concurrency bugs can be removed

105
00:08:08,086 --> 00:08:12,064
with the help of a static
raise detection of NesC.

106
00:08:12,064 --> 00:08:17,189
Third, Tiny OS supports hardware and
software transparency.

107
00:08:17,189 --> 00:08:21,809
Basically, the idea behind is to replace
software components with more efficient

108
00:08:21,809 --> 00:08:25,120
hardware implementations to
reduce energy consumption.

109
00:08:26,280 --> 00:08:32,150
For example, using a single chip which
consists of microcontroller, memory,

110
00:08:32,150 --> 00:08:38,210
radio transceiver and radio acceleration,
consumes around 100 microamps,

111
00:08:38,210 --> 00:08:42,350
while the standard server radio
stack consumes 3.6 milliamps.

112
00:08:43,750 --> 00:08:47,290
Last but not least is interposition.

113
00:08:47,290 --> 00:08:51,640
One aspect of flexibility is the ability
to insert components between

114
00:08:51,640 --> 00:08:52,510
other components.

115
00:08:53,750 --> 00:08:55,770
Whenever a component provides and

116
00:08:55,770 --> 00:09:00,610
uses the same interface type, it can
be inserted or removed transparently.

117
00:09:02,270 --> 00:09:06,810
Another feature of Tiny OS is support for
low power operation.

118
00:09:07,890 --> 00:09:12,990
To give you a comprehensive view of this
property, we discuss three concepts.

119
00:09:14,100 --> 00:09:18,950
These are CPU power usage,
power management interfaces and

120
00:09:18,950 --> 00:09:20,680
hardware software transparencies.

121
00:09:22,060 --> 00:09:26,240
First, in order to achieve
low CPU power consumption,

122
00:09:26,240 --> 00:09:31,110
Tiny OS has a sleep mode to which
it transitions when it is idle.

123
00:09:32,430 --> 00:09:38,440
Tiny OS tries to sleep as long as
possible to minimize power consumption.

124
00:09:38,440 --> 00:09:41,960
For example,
when listening to incoming packets,

125
00:09:41,960 --> 00:09:46,600
the power consumption of the CPU
is about 4.6 milliamps and

126
00:09:46,600 --> 00:09:50,930
2.4 milliamps in active and
idle state respectively.

127
00:09:52,310 --> 00:09:56,505
Second, it is difficult to
save energy in cases of

128
00:09:56,505 --> 00:10:00,720
long-term wireless sensor
network applications.

129
00:10:00,720 --> 00:10:05,900
In order to perform the tasks
successfully, Tiny OS provides power

130
00:10:05,900 --> 00:10:11,350
management interfaces to allow self
systems to be put in low power idle state.

131
00:10:12,670 --> 00:10:18,160
For example, by powering down hardware or
disabling periodic tasks,

132
00:10:18,160 --> 00:10:22,040
power consumption can be
dramatically reduced.

133
00:10:22,040 --> 00:10:25,870
This job can be done via set of
commands provide by Tiny OS.

134
00:10:27,300 --> 00:10:31,548
Finally, Tiny OS supports
Hardware/Software Transparency

135
00:10:31,548 --> 00:10:33,960
which is already discussed above.

136
00:10:35,400 --> 00:10:38,530
There are many interesting
features of Tiny OS.

137
00:10:38,530 --> 00:10:41,010
However, we cannot
discuss all of them here.

138
00:10:42,250 --> 00:10:47,220
In order to cover all these features and
advantages of Tiny OS in detail,

139
00:10:47,220 --> 00:10:50,780
I suggest that you go through
documentations in the suggested materials.

140
00:10:52,030 --> 00:10:54,550
Before ending this section,

141
00:10:54,550 --> 00:10:58,559
we're going to take a look at the classic
Helloworld example for Tiny OS.

142
00:10:59,600 --> 00:11:04,660
In this example, Helloworld will be
printed out the terminal of the device.

143
00:11:04,660 --> 00:11:09,820
To learn details on how to write
a program and run application in Tiny OS,

144
00:11:09,820 --> 00:11:14,360
you should come back later to our
lectures, which have more detailed videos.

145
00:11:14,360 --> 00:11:15,708
Thank you for watching.

146
00:11:15,708 --> 00:11:20,039
[MUSIC]