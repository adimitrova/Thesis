[
music
]
hello
,
good
to
see
you
back
for
this
lesson
.
in
previous
videos
,
we
explored
contiki
,
a
popular
iot
embedded
os
,
its
features
,
and
advantages
.
now
,
we
're
going
to
another
flavor
of
iot
embedded
os
.
tiny
os
,
which
can
be
seen
as
an
example
of
a
monolithic
kernel
.
first
of
all
,
i
will
give
you
an
introduction
to
tiny
os
,
followed
by
its
features
and
advantages
.
tiny
os
is
an
open
source
embedded
operating
system
.
it
is
designed
for
network
and
memory
constrained
systems
.
it
mainly
focuses
on
low
power
wireless
sensor
network
systems
and
internet-of-things
devices
.
consequently
,
tiny
os
is
lightweight
enough
to
satisfy
their
requirements
of
an
embedded
device
with
not
so
powerful
micro-controller
with
a
small
memory
,
and
that
operates
on
battery
.
tiny
os
was
created
at
berkeley
university
in
1999
,
and
later
developed
by
many
companies
and
universities
.
tiny
os
and
its
applications
are
written
using
nesc
.
nesc
is
a
structure
component
based
extension
of
the
c
language
.
now
we
will
discuss
the
five
basic
concepts
of
nesc
.
the
first
one
is
the
separation
of
construction
and
composition
.
this
is
achieved
by
the
fact
that
all
programs
in
tiny
os
are
built
as
components
,
and
then
they
are
assembled
to
form
a
whole
program
.
components
have
internal
concurrency
in
the
form
of
tasks
.
a
component
may
be
called
via
its
interfaces
.
second
is
the
specification
of
component
behavior
using
a
set
of
interfaces
.
this
means
,
in
other
words
,
the
provided
interface
is
just
for
representing
the
functionality
of
a
particular
component
.
the
third
one
is
regarding
bidirectional
interfaces
.
this
implies
that
interfaces
define
functions
,
which
can
be
implemented
by
both
commands
and
events
.
this
provides
the
benefit
that
a
single
interface
can
represent
a
complex
interaction
between
components
.
four
,
is
the
static
linking
of
components
with
each
other
and
via
their
interfaces
.
this
enhances
run
time
efficiency
,
promotes
robust
design
and
allows
for
better
static
analysis
of
program
code
.
finally
,
a
whole
program
compiler
.
in
nesc
,
code
is
generated
by
whole
program
compilers
instead
of
blocks
.
therefore
,
it
is
better
for
code
generation
and
analysis
.
after
this
introduction
,
i
hope
you
have
main
ideas
of
tiny
os
.
now
,
we
go
into
the
internals
of
tiny
os
features
and
advantages
.
absolute
size
,
compared
to
other
popular
embedded
wireless
sensor
networks
,
tiny
os
requires
minimal
ram
and
rom
for
performing
a
basic
task
.
it
needs
less
than
one
kilobyte
of
ram
and
four
kilobytes
of
rom
.
now
,
you
may
wonder
how
it
can
happen
.
previously
,
i
mentioned
the
whole
program
compiler
in
nesc
.
it
is
used
to
remove
dead
code
and
applies
cross-component
optimization
to
remove
redundant
operations
and
minimize
the
overhead
of
module
crosses
.
in
tiny
os
,
context
switch
overhead
corresponds
to
both
,
the
cost
of
test
scheduling
and
interrupt
handling
overheads
.
the
interrupt
overheads
consists
of
both
switching
overhead
and
function
overhead
of
the
handler
,
which
varies
with
the
number
of
saved
registers
.
in
contrast
to
the
other
traditional
multimedia
applications
,
sensor
network
applications
are
different
in
terms
of
time
and
criticality
of
work
.
instead
of
chorusing
a
priority
scheme
to
allow
the
correct
ordering
of
the
task
,
tiny
os
uses
a
simple
scheduler
to
schedule
based
on
a
set
of
deadlines
.
tiny
os
with
nesc
compiler
support
debugging
and
helps
to
detect
race
conditions
.
in
order
to
do
this
,
synchronous
and
asynchronous
codes
are
considered
in
tiny
os
.
in
order
to
give
you
a
better
understanding
of
this
process
,
synchronous
and
asynchronous
code
will
be
explained
.
synchronous
code
or
sc
is
a
code
that
is
only
reachable
from
tasks
,
while
asynchronous
code
or
ac
is
a
code
that
is
reachable
from
at
least
one
interrupt
handler
.
the
primary
goal
of
tiny
os
is
to
allow
developers
build
responsive
and
concurrent
data
structures
that
can
safely
share
data
between
ac
and
sc
.
so
components
often
have
a
mix
of
sc
and
ac
code
.
as
a
result
,
there
are
potential
causes
of
races
.
it
is
clear
that
non-preemption
almost
eliminates
races
between
tasks
.
however
,
there
are
some
cases
of
potential
races
between
ac
and
sc
or
between
ac
and
ac
.
there
are
two
options
to
avoiding
such
cases
.
the
first
one
is
to
convert
all
the
conflicting
code
to
tasks
only
for
sc
.
the
second
option
is
to
use
atomic
sections
to
update
the
shared
state
.
next
,
i
will
discuss
about
active
messages
,
which
can
be
considered
as
the
main
communication
abstraction
model
of
tiny
os
.
active
messages
are
small
packets
.
about
36
bytes
also
shared
with
one
byte
handler
id
.
now
you
may
wonder
how
active
messages
work
.
let
us
see
.
a
node
dispatches
a
message
using
an
event
to
one
or
more
handlers
that
are
reducer
to
receive
messages
.
handler
registration
is
carried
out
using
static
wiring
and
a
parameterized
interface
.
moreover
,
single
hold
datagram
protocol
and
unified
communication
interface
are
provided
by
am
.
higher
level
protocols
providing
multi-hub
communication
,
are
readily
built
on
the
top
of
the
am
interface
.
now
we
continue
to
discuss
tiny
os
flexibility
.
to
give
you
a
comprehensive
understanding
of
this
feature
,
i
will
explain
characteristics
which
justify
the
flexibility
of
tiny
os
.
first
,
tiny
os
supports
fine-grained
components
.
this
implies
that
a
complex
application
is
composed
from
a
large
number
or
very
fine
grain
components
.
for
example
,
the
main
code
of
tiny
os
consists
of
401
components
.
in
addition
,
other
42
applications
in
the
source
tree
use
about
74
components
each
.
a
component
is
built
with
a
small
number
of
modules
.
and
each
module
is
from
seven
to
around
2,000
lines
of
code
.
second
,
tiny
os
provides
concurrent
components
.
as
i
mentioned
early
,
any
component
can
be
the
source
of
concurrency
.
events
can
be
automatically
generated
by
any
component
via
by
directional
interfaces
.
in
addition
,
concurrency
bugs
can
be
removed
with
the
help
of
a
static
raise
detection
of
nesc
.
third
,
tiny
os
supports
hardware
and
software
transparency
.
basically
,
the
idea
behind
is
to
replace
software
components
with
more
efficient
hardware
implementations
to
reduce
energy
consumption
.
for
example
,
using
a
single
chip
which
consists
of
microcontroller
,
memory
,
radio
transceiver
and
radio
acceleration
,
consumes
around
100
microamps
,
while
the
standard
server
radio
stack
consumes
3.6
milliamps
.
last
but
not
least
is
interposition
.
one
aspect
of
flexibility
is
the
ability
to
insert
components
between
other
components
.
whenever
a
component
provides
and
uses
the
same
interface
type
,
it
can
be
inserted
or
removed
transparently
.
another
feature
of
tiny
os
is
support
for
low
power
operation
.
to
give
you
a
comprehensive
view
of
this
property
,
we
discuss
three
concepts
.
these
are
cpu
power
usage
,
power
management
interfaces
and
hardware
software
transparencies
.
first
,
in
order
to
achieve
low
cpu
power
consumption
,
tiny
os
has
a
sleep
mode
to
which
it
transitions
when
it
is
idle
.
tiny
os
tries
to
sleep
as
long
as
possible
to
minimize
power
consumption
.
for
example
,
when
listening
to
incoming
packets
,
the
power
consumption
of
the
cpu
is
about
4.6
milliamps
and
2.4
milliamps
in
active
and
idle
state
respectively
.
second
,
it
is
difficult
to
save
energy
in
cases
of
long-term
wireless
sensor
network
applications
.
in
order
to
perform
the
tasks
successfully
,
tiny
os
provides
power
management
interfaces
to
allow
self
systems
to
be
put
in
low
power
idle
state
.
for
example
,
by
powering
down
hardware
or
disabling
periodic
tasks
,
power
consumption
can
be
dramatically
reduced
.
this
job
can
be
done
via
set
of
commands
provide
by
tiny
os
.
finally
,
tiny
os
supports
hardware/software
transparency
which
is
already
discussed
above
.
there
are
many
interesting
features
of
tiny
os
.
however
,
we
can
not
discuss
all
of
them
here
.
in
order
to
cover
all
these
features
and
advantages
of
tiny
os
in
detail
,
i
suggest
that
you
go
through
documentations
in
the
suggested
materials
.
before
ending
this
section
,
we
're
going
to
take
a
look
at
the
classic
helloworld
example
for
tiny
os
.
in
this
example
,
helloworld
will
be
printed
out
the
terminal
of
the
device
.
to
learn
details
on
how
to
write
a
program
and
run
application
in
tiny
os
,
you
should
come
back
later
to
our
lectures
,
which
have
more
detailed
videos
.
thank
you
for
watching
.
[
music
]
