[SOUND] Hello and welcome back to the course. In this video, we're going to talk about
how to get data into the processing element as well as how to transfer
the data from the processing element. A processing element is a digital device,
which makes computations. The computations
are performed on some data, which is stored in memory
within the processing element. However, initially the memory is empty,
so where to get the data from? I would like to introduce here
two concepts, input and output. As you may guess, the input comprises
the whole set of devices or units through which the data can be
delivered to make computations on. On the other hand an output is a device or
unit that help to transfer processed data from a processing
element to other devices. Input/output devices share
some characteristics. However, let's talk
about the inputs first. Input devices are meant for
delivering data to the processing element. In some cases, the microcontrollers have
different peripheral units that play the role of inputs, for example,
communication units such as UART or SPI. An analog to digital converter can
also be considered as an input device. These peripheral units might be located
inside of the microcontroller and exposed to the user through external pins. By the way,
general purpose input/output pins, as you might guess from their name,
can also be used as an input, regardless of any peripheral
unit being attached to them. There are many ways to classify
a microcontroller's inputs. However, among all of them,
I would like to mention the one which separates inputs into two categories,
serial and parallel. As an example you can think of serial
peripheral interface and GPIOs. Inputs can also be classified according
to the type of signal they handle. This way an input may be digital,
for example SPI interface, or analog, such as an analog
to digital converter. The next question I would like to cover is how to actually read
the data from those inputs. The details of how to do
that may be quite different depending on the input
unit you want to use. Let's consider an SPI interface and an ADC, which are clearly very
different kinds of units. The first one is meant to communication, whereas the second one converts
analog signals into a digital form. Because of their fundamental differences,
we can expect their operation details to differ very much as well as
the methods for reading data from them. However, from a higher abstraction level,
we can distinguish two ways for doing this. The first one is to read
the input every once in a while, let's say once every 100
milliseconds interval. In this case, the read operation
is initiated by the software. Therefore, we need write a piece
of code that gets the data from the input unit at
the chosen interval. In our case, the interval is 100
milliseconds, but it can be adjusted. Now, let's think about the following case. What if we are interested in knowing
the time when an event happens? For example, we need to know when
the voltage level on some pin rises from logic zero to logic one. What time interval do we choose
in order to catch such event? You can make an assumption
that the shorter the interval, the more frequently we check the input,
and therefore the less the probability
that we will miss the event. This is of course true. However, if we think of the amount of
time the processing element will spend on checking if the event has occurred,
we will conclude that such approach is not efficient since a lot of
computational power will be wasted. Luckily, there is another
way of catching fast events. If the first method was
software initiated, the second way is hardware initiated. It is based on interrupts. When an event occurs,
it causes an interrupt, which in turn breaks the flow of
the main program and reads the input. The second method is more reliable
in the sense that it is less likely to miss the event. To make sense of the received data, the communications unit used as input
must be compatible with the sender. This compatibility should
be at the protocol level. This means that signals
used follow the same rules. For example,
if SPI communication protocol is used, the sender and the receiver should
work according to this protocol. It is also important to
consider voltage compatibility. The signals should be preferably
used the same voltage, let's say either 3.3 volts or 5 volts. With outputs,
the picture is pretty much the same. Peripheral units can be used as output. The interaction with the outer
world is done via external pins. The classification is also similar,
serial, parallel, analog, digital. An example of an analog output is
a digital to analog converter, which converts a number
to a voltage signal. Communication units, such as UART or
SPI, are examples of digital outputs. Sending and receiving data can be
software or hardware-initiated. Let's make an example of
hardware-initiated transfer. For example, we need to build an analog
signal using a microcontroller. In this case, we will need
a digital-to-analog converter. The shape of the required signal
should be, for example, sinusoidal. For that we will keep samples,
which are just numbers, of one of the periods of
the sinusoidal in memory. What we need to do is to read those
samples at the right intervals to send them to the DAC. The right intervals of time
are measured using a timer. Now, if we want to keep
the shape of a signal stable, we need to rely on hardware. It can be done in the following way. A timer marks the right moment and
instructs the Direct Memory Access unit to transfer one sample from
the memory to the DAC. After the DAC converts
the sample to voltage, everything is set to be done
without the influence of software. As for inputs, output units should
be compatible with the receiver regarding their protocol and
voltage level used. So in this video we discussed the ways
on how an embedded system can exchange the data with outer world, and what are the requirements that should be
expected to make such exchange correct. [SOUND]