[MUSIC] Hello and welcome back to the course. In this video we will elaborate
on sensors and actuators. You will get an insight
on where they are used. We also will discuss what obstacles
you might encounter on the way while working with them. And in the end, I will talk about
two ways on how to read input data, namely polling and interrupts. Embedded systems deal with
the real physical world. Physical quantities of the real world
can either be used as input for the embedded system or
they can be altered by such systems. Sensors are meant for
measuring physical quantities. In a sense, sensors help to convert
a physical quantity, such as, for example, temperature, pressure, or
acceleration into a number. So sensors map a physical
value to a number. There are examples of sensors. A temperature sensor converts
temperature to voltage. An accelermator converts acceleration
to voltage and many others. Sensors can have a processing
element on board. So they can have a digital output. Actuators are used to alter
the physical quantity. In contrast to sensors,
which are driven by the physical quantity, actuators are driven by a processing
element or in other words, by a number. Electric motors are a good
example of actuators. A sensor's work range is limited. For example, a temperature sensor can
operate in the range from -20 degrees Celsius to 50 degrees Celsius. Obviously, this should be taken into
consideration, when using such sensors. If the sensor is used out of its range,
then saturation might occur. It means that the mentioned temperature
sensor will show the temperature 50 degrees, when the real temperature is,
let's say 60 degrees. To be used by processing elements, the
measure of quantity should be quantized. What does this mean? During the process of quantization,
the quantity is being mapped to a number. It happens with some error because
the number of values is limited. For example, there are only 8
bits to be used for quantization. So in total we have 256 numbers. This means that our initial quantity will
be mapped to one of those 256 numbers. The quantity will be mapped
to the closest number. Thus quantization is done with some error, which is the difference between the real
value and its quantized representation. For some applications, it may be
not enough to have just 256 values to represent the whole range
of changes of some quantity. In this case, the number of bits or in other words the resolution should
be increased to 9, 10 bits or more. Sometimes the only way to increase
the resolution is to change the hardware. At this pont, you can think of the cases where the
quantization error will be the largest. Another issue that needs to be considered
when dealing with sensors is noise. Measurements always
have a noise component. We can say that a measurement is the sum
of the real value and the noise. If you think of an accelerometer, then the noise can be caused
by some random vibration. The influence of noise can be
reduced when processing the results. Filtering is one of the examples
of how the noise can be reduced. We talked about quantization, however the quantization process
is done at some moments of time. The quantization in time
is called sampling. Sampling is done with some period T. It may be obvious that the smaller the T,
the higher the sampling frequency and therefore the more data
we will have per second. However, it is not always necessary
to increase the sampling frequency. We will not go deep into the details, although I would like to mention that it
was proven by Nyquist that the sampling frequency should be at least twice the
highest frequency contained in the signal. If the signal is sampled
at a lower frequency, we may get wrong information
about the signal. However this is only relevant if
the shape of the signal matters to us. In many other cases, especially
when the signal changes slowly, for example temperature under normal
conditions does not change fast. Might not been necessary to
use a high sampling frequency. A processing element can read data
from a sensor once in a while. Let's say we use a timer
of the micro controller which marks off 100 millisecond intervals. Thus we can obtain data
every 100 milliseconds. This approach is good enough for
a slow processes, however when there is need to catch a fast event and
we don't know when exactly it will occur. This method is not a good choice. We can adjust the interval
between two successive reads, for example, we can make it smaller. In this case, the probability
of missing the event decreases. This approach is called polling. So when polling, the processing element checks if the event
has occurred within some time interval. The interval can be adjusted. So what are the downsides
of this approach? The main drawback is that the approach
doesn't allow to catch fast random events. Another disadvantage is that a processing
element spends its time polling. And the smaller the interval,
the more time is spent. Here, this means that
computation power is wasted. So is there a way to
catch fast random events? Let's consider that we have
a microcontroller as a tool for that. With the power of interrupts,
it is possible to catch fast events, and what is more, to estimate at
the time when the event occurred. An interrupt is a hardware based way
to break the main flow of the program, which means this method is fast in the sense that the hardware
reacts quickly to the event. Furthermore, it gives control to
software to process the event. So what are the off sites of interrupts? First, when we use interrupts,
the processing element does not spend computation power to actually
check if the event occurred. An interrupt happens almost at the same
time when the physical event occurs. Micro-controllers have one or
several external interrupt pins, which gives a developer the possibility
to process the incoming event. A raise or fall of voltage on
the corresponding pin can be an event. An interrupt might also happen when for
example, the ADC conversion has finished, or when some data has come to
the receive buffer of the UART register, which is very convenient. What is left for the developer is just to
take their result of the ADC conversion, or their received UART data, and use it. An interrupt service routine can
be used to process an interrupt. It can be written by a developer. It is good practice to make
interrupt service routines fast. Because they break tha main program flow,
and might block other interrupts, or the execution of other tasks. In the video we talk about sensors and
actuators as the ways the processing element
communicate with the physical world. We also discussed the ways on how
the input data can be obtained. So thanks for watching. I hope this module has been
interesting for you and I look forward seeing
you in the next module. [MUSIC]