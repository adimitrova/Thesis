1
00:00:00,025 --> 00:00:06,155
[MUSIC]

2
00:00:06,155 --> 00:00:08,040
Hello and welcome back.

3
00:00:08,040 --> 00:00:13,000
By now hopefully, you have a general
picture of what an embedded system is.

4
00:00:13,000 --> 00:00:16,170
However, in order to give
you a better insight,

5
00:00:16,170 --> 00:00:20,900
in this video we're going to talk about
the characteristics of an embedded system.

6
00:00:20,900 --> 00:00:25,850
We will also discuss the challenges you
may face when developing embedded systems

7
00:00:25,850 --> 00:00:29,390
as well as possible design flows
to tackle those challenges.

8
00:00:30,730 --> 00:00:34,460
Any embedded system is built for
a certain application,

9
00:00:34,460 --> 00:00:39,420
thus the system should fulfill
the requirements of the application.

10
00:00:39,420 --> 00:00:43,250
These requirements dictate the
characteristics of the embedded system.

11
00:00:44,310 --> 00:00:45,100
In general,

12
00:00:45,100 --> 00:00:49,590
we can distinguish several of them that
can be applied to any embedded system.

13
00:00:50,710 --> 00:00:53,170
In the video,
we will highlight some of them.

14
00:00:54,230 --> 00:00:59,810
We will talk about dependability,
efficiency, and real-time constraints.

15
00:00:59,810 --> 00:01:04,520
These characteristics are crucial since
they influence the way the system works.

16
00:01:06,390 --> 00:01:13,160
A lot of embedded systems are safety
critical and so they must be dependable.

17
00:01:13,160 --> 00:01:17,216
A good example of a system which
everyone would agree should be

18
00:01:17,216 --> 00:01:19,720
dependable is nuclear power plants.

19
00:01:19,720 --> 00:01:25,470
They are of course many other
examples such as airplanes or cars.

20
00:01:25,470 --> 00:01:27,310
Why should these systems be dependable?

21
00:01:28,320 --> 00:01:32,240
The main reason is they are directly
connected to the environment and

22
00:01:32,240 --> 00:01:35,430
if something goes wrong they will
have an immediate impact on it.

23
00:01:36,850 --> 00:01:41,150
Dependability can be split into
several sub-characteristics.

24
00:01:41,150 --> 00:01:46,400
The system is considered dependable if
all those characteristics are fulfilled.

25
00:01:47,690 --> 00:01:50,860
An important issue is that
initially the developers

26
00:01:50,860 --> 00:01:54,510
should not focus only on
the functionality of the system

27
00:01:54,510 --> 00:01:59,320
assuming that the dependability
can be brought in on later stages.

28
00:01:59,320 --> 00:02:02,180
In fact, this approach does not work,

29
00:02:02,180 --> 00:02:06,940
because design decisions might not allow
achieving dependability afterwards.

30
00:02:06,940 --> 00:02:11,502
For example, if the wrong components
are chosen for an application,

31
00:02:11,502 --> 00:02:15,988
let's say there is not enough
computational performance to execute

32
00:02:15,988 --> 00:02:21,343
critical tasks on time, It will be very
difficult to deal with it in later stages.

33
00:02:21,343 --> 00:02:24,779
So dependability should be considered
during the initial stages of

34
00:02:24,779 --> 00:02:25,810
the system design.

35
00:02:27,860 --> 00:02:29,400
Efficiency is another issue.

36
00:02:30,490 --> 00:02:33,690
The importance of this
characteristic comes from the fact

37
00:02:33,690 --> 00:02:37,260
that the amount of resources
is always limited.

38
00:02:37,260 --> 00:02:40,590
Resources can be represented
in the form of energy or

39
00:02:40,590 --> 00:02:45,050
memory space if it's an embedded system or
as money if it's a customer.

40
00:02:46,290 --> 00:02:51,020
Nowadays, small resource constrained
devices such as wearables or

41
00:02:51,020 --> 00:02:54,830
Internet of Things nodes
are becoming more and more popular.

42
00:02:56,180 --> 00:02:59,950
These devices do not have
constant power supply.

43
00:02:59,950 --> 00:03:04,770
However, they should last longer to
provide costumers with proper services.

44
00:03:05,930 --> 00:03:09,950
Therefore, energy efficiency is
much relevant to embedded systems.

45
00:03:11,070 --> 00:03:13,130
How can these characteristics
be estimated?

46
00:03:14,810 --> 00:03:19,880
In general, Energy Efficiency can be
estimated based on the amount of work done

47
00:03:19,880 --> 00:03:23,600
by the system considering
the amount of spent energy.

48
00:03:24,620 --> 00:03:28,469
For example, for
processors energy efficiency can be

49
00:03:28,469 --> 00:03:32,575
estimated based on the number
of instructions per joule.

50
00:03:32,575 --> 00:03:37,459
It is probably obvious that the number
of operations per joule is increasing as

51
00:03:37,459 --> 00:03:39,870
technology advances.

52
00:03:39,870 --> 00:03:43,300
If we make a quick comparison
of the current technologies,

53
00:03:43,300 --> 00:03:46,430
we can conclude that the more
application specific

54
00:03:46,430 --> 00:03:51,010
the components are that the more
efficient the application is.

55
00:03:51,010 --> 00:03:56,490
According to that, processors offer
the least energy efficient solutions.

56
00:03:56,490 --> 00:04:00,438
Whereas, application specific
integrated-circuits are the most

57
00:04:00,438 --> 00:04:01,464
efficient ones.

58
00:04:01,464 --> 00:04:07,440
In an embedded system, hardware and
software play equally important roles.

59
00:04:08,690 --> 00:04:12,890
If the running software does not
exclude the underlying hardware

60
00:04:12,890 --> 00:04:16,930
at its full potential Then
run-time efficiency will be poor.

61
00:04:18,225 --> 00:04:22,750
Inefficiencies cost by poor mapping
of the application to platforms

62
00:04:22,750 --> 00:04:24,410
should be avoided.

63
00:04:24,410 --> 00:04:29,162
For instance, compilers should
not bring in overhead which

64
00:04:29,162 --> 00:04:32,710
will eventually leave
two of wasted energy.

65
00:04:32,710 --> 00:04:38,630
Code size is another issue that needs to
be addressed when it comes to efficiency.

66
00:04:38,630 --> 00:04:44,080
Devices capable of loading additional
code dynamically are still rare.

67
00:04:44,080 --> 00:04:48,740
Usually an embedded systems code
is stored within the device.

68
00:04:48,740 --> 00:04:52,030
Therefore, it should occupy
as less space as possible.

69
00:04:53,160 --> 00:04:56,520
The physical appearance of
the system is not less important.

70
00:04:57,560 --> 00:05:02,170
Portable devices should be lightweight so
to be more attractive to customers.

71
00:05:03,180 --> 00:05:08,889
The last but not the last parameter that
influences the overall efficiency is cost.

72
00:05:09,970 --> 00:05:14,040
The system should be built using
as little components as possible

73
00:05:14,040 --> 00:05:16,270
to implement the required functionality.

74
00:05:18,580 --> 00:05:22,430
Embedded systems should
meet real-time constraints.

75
00:05:22,430 --> 00:05:24,812
If computations are not finished in time,

76
00:05:24,812 --> 00:05:27,333
the quality of the solution
might decrease.

77
00:05:27,333 --> 00:05:32,531
Sometimes, violating real-time
constraints may actually lead to more

78
00:05:32,531 --> 00:05:38,450
serious consequences, which will
make the system less dependable.

79
00:05:38,450 --> 00:05:42,970
Of course, not all embedded systems
share the mentioned characteristics, but

80
00:05:42,970 --> 00:05:44,280
the majority still do.

81
00:05:45,710 --> 00:05:50,551
However, since embedded systems lie in
the intersection of different fields of

82
00:05:50,551 --> 00:05:51,130
a study.

83
00:05:51,130 --> 00:05:55,552
There is some haziness in the definition
of what these systems are,

84
00:05:55,552 --> 00:05:59,130
and therefore,
the set of characteristics may vary.

85
00:06:01,060 --> 00:06:05,370
Considering the above listed
characteristics of embedded systems,

86
00:06:05,370 --> 00:06:08,479
we can think of challenges
that developers might face.

87
00:06:09,890 --> 00:06:14,725
The dependability level of embedded
systems goes beyond the level for

88
00:06:14,725 --> 00:06:16,190
PC-like systems.

89
00:06:17,260 --> 00:06:21,854
A real life example of the effects
an undependable system can have is what

90
00:06:21,854 --> 00:06:25,180
happened in Southern California
back in 2004.

91
00:06:25,180 --> 00:06:29,951
When due to technical problems,
the air traffic control center

92
00:06:29,951 --> 00:06:34,560
could not operate and
many airliners were held to the ground.

93
00:06:35,670 --> 00:06:39,810
This s the kind of situations that
obviously everybody would like to avoid.

94
00:06:41,160 --> 00:06:42,900
To make a system efficient,

95
00:06:42,900 --> 00:06:47,800
software can not be developed
independently of the underlying hardware.

96
00:06:47,800 --> 00:06:51,960
This means that during the initial
design steps, both software and

97
00:06:51,960 --> 00:06:54,160
hardware should be taken into account.

98
00:06:55,330 --> 00:06:58,520
This actually requires
collaboration between the fields of

99
00:06:58,520 --> 00:07:00,680
electrical engineering and
computer science.

100
00:07:01,980 --> 00:07:07,310
The best energy efficiency can be achieved
by building application specific hardware.

101
00:07:08,340 --> 00:07:12,340
However, there are downsides
to hardware implementation,

102
00:07:12,340 --> 00:07:15,170
it doesn't provide high flexibility.

103
00:07:15,170 --> 00:07:19,390
It is also expensive and
requires long design times.

104
00:07:19,390 --> 00:07:23,710
Embedded systems development is about
finding the right balance between

105
00:07:23,710 --> 00:07:25,460
efficiency and flexibility.

106
00:07:26,540 --> 00:07:29,610
Embedded systems interact
with the physical world.

107
00:07:29,610 --> 00:07:32,310
This fact has additional implications.

108
00:07:32,310 --> 00:07:37,880
For instance, developers must check
if real-time constraints are met.

109
00:07:37,880 --> 00:07:41,270
It should be also considered,
that real systems are concurrent.

110
00:07:42,370 --> 00:07:45,840
Managing concurrency is
another important challenge.

111
00:07:45,840 --> 00:07:50,455
Embedded systems may consist of many
components, such as processing elements,

112
00:07:50,455 --> 00:07:54,340
input-output devices, and
communications units.

113
00:07:54,340 --> 00:07:58,630
This means that the impact of combining
these components should be studied and

114
00:07:58,630 --> 00:08:00,000
considered.

115
00:08:00,000 --> 00:08:00,790
For instance,

116
00:08:00,790 --> 00:08:05,680
it is desirable to know how one component
might influence the other components.

117
00:08:07,960 --> 00:08:10,860
In order to make
the design process easier,

118
00:08:10,860 --> 00:08:14,180
it should be broken into
several soft tests.

119
00:08:14,180 --> 00:08:17,640
These self tests should be
performed sequentially and

120
00:08:17,640 --> 00:08:19,160
some of them can be repeated.

121
00:08:20,290 --> 00:08:26,320
Also, it is important that all solutions
and methods are reused whenever possible.

122
00:08:26,320 --> 00:08:30,990
Designing starts from an idea which should
be converted into a design specification.

123
00:08:32,250 --> 00:08:34,690
Special repository should be created

124
00:08:34,690 --> 00:08:37,600
where the relevant designing
formation will be stored.

125
00:08:38,610 --> 00:08:42,080
The repository will lead the developer's
to keep tract of the design.

126
00:08:43,190 --> 00:08:48,240
It is also good if the repository provides
version control to make it possible

127
00:08:48,240 --> 00:08:53,560
to roll back to previous version
of the design at each iteration,

128
00:08:53,560 --> 00:08:56,040
the repository should be updated.

129
00:08:56,040 --> 00:09:00,740
During the design process, applications
are mapped to the platform iteratively.

130
00:09:01,870 --> 00:09:05,300
In each iteration,
new design information is generated.

131
00:09:06,710 --> 00:09:11,780
The information comprises the mapping
of operations to hardware or software.

132
00:09:11,780 --> 00:09:16,330
Computation and
scaling in each step the design should be

133
00:09:16,330 --> 00:09:21,330
evaluated considering perimeters
such as dependability, performance,

134
00:09:21,330 --> 00:09:23,210
energy consumption and others.

135
00:09:24,600 --> 00:09:29,350
During the intermediate steps there is no
warranty that the design will be correct

136
00:09:29,350 --> 00:09:32,990
that's why the design should
be validated in each step.

137
00:09:32,990 --> 00:09:34,660
As it was mentioned before,

138
00:09:34,660 --> 00:09:38,470
the system should be efficient,
that's why optimization is important.

139
00:09:39,900 --> 00:09:44,780
To ease the design process, you might be
interested in different design models.

140
00:09:44,780 --> 00:09:49,460
These models clearly show the different
steps that must be performed.

141
00:09:49,460 --> 00:09:53,650
For example, the waterfall model
is a sequential design process

142
00:09:53,650 --> 00:09:57,920
where development proceeds
from the top to the bottom

143
00:09:57,920 --> 00:10:01,540
from obtaining the requirements
to the maintenance.

144
00:10:01,540 --> 00:10:05,550
In order to use this model, the design
process should be thought through

145
00:10:05,550 --> 00:10:09,320
very well because after the fact
changes are very costly.

146
00:10:10,560 --> 00:10:15,090
The iterative model doesn't have
dimension drawback since before

147
00:10:15,090 --> 00:10:20,030
deployment the design goes
through testing, evolution,

148
00:10:20,030 --> 00:10:23,799
implementation every as many times
as needed to meet the requirements.

149
00:10:24,880 --> 00:10:27,440
Well, this is all for this video.

150
00:10:27,440 --> 00:10:31,900
We discussed the main characteristics and
challenges of embedded systems.

151
00:10:31,900 --> 00:10:35,053
In the next videos,
we will go into interesting details and

152
00:10:35,053 --> 00:10:37,523
we will discuss more
about embedded systems.

153
00:10:37,523 --> 00:10:42,124
[MUSIC]