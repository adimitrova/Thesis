1
00:00:00,000 --> 00:00:06,166
[MUSIC]

2
00:00:06,166 --> 00:00:09,020
Hello and welcome back to the course.

3
00:00:09,020 --> 00:00:13,220
In this video we will elaborate
on sensors and actuators.

4
00:00:13,220 --> 00:00:16,490
You will get an insight
on where they are used.

5
00:00:16,490 --> 00:00:20,910
We also will discuss what obstacles
you might encounter on the way

6
00:00:20,910 --> 00:00:22,630
while working with them.

7
00:00:22,630 --> 00:00:27,136
And in the end, I will talk about
two ways on how to read input data,

8
00:00:27,136 --> 00:00:29,405
namely polling and interrupts.

9
00:00:31,933 --> 00:00:35,720
Embedded systems deal with
the real physical world.

10
00:00:35,720 --> 00:00:39,910
Physical quantities of the real world
can either be used as input for

11
00:00:39,910 --> 00:00:43,480
the embedded system or
they can be altered by such systems.

12
00:00:44,650 --> 00:00:48,230
Sensors are meant for
measuring physical quantities.

13
00:00:48,230 --> 00:00:53,150
In a sense, sensors help to convert
a physical quantity, such as, for example,

14
00:00:53,150 --> 00:00:57,380
temperature, pressure, or
acceleration into a number.

15
00:00:57,380 --> 00:01:01,450
So sensors map a physical
value to a number.

16
00:01:01,450 --> 00:01:03,290
There are examples of sensors.

17
00:01:03,290 --> 00:01:07,060
A temperature sensor converts
temperature to voltage.

18
00:01:07,060 --> 00:01:11,560
An accelermator converts acceleration
to voltage and many others.

19
00:01:12,870 --> 00:01:16,080
Sensors can have a processing
element on board.

20
00:01:16,080 --> 00:01:17,950
So they can have a digital output.

21
00:01:20,180 --> 00:01:24,390
Actuators are used to alter
the physical quantity.

22
00:01:24,390 --> 00:01:29,090
In contrast to sensors,
which are driven by the physical quantity,

23
00:01:29,090 --> 00:01:33,710
actuators are driven by a processing
element or in other words, by a number.

24
00:01:34,900 --> 00:01:39,336
Electric motors are a good
example of actuators.

25
00:01:39,336 --> 00:01:42,930
A sensor's work range is limited.

26
00:01:42,930 --> 00:01:47,680
For example, a temperature sensor can
operate in the range from -20 degrees

27
00:01:47,680 --> 00:01:50,840
Celsius to 50 degrees Celsius.

28
00:01:51,850 --> 00:01:57,290
Obviously, this should be taken into
consideration, when using such sensors.

29
00:01:57,290 --> 00:02:01,860
If the sensor is used out of its range,
then saturation might occur.

30
00:02:02,910 --> 00:02:07,500
It means that the mentioned temperature
sensor will show the temperature 50

31
00:02:07,500 --> 00:02:11,080
degrees, when the real temperature is,
let's say 60 degrees.

32
00:02:12,180 --> 00:02:16,900
To be used by processing elements, the
measure of quantity should be quantized.

33
00:02:17,900 --> 00:02:18,690
What does this mean?

34
00:02:19,690 --> 00:02:25,540
During the process of quantization,
the quantity is being mapped to a number.

35
00:02:25,540 --> 00:02:30,200
It happens with some error because
the number of values is limited.

36
00:02:31,300 --> 00:02:36,230
For example, there are only 8
bits to be used for quantization.

37
00:02:36,230 --> 00:02:39,250
So in total we have 256 numbers.

38
00:02:40,590 --> 00:02:47,120
This means that our initial quantity will
be mapped to one of those 256 numbers.

39
00:02:48,340 --> 00:02:52,225
The quantity will be mapped
to the closest number.

40
00:02:52,225 --> 00:02:55,510
Thus quantization is done with some error,

41
00:02:55,510 --> 00:03:00,110
which is the difference between the real
value and its quantized representation.

42
00:03:01,380 --> 00:03:06,450
For some applications, it may be
not enough to have just 256 values

43
00:03:06,450 --> 00:03:10,820
to represent the whole range
of changes of some quantity.

44
00:03:11,920 --> 00:03:15,140
In this case, the number of bits or

45
00:03:15,140 --> 00:03:20,790
in other words the resolution should
be increased to 9, 10 bits or more.

46
00:03:21,890 --> 00:03:25,920
Sometimes the only way to increase
the resolution is to change the hardware.

47
00:03:27,110 --> 00:03:28,160
At this pont,

48
00:03:28,160 --> 00:03:32,950
you can think of the cases where the
quantization error will be the largest.

49
00:03:35,470 --> 00:03:40,060
Another issue that needs to be considered
when dealing with sensors is noise.

50
00:03:41,100 --> 00:03:44,620
Measurements always
have a noise component.

51
00:03:44,620 --> 00:03:49,310
We can say that a measurement is the sum
of the real value and the noise.

52
00:03:50,450 --> 00:03:53,020
If you think of an accelerometer,

53
00:03:53,020 --> 00:03:55,929
then the noise can be caused
by some random vibration.

54
00:03:57,050 --> 00:04:02,700
The influence of noise can be
reduced when processing the results.

55
00:04:02,700 --> 00:04:07,267
Filtering is one of the examples
of how the noise can be reduced.

56
00:04:09,859 --> 00:04:12,442
We talked about quantization,

57
00:04:12,442 --> 00:04:17,822
however the quantization process
is done at some moments of time.

58
00:04:17,822 --> 00:04:22,730
The quantization in time
is called sampling.

59
00:04:22,730 --> 00:04:25,420
Sampling is done with some period T.

60
00:04:26,470 --> 00:04:31,870
It may be obvious that the smaller the T,
the higher the sampling frequency and

61
00:04:31,870 --> 00:04:35,180
therefore the more data
we will have per second.

62
00:04:36,370 --> 00:04:41,340
However, it is not always necessary
to increase the sampling frequency.

63
00:04:41,340 --> 00:04:43,570
We will not go deep into the details,

64
00:04:43,570 --> 00:04:48,370
although I would like to mention that it
was proven by Nyquist that the sampling

65
00:04:48,370 --> 00:04:54,010
frequency should be at least twice the
highest frequency contained in the signal.

66
00:04:55,240 --> 00:04:58,770
If the signal is sampled
at a lower frequency,

67
00:04:58,770 --> 00:05:01,480
we may get wrong information
about the signal.

68
00:05:02,600 --> 00:05:08,140
However this is only relevant if
the shape of the signal matters to us.

69
00:05:08,140 --> 00:05:12,330
In many other cases, especially
when the signal changes slowly, for

70
00:05:12,330 --> 00:05:17,361
example temperature under normal
conditions does not change fast.

71
00:05:17,361 --> 00:05:21,410
Might not been necessary to
use a high sampling frequency.

72
00:05:23,760 --> 00:05:28,760
A processing element can read data
from a sensor once in a while.

73
00:05:28,760 --> 00:05:31,890
Let's say we use a timer
of the micro controller

74
00:05:31,890 --> 00:05:35,660
which marks off 100 millisecond intervals.

75
00:05:35,660 --> 00:05:39,310
Thus we can obtain data
every 100 milliseconds.

76
00:05:40,600 --> 00:05:45,430
This approach is good enough for
a slow processes, however when there is

77
00:05:45,430 --> 00:05:51,290
need to catch a fast event and
we don't know when exactly it will occur.

78
00:05:51,290 --> 00:05:52,979
This method is not a good choice.

79
00:05:54,220 --> 00:05:58,050
We can adjust the interval
between two successive reads, for

80
00:05:58,050 --> 00:06:00,620
example, we can make it smaller.

81
00:06:00,620 --> 00:06:04,090
In this case, the probability
of missing the event decreases.

82
00:06:05,140 --> 00:06:08,130
This approach is called polling.

83
00:06:08,130 --> 00:06:09,470
So when polling,

84
00:06:09,470 --> 00:06:14,870
the processing element checks if the event
has occurred within some time interval.

85
00:06:16,190 --> 00:06:19,040
The interval can be adjusted.

86
00:06:19,040 --> 00:06:22,240
So what are the downsides
of this approach?

87
00:06:22,240 --> 00:06:28,830
The main drawback is that the approach
doesn't allow to catch fast random events.

88
00:06:28,830 --> 00:06:34,180
Another disadvantage is that a processing
element spends its time polling.

89
00:06:34,180 --> 00:06:38,270
And the smaller the interval,
the more time is spent.

90
00:06:38,270 --> 00:06:41,680
Here, this means that
computation power is wasted.

91
00:06:43,450 --> 00:06:47,880
So is there a way to
catch fast random events?

92
00:06:47,880 --> 00:06:51,550
Let's consider that we have
a microcontroller as a tool for that.

93
00:06:53,340 --> 00:06:58,160
With the power of interrupts,
it is possible to catch fast events, and

94
00:06:58,160 --> 00:07:02,029
what is more, to estimate at
the time when the event occurred.

95
00:07:03,315 --> 00:07:09,320
An interrupt is a hardware based way
to break the main flow of the program,

96
00:07:09,320 --> 00:07:12,320
which means this method is fast

97
00:07:12,320 --> 00:07:16,160
in the sense that the hardware
reacts quickly to the event.

98
00:07:17,270 --> 00:07:21,850
Furthermore, it gives control to
software to process the event.

99
00:07:23,100 --> 00:07:26,050
So what are the off sites of interrupts?

100
00:07:26,050 --> 00:07:30,480
First, when we use interrupts,
the processing element does not

101
00:07:30,480 --> 00:07:35,357
spend computation power to actually
check if the event occurred.

102
00:07:36,720 --> 00:07:42,325
An interrupt happens almost at the same
time when the physical event occurs.

103
00:07:42,325 --> 00:07:49,180
Micro-controllers have one or
several external interrupt pins,

104
00:07:49,180 --> 00:07:53,110
which gives a developer the possibility
to process the incoming event.

105
00:07:54,390 --> 00:07:59,620
A raise or fall of voltage on
the corresponding pin can be an event.

106
00:08:00,770 --> 00:08:06,050
An interrupt might also happen when for
example, the ADC conversion has finished,

107
00:08:06,050 --> 00:08:10,880
or when some data has come to
the receive buffer of the UART register,

108
00:08:10,880 --> 00:08:12,760
which is very convenient.

109
00:08:12,760 --> 00:08:18,370
What is left for the developer is just to
take their result of the ADC conversion,

110
00:08:18,370 --> 00:08:21,210
or their received UART data, and use it.

111
00:08:22,550 --> 00:08:26,900
An interrupt service routine can
be used to process an interrupt.

112
00:08:26,900 --> 00:08:28,590
It can be written by a developer.

113
00:08:29,730 --> 00:08:33,530
It is good practice to make
interrupt service routines fast.

114
00:08:33,530 --> 00:08:38,330
Because they break tha main program flow,
and might block other interrupts, or

115
00:08:38,330 --> 00:08:40,449
the execution of other tasks.

116
00:08:42,050 --> 00:08:45,440
In the video we talk about sensors and
actuators

117
00:08:45,440 --> 00:08:49,910
as the ways the processing element
communicate with the physical world.

118
00:08:49,910 --> 00:08:54,110
We also discussed the ways on how
the input data can be obtained.

119
00:08:55,250 --> 00:08:57,010
So thanks for watching.

120
00:08:57,010 --> 00:09:00,205
I hope this module has been
interesting for you and

121
00:09:00,205 --> 00:09:03,105
I look forward seeing
you in the next module.

122
00:09:03,105 --> 00:09:07,084
[MUSIC]