1
00:00:00,090 --> 00:00:02,833
[SOUND] Hello and

2
00:00:02,833 --> 00:00:07,899
welcome back to the course.

3
00:00:07,899 --> 00:00:12,348
In this video, we're going to talk about
how to get data into the processing

4
00:00:12,348 --> 00:00:16,600
element as well as how to transfer
the data from the processing element.

5
00:00:18,460 --> 00:00:23,020
A processing element is a digital device,
which makes computations.

6
00:00:23,020 --> 00:00:26,190
The computations
are performed on some data,

7
00:00:26,190 --> 00:00:29,200
which is stored in memory
within the processing element.

8
00:00:30,250 --> 00:00:34,610
However, initially the memory is empty,
so where to get the data from?

9
00:00:35,770 --> 00:00:40,240
I would like to introduce here
two concepts, input and output.

10
00:00:40,240 --> 00:00:44,780
As you may guess, the input comprises
the whole set of devices or

11
00:00:44,780 --> 00:00:49,130
units through which the data can be
delivered to make computations on.

12
00:00:50,230 --> 00:00:55,329
On the other hand an output is a device or
unit that help to transfer

13
00:00:55,329 --> 00:01:00,071
processed data from a processing
element to other devices.

14
00:01:00,071 --> 00:01:04,050
Input/output devices share
some characteristics.

15
00:01:04,050 --> 00:01:06,530
However, let's talk
about the inputs first.

16
00:01:07,610 --> 00:01:12,290
Input devices are meant for
delivering data to the processing element.

17
00:01:12,290 --> 00:01:18,764
In some cases, the microcontrollers have
different peripheral units that play

18
00:01:18,764 --> 00:01:24,867
the role of inputs, for example,
communication units such as UART or SPI.

19
00:01:24,867 --> 00:01:29,180
An analog to digital converter can
also be considered as an input device.

20
00:01:30,450 --> 00:01:34,792
These peripheral units might be located
inside of the microcontroller and

21
00:01:34,792 --> 00:01:37,319
exposed to the user through external pins.

22
00:01:38,400 --> 00:01:41,820
By the way,
general purpose input/output pins,

23
00:01:41,820 --> 00:01:45,500
as you might guess from their name,
can also be used as an input,

24
00:01:45,500 --> 00:01:48,750
regardless of any peripheral
unit being attached to them.

25
00:01:50,500 --> 00:01:54,460
There are many ways to classify
a microcontroller's inputs.

26
00:01:54,460 --> 00:01:58,190
However, among all of them,
I would like to mention the one which

27
00:01:58,190 --> 00:02:03,000
separates inputs into two categories,
serial and parallel.

28
00:02:04,150 --> 00:02:08,750
As an example you can think of serial
peripheral interface and GPIOs.

29
00:02:10,180 --> 00:02:13,900
Inputs can also be classified according
to the type of signal they handle.

30
00:02:15,090 --> 00:02:19,650
This way an input may be digital,
for example SPI interface, or

31
00:02:19,650 --> 00:02:22,190
analog, such as an analog
to digital converter.

32
00:02:24,020 --> 00:02:26,490
The next question I would like to cover

33
00:02:26,490 --> 00:02:29,690
is how to actually read
the data from those inputs.

34
00:02:30,800 --> 00:02:34,420
The details of how to do
that may be quite different

35
00:02:34,420 --> 00:02:36,840
depending on the input
unit you want to use.

36
00:02:37,980 --> 00:02:40,750
Let's consider an SPI interface and

37
00:02:40,750 --> 00:02:45,680
an ADC, which are clearly very
different kinds of units.

38
00:02:45,680 --> 00:02:48,300
The first one is meant to communication,

39
00:02:48,300 --> 00:02:52,140
whereas the second one converts
analog signals into a digital form.

40
00:02:53,330 --> 00:02:58,250
Because of their fundamental differences,
we can expect their operation details

41
00:02:58,250 --> 00:03:02,240
to differ very much as well as
the methods for reading data from them.

42
00:03:03,320 --> 00:03:07,590
However, from a higher abstraction level,
we can distinguish two ways for

43
00:03:07,590 --> 00:03:08,240
doing this.

44
00:03:09,240 --> 00:03:13,250
The first one is to read
the input every once in a while,

45
00:03:13,250 --> 00:03:15,900
let's say once every 100
milliseconds interval.

46
00:03:17,000 --> 00:03:21,685
In this case, the read operation
is initiated by the software.

47
00:03:21,685 --> 00:03:25,920
Therefore, we need write a piece
of code that gets the data

48
00:03:25,920 --> 00:03:28,480
from the input unit at
the chosen interval.

49
00:03:29,760 --> 00:03:34,710
In our case, the interval is 100
milliseconds, but it can be adjusted.

50
00:03:35,930 --> 00:03:38,850
Now, let's think about the following case.

51
00:03:38,850 --> 00:03:43,151
What if we are interested in knowing
the time when an event happens?

52
00:03:43,151 --> 00:03:47,937
For example, we need to know when
the voltage level on some pin

53
00:03:47,937 --> 00:03:50,710
rises from logic zero to logic one.

54
00:03:51,900 --> 00:03:57,132
What time interval do we choose
in order to catch such event?

55
00:03:57,132 --> 00:04:00,494
You can make an assumption
that the shorter the interval,

56
00:04:00,494 --> 00:04:03,033
the more frequently we check the input,
and

57
00:04:03,033 --> 00:04:06,750
therefore the less the probability
that we will miss the event.

58
00:04:07,850 --> 00:04:09,800
This is of course true.

59
00:04:09,800 --> 00:04:14,470
However, if we think of the amount of
time the processing element will spend on

60
00:04:14,470 --> 00:04:19,550
checking if the event has occurred,
we will conclude that such approach

61
00:04:19,550 --> 00:04:24,760
is not efficient since a lot of
computational power will be wasted.

62
00:04:24,760 --> 00:04:28,950
Luckily, there is another
way of catching fast events.

63
00:04:28,950 --> 00:04:32,030
If the first method was
software initiated,

64
00:04:32,030 --> 00:04:34,670
the second way is hardware initiated.

65
00:04:34,670 --> 00:04:37,250
It is based on interrupts.

66
00:04:37,250 --> 00:04:40,220
When an event occurs,
it causes an interrupt,

67
00:04:40,220 --> 00:04:44,840
which in turn breaks the flow of
the main program and reads the input.

68
00:04:46,050 --> 00:04:50,190
The second method is more reliable
in the sense that it is less likely

69
00:04:50,190 --> 00:04:51,220
to miss the event.

70
00:04:53,760 --> 00:04:55,950
To make sense of the received data,

71
00:04:55,950 --> 00:05:01,050
the communications unit used as input
must be compatible with the sender.

72
00:05:02,505 --> 00:05:06,400
This compatibility should
be at the protocol level.

73
00:05:06,400 --> 00:05:11,040
This means that signals
used follow the same rules.

74
00:05:11,040 --> 00:05:15,290
For example,
if SPI communication protocol is used,

75
00:05:15,290 --> 00:05:20,470
the sender and the receiver should
work according to this protocol.

76
00:05:20,470 --> 00:05:23,900
It is also important to
consider voltage compatibility.

77
00:05:24,900 --> 00:05:30,026
The signals should be preferably
used the same voltage,

78
00:05:30,026 --> 00:05:33,994
let's say either 3.3 volts or 5 volts.

79
00:05:33,994 --> 00:05:36,490
With outputs,
the picture is pretty much the same.

80
00:05:37,500 --> 00:05:39,910
Peripheral units can be used as output.

81
00:05:41,060 --> 00:05:45,650
The interaction with the outer
world is done via external pins.

82
00:05:46,730 --> 00:05:51,260
The classification is also similar,
serial, parallel, analog, digital.

83
00:05:52,840 --> 00:05:57,500
An example of an analog output is
a digital to analog converter,

84
00:05:57,500 --> 00:06:00,300
which converts a number
to a voltage signal.

85
00:06:01,410 --> 00:06:06,850
Communication units, such as UART or
SPI, are examples of digital outputs.

86
00:06:08,670 --> 00:06:14,510
Sending and receiving data can be
software or hardware-initiated.

87
00:06:14,510 --> 00:06:18,137
Let's make an example of
hardware-initiated transfer.

88
00:06:18,137 --> 00:06:23,110
For example, we need to build an analog
signal using a microcontroller.

89
00:06:24,250 --> 00:06:27,840
In this case, we will need
a digital-to-analog converter.

90
00:06:29,080 --> 00:06:33,140
The shape of the required signal
should be, for example, sinusoidal.

91
00:06:34,270 --> 00:06:38,044
For that we will keep samples,
which are just numbers,

92
00:06:38,044 --> 00:06:42,980
of one of the periods of
the sinusoidal in memory.

93
00:06:42,980 --> 00:06:47,780
What we need to do is to read those
samples at the right intervals

94
00:06:47,780 --> 00:06:49,250
to send them to the DAC.

95
00:06:50,840 --> 00:06:53,950
The right intervals of time
are measured using a timer.

96
00:06:55,110 --> 00:06:58,790
Now, if we want to keep
the shape of a signal stable,

97
00:06:58,790 --> 00:07:00,340
we need to rely on hardware.

98
00:07:01,420 --> 00:07:03,090
It can be done in the following way.

99
00:07:04,180 --> 00:07:09,570
A timer marks the right moment and
instructs the Direct Memory Access unit

100
00:07:09,570 --> 00:07:13,370
to transfer one sample from
the memory to the DAC.

101
00:07:14,750 --> 00:07:17,170
After the DAC converts
the sample to voltage,

102
00:07:19,020 --> 00:07:22,670
everything is set to be done
without the influence of software.

103
00:07:24,640 --> 00:07:29,020
As for inputs, output units should
be compatible with the receiver

104
00:07:29,020 --> 00:07:32,400
regarding their protocol and
voltage level used.

105
00:07:32,400 --> 00:07:37,100
So in this video we discussed the ways
on how an embedded system can exchange

106
00:07:37,100 --> 00:07:39,039
the data with outer world, and

107
00:07:39,039 --> 00:07:44,203
what are the requirements that should be
expected to make such exchange correct.

108
00:07:44,203 --> 00:07:48,484
[SOUND]