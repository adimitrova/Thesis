[music] hello and welcome back to the course.
in this video we will elaborate on sensors and actuators.
you will get an insight on where they are used.
we also will discuss what obstacles you might encounter on the way while working with them.
and in the end, i will talk about two ways on how to read input data, namely polling and interrupts.
embedded systems deal with the real physical world.
physical quantities of the real world can either be used as input for the embedded system or they can be altered by such systems.
sensors are meant for measuring physical quantities.
in a sense, sensors help to convert a physical quantity, such as, for example, temperature, pressure, or acceleration into a number.
so sensors map a physical value to a number.
there are examples of sensors.
a temperature sensor converts temperature to voltage.
an accelermator converts acceleration to voltage and many others.
sensors can have a processing element on board.
so they can have a digital output.
actuators are used to alter the physical quantity.
in contrast to sensors, which are driven by the physical quantity, actuators are driven by a processing element or in other words, by a number.
electric motors are a good example of actuators.
a sensor's work range is limited.
for example, a temperature sensor can operate in the range from -20 degrees celsius to 50 degrees celsius.
obviously, this should be taken into consideration, when using such sensors.
if the sensor is used out of its range, then saturation might occur.
it means that the mentioned temperature sensor will show the temperature 50 degrees, when the real temperature is, let's say 60 degrees.
to be used by processing elements, the measure of quantity should be quantized.
what does this mean?
during the process of quantization, the quantity is being mapped to a number.
it happens with some error because the number of values is limited.
for example, there are only 8 bits to be used for quantization.
so in total we have 256 numbers.
this means that our initial quantity will be mapped to one of those 256 numbers.
the quantity will be mapped to the closest number.
thus quantization is done with some error, which is the difference between the real value and its quantized representation.
for some applications, it may be not enough to have just 256 values to represent the whole range of changes of some quantity.
in this case, the number of bits or in other words the resolution should be increased to 9, 10 bits or more.
sometimes the only way to increase the resolution is to change the hardware.
at this pont, you can think of the cases where the quantization error will be the largest.
another issue that needs to be considered when dealing with sensors is noise.
measurements always have a noise component.
we can say that a measurement is the sum of the real value and the noise.
if you think of an accelerometer, then the noise can be caused by some random vibration.
the influence of noise can be reduced when processing the results.
filtering is one of the examples of how the noise can be reduced.
we talked about quantization, however the quantization process is done at some moments of time.
the quantization in time is called sampling.
sampling is done with some period t. it may be obvious that the smaller the t, the higher the sampling frequency and therefore the more data we will have per second.
however, it is not always necessary to increase the sampling frequency.
we will not go deep into the details, although i would like to mention that it was proven by nyquist that the sampling frequency should be at least twice the highest frequency contained in the signal.
if the signal is sampled at a lower frequency, we may get wrong information about the signal.
however this is only relevant if the shape of the signal matters to us.
in many other cases, especially when the signal changes slowly, for example temperature under normal conditions does not change fast.
might not been necessary to use a high sampling frequency.
a processing element can read data from a sensor once in a while.
let's say we use a timer of the micro controller which marks off 100 millisecond intervals.
thus we can obtain data every 100 milliseconds.
this approach is good enough for a slow processes, however when there is need to catch a fast event and we don't know when exactly it will occur.
this method is not a good choice.
we can adjust the interval between two successive reads, for example, we can make it smaller.
in this case, the probability of missing the event decreases.
this approach is called polling.
so when polling, the processing element checks if the event has occurred within some time interval.
the interval can be adjusted.
so what are the downsides of this approach?
the main drawback is that the approach doesn't allow to catch fast random events.
another disadvantage is that a processing element spends its time polling.
and the smaller the interval, the more time is spent.
here, this means that computation power is wasted.
so is there a way to catch fast random events?
let's consider that we have a microcontroller as a tool for that.
with the power of interrupts, it is possible to catch fast events, and what is more, to estimate at the time when the event occurred.
an interrupt is a hardware based way to break the main flow of the program, which means this method is fast in the sense that the hardware reacts quickly to the event.
furthermore, it gives control to software to process the event.
so what are the off sites of interrupts?
first, when we use interrupts, the processing element does not spend computation power to actually check if the event occurred.
an interrupt happens almost at the same time when the physical event occurs.
micro-controllers have one or several external interrupt pins, which gives a developer the possibility to process the incoming event.
a raise or fall of voltage on the corresponding pin can be an event.
an interrupt might also happen when for example, the adc conversion has finished, or when some data has come to the receive buffer of the uart register, which is very convenient.
what is left for the developer is just to take their result of the adc conversion, or their received uart data, and use it.
an interrupt service routine can be used to process an interrupt.
it can be written by a developer.
it is good practice to make interrupt service routines fast.
because they break tha main program flow, and might block other interrupts, or the execution of other tasks.
in the video we talk about sensors and actuators as the ways the processing element communicate with the physical world.
we also discussed the ways on how the input data can be obtained.
so thanks for watching.
i hope this module has been interesting for you and i look forward seeing you in the next module.
[music]
