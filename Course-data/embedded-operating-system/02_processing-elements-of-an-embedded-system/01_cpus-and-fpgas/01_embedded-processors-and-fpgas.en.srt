1
00:00:00,127 --> 00:00:05,704
[MUSIC]

2
00:00:05,704 --> 00:00:10,146
Hello, I hope by now you have
a general idea about embedded systems,

3
00:00:10,146 --> 00:00:15,770
the challenges that lie in this field,
and their main characteristics.

4
00:00:15,770 --> 00:00:16,760
In this lecture,

5
00:00:16,760 --> 00:00:22,160
we will go into details of what components
the embedded systems consist of.

6
00:00:22,160 --> 00:00:26,070
We are going to start by
discussing on processing elements.

7
00:00:26,070 --> 00:00:29,340
In the course,
we will cover embedded processors and

8
00:00:29,340 --> 00:00:32,440
field program level gate arrays, FPGAs.

9
00:00:32,440 --> 00:00:35,180
So in the end of the course,
you are capable of selecting

10
00:00:35,180 --> 00:00:39,370
a proper processing element
to implement your own ideas.

11
00:00:39,370 --> 00:00:42,740
So here, I would like to start
by giving you some ideas

12
00:00:42,740 --> 00:00:45,280
on what embedded processors and
NetFPGAs are.

13
00:00:47,320 --> 00:00:50,910
Well, we discuss embedded
processors first.

14
00:00:50,910 --> 00:00:52,940
So what is a processor?

15
00:00:52,940 --> 00:00:55,800
It is an electronic device
that works sequentially.

16
00:00:57,110 --> 00:01:01,700
This means that a processor makes
computations in a serial manner,

17
00:01:01,700 --> 00:01:02,520
one after another.

18
00:01:03,720 --> 00:01:06,660
Any computation,
no matter how difficult it is,

19
00:01:06,660 --> 00:01:10,645
can be split into simpler,
let's say sub-computations.

20
00:01:10,645 --> 00:01:15,380
Those sub-computations might
be split even further.

21
00:01:15,380 --> 00:01:19,120
An elementary piece of computation
that cannot be split anymore

22
00:01:19,120 --> 00:01:20,480
is called an instruction.

23
00:01:21,730 --> 00:01:26,560
Any piece of computation, given by let's
say by our programmer, in order to be

24
00:01:26,560 --> 00:01:30,990
executed on a processor, should be
split into a sequence of instructions.

25
00:01:32,270 --> 00:01:36,990
Different kinds of processors can
have different instruction sets.

26
00:01:36,990 --> 00:01:40,630
They are different for example,
in the number of instructions or

27
00:01:40,630 --> 00:01:44,339
let's say in how complex simple
instructions are in the sets.

28
00:01:45,580 --> 00:01:47,740
So what is good about this approach?

29
00:01:47,740 --> 00:01:51,780
And there should be oboisily something
good in it since nowadays processors

30
00:01:51,780 --> 00:01:52,810
are widely used.

31
00:01:53,980 --> 00:01:56,110
The good thing is it's flexibility.

32
00:01:57,200 --> 00:02:02,180
Nearly, any piece of computation can be
represented as a sequence of instructions

33
00:02:02,180 --> 00:02:04,430
and therefore executed on a processor.

34
00:02:05,580 --> 00:02:09,750
That means we change the behavior
of an embedded system

35
00:02:09,750 --> 00:02:14,060
just by changing the sequence of
instructions it's processor executes.

36
00:02:15,240 --> 00:02:18,460
In other words,
we only change the software.

37
00:02:18,460 --> 00:02:21,380
There is no need to change
the architecture of the processor.

38
00:02:22,900 --> 00:02:28,260
The generality of such approach is the
reason why it is used massively nowadays.

39
00:02:29,500 --> 00:02:34,500
Let's just think about the huge number
of applications that can be run on,

40
00:02:34,500 --> 00:02:39,020
let's say, Cortex processors,
which are present in smartphones,

41
00:02:39,020 --> 00:02:41,330
servers and many other devices.

42
00:02:43,030 --> 00:02:47,970
One metric for processors, as mentioned
before, is the instruction set,

43
00:02:47,970 --> 00:02:51,430
which actually defines the inner
structure of a processor.

44
00:02:52,710 --> 00:02:57,810
If we compared reduced instruction set
computers and complex instruction set

45
00:02:57,810 --> 00:03:03,200
computers, we will notice that
CISC instruction set is larger.

46
00:03:03,200 --> 00:03:06,620
And it has more complex instructions, so

47
00:03:06,620 --> 00:03:10,110
how does it influence
the complexity of hardware?

48
00:03:10,110 --> 00:03:13,460
We are not going to go
deeply into the details, but

49
00:03:13,460 --> 00:03:16,750
at least we can conclude
that the piece of hardware

50
00:03:16,750 --> 00:03:20,520
that the codes instructions
should be more complex for CISC.

51
00:03:22,620 --> 00:03:28,630
One of the most prominent representative
of Sisk is Intel's X86 processors.

52
00:03:29,930 --> 00:03:31,360
Though in this course,

53
00:03:31,360 --> 00:03:34,950
we are not targeting this kind
of big general processors.

54
00:03:36,060 --> 00:03:40,130
I could not not mention a more kind

55
00:03:40,130 --> 00:03:44,530
of embeddable processors are for
example RISC micro controllers.

56
00:03:46,220 --> 00:03:52,200
If we look at Atmel's AVR family we
will find a large variety of options for

57
00:03:52,200 --> 00:03:54,240
embedded applications.

58
00:03:54,240 --> 00:03:56,940
Advanced RISC, arm processors,

59
00:03:56,940 --> 00:04:00,179
as was mentioned before
are widely spread nowadays.

60
00:04:01,270 --> 00:04:05,840
They've arrived from Cortex M to
Cortex A family which are meant for

61
00:04:05,840 --> 00:04:09,980
different application domains in
terms of competition out performance,

62
00:04:09,980 --> 00:04:11,870
energy efficiency and others.

63
00:04:13,100 --> 00:04:17,810
In further lectures, we will give more
details about processors in general and

64
00:04:17,810 --> 00:04:20,050
microcontrollers in particular.

65
00:04:20,050 --> 00:04:24,820
So just how instructions are executed,
what peripherals are used,

66
00:04:24,820 --> 00:04:27,810
what platforms exist, so stay in.

67
00:04:29,760 --> 00:04:33,900
Now that you have an insight on what
the nature of an embedded processor

68
00:04:33,900 --> 00:04:37,987
is we can move to the second
representative of processing elements.

69
00:04:37,987 --> 00:04:41,720
Field-programmable gate arrays, or FPGAs.

70
00:04:42,870 --> 00:04:46,330
Well, it is of course
an electronic device, but

71
00:04:46,330 --> 00:04:51,250
unlike a processor it is meant for
more application specific designs.

72
00:04:51,250 --> 00:04:52,959
So what does it mean?

73
00:04:52,959 --> 00:04:57,416
First, let's have a quick
look at what an FPGA is.

74
00:04:57,416 --> 00:05:00,390
FPGA has reconfigured a logic with them.

75
00:05:01,710 --> 00:05:07,110
To make a simple example,
let's say we have two input and gates.

76
00:05:07,110 --> 00:05:09,150
What kind of logic can we implement?

77
00:05:10,170 --> 00:05:15,819
We can for example use only one gate and
implement a simple logic and function.

78
00:05:16,900 --> 00:05:22,450
However, we can implement a more complex
circuit if we use both and gates and

79
00:05:22,450 --> 00:05:27,120
connected the output of the first gates
to one of the inputs of the other gate.

80
00:05:28,190 --> 00:05:34,390
So, if a certain application demands
the use of two gates, we can use both.

81
00:05:35,890 --> 00:05:39,940
This is a simplified way to explain
what can be done with an FPGA.

82
00:05:41,020 --> 00:05:44,240
An FPGA has many logic blocks in sight,
and

83
00:05:44,240 --> 00:05:49,010
when needed, these blocks can be connected
together to build complex circuits.

84
00:05:50,190 --> 00:05:55,560
These connections, the inner structure
of the FPGA has to be configured

85
00:05:55,560 --> 00:05:59,290
according to the application's
requirements before the execution.

86
00:06:00,390 --> 00:06:05,130
So, when we deal with an FPGA,
we make changes on a hardware level

87
00:06:06,330 --> 00:06:10,540
and FPGAs hardware design is meant for
certain applications.

88
00:06:11,560 --> 00:06:15,390
You can see now that there
is no such flexibility for

89
00:06:15,390 --> 00:06:18,600
FPGAs as there is for processors.

90
00:06:18,600 --> 00:06:20,800
We need to change the hardware design for

91
00:06:20,800 --> 00:06:24,540
an FPGA every time there
is a new application.

92
00:06:24,540 --> 00:06:25,640
There is no flexibility.

93
00:06:27,150 --> 00:06:30,590
The reasonable question
is why then use an FPGA?

94
00:06:31,660 --> 00:06:37,470
Flexibility comes at the cost of
performance, and energy consumption.

95
00:06:37,470 --> 00:06:43,010
Indeed, in most cases, the same
application implemented on an FPGA,

96
00:06:43,010 --> 00:06:48,050
executes faster and consumes less energy
than if implemented on a processor.

97
00:06:49,530 --> 00:06:53,640
There is one more thing which one needs
to consider when working with an FPGA.

98
00:06:54,960 --> 00:07:00,730
An FPGA design is parallel in a sense
that there is no sequence of operations.

99
00:07:00,730 --> 00:07:02,220
Things happen in parallel.

100
00:07:03,260 --> 00:07:05,980
A good example is a four loop.

101
00:07:05,980 --> 00:07:12,240
If the loop is executed on a processor, it
will be run one iteration after another.

102
00:07:12,240 --> 00:07:15,040
However, if the loop is
implemented on FPGA,

103
00:07:15,040 --> 00:07:20,360
a separate surrogate for
each iteration will be generated.

104
00:07:20,360 --> 00:07:22,840
In a sense, iterations exist in parallel.

105
00:07:24,630 --> 00:07:28,000
Now you can probably conclude
that a FPGA is meant for

106
00:07:28,000 --> 00:07:30,570
computationally heavy applications.

107
00:07:30,570 --> 00:07:35,409
Such as for example,
image processing or big data analytics.

108
00:07:35,409 --> 00:07:41,082
It is also interesting that an embedded
processor can be implemented on an FPGA.

109
00:07:41,082 --> 00:07:44,460
In this case,
a processor is the application itself.

110
00:07:46,360 --> 00:07:49,390
There are several FPGA vendors
available in the market.

111
00:07:50,500 --> 00:07:52,490
The living one is Xilinx,

112
00:07:52,490 --> 00:07:57,350
which has a wide variety of devices
with different characteristics.

113
00:07:57,350 --> 00:08:02,257
We will discuss the main ones as well
as the inner structure of an FPGA in

114
00:08:02,257 --> 00:08:06,932
the following lectures, so
there are interesting things ahead.

115
00:08:06,932 --> 00:08:11,847
Well, to sum up the video, I would
like to emphasize the main differences

116
00:08:11,847 --> 00:08:14,890
between a processor and an FPGA.

117
00:08:14,890 --> 00:08:19,690
Because these differences will impact the
choice when selecting a proper platform

118
00:08:19,690 --> 00:08:20,250
to work with.

119
00:08:21,600 --> 00:08:27,470
A processor has a sequential nature
at its core and provides flexibility.

120
00:08:27,470 --> 00:08:33,440
Whereas, an FPGA is more application
oriented and provides hydro performance.

121
00:08:33,440 --> 00:08:40,430
If the main goal is efficiency, then
an FPGA would probably be a good choice.

122
00:08:40,430 --> 00:08:44,140
On the other hand, if we need
to build a generic platform, and

123
00:08:44,140 --> 00:08:46,940
we have either no specific application or

124
00:08:46,940 --> 00:08:51,780
many applications in mind, then
a processor would be a suitable solution.

125
00:08:52,960 --> 00:08:57,640
And also it is worth mentioning
that sometimes the optimal solution

126
00:08:57,640 --> 00:08:59,690
lies between two limits.

127
00:08:59,690 --> 00:09:04,620
So a combination of a processor with
an FPGA may be a powerful tool.

128
00:09:06,370 --> 00:09:09,784
Thank you for watching, and
see you in the next video.

129
00:09:09,784 --> 00:09:13,884
[SOUND]