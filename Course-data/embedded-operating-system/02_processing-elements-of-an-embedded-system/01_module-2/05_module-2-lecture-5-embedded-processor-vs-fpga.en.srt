1
00:00:00,000 --> 00:00:06,031
[MUSIC]

2
00:00:06,031 --> 00:00:08,750
Hello and welcome back to the course.

3
00:00:08,750 --> 00:00:11,940
By now,
I hope you know about microcontrollers and

4
00:00:11,940 --> 00:00:15,440
NetFPGAs as well as about their features.

5
00:00:15,440 --> 00:00:19,869
In this video, we will show the steps you
need to follow to make them actually work

6
00:00:20,920 --> 00:00:25,100
this sequence of steps is
called a design of work flow.

7
00:00:25,100 --> 00:00:30,570
Obviously, design flows for
microcontrollers and SPGAs are different.

8
00:00:30,570 --> 00:00:34,820
We will start with microcontrollers, so

9
00:00:34,820 --> 00:00:38,790
after the application that you
want to implement is selected.

10
00:00:38,790 --> 00:00:43,130
And the choice of the appropriate
microcontroller platform is done,

11
00:00:43,130 --> 00:00:45,860
it is time to actually start
building the solution.

12
00:00:47,070 --> 00:00:51,070
First, you may want to select
a programming language that you will use.

13
00:00:52,400 --> 00:00:55,270
There are three popular
programming languages for

14
00:00:55,270 --> 00:00:59,980
microcontrollers, assembler, C, and C++.

15
00:00:59,980 --> 00:01:03,320
Sometimes developers use the language
which they know the best or

16
00:01:03,320 --> 00:01:06,470
the choice may be dictated
by the project itself.

17
00:01:06,470 --> 00:01:09,870
If, for example,
the project is built using C and

18
00:01:09,870 --> 00:01:14,810
it will cause less trouble if a project
extension will be done on C as well.

19
00:01:16,140 --> 00:01:19,910
However, the solution can benefit from
each programming language differently.

20
00:01:21,090 --> 00:01:25,020
Assembler is a very efficient
way to build a solution where

21
00:01:25,020 --> 00:01:28,180
the generated code is fast and
takes less memory.

22
00:01:29,710 --> 00:01:35,030
Also, assembler lets you investigate
the inner structure of the hardware.

23
00:01:35,030 --> 00:01:37,220
But unluckily, it is less convenient for

24
00:01:37,220 --> 00:01:39,580
humans to read a program
written in assembler.

25
00:01:40,710 --> 00:01:43,750
What is more,
the larger the solution becomes,

26
00:01:43,750 --> 00:01:46,960
the more difficult it is to maintain and
debug assembly code.

27
00:01:48,140 --> 00:01:50,820
Fortunately, memory cost is low and

28
00:01:50,820 --> 00:01:54,680
micro controllers nowadays
are cheaper than they used to be.

29
00:01:54,680 --> 00:02:00,583
This fact enables the use of more
human friendly programming languages,

30
00:02:00,583 --> 00:02:02,120
such as C or C++.

31
00:02:02,120 --> 00:02:05,630
These languages allow
developers to build vigor and

32
00:02:05,630 --> 00:02:09,320
more complex solutions,
which are easier to maintain and extend.

33
00:02:10,510 --> 00:02:13,240
Though, it is still possible
to write assembly code for

34
00:02:13,240 --> 00:02:17,290
critical parts of the program,
combining C and assembler.

35
00:02:19,200 --> 00:02:22,810
Even though all required tools,
such as compilers,

36
00:02:22,810 --> 00:02:28,310
linkers, can be used manually, to build
an executable for a microcontroller.

37
00:02:28,310 --> 00:02:30,120
It is often more convenient,

38
00:02:30,120 --> 00:02:34,260
to build a solution in an integrated
development environment.

39
00:02:34,260 --> 00:02:37,080
Some vendors develop their own IDs.

40
00:02:37,080 --> 00:02:43,070
For example, Admil, has Admil Studio but
there, of course, more options.

41
00:02:43,070 --> 00:02:45,410
Eclipse IDE is one of them.

42
00:02:45,410 --> 00:02:49,510
This is a free IDE for our range of
platforms and programming languages.

43
00:02:50,860 --> 00:02:55,890
Usually vendors release supplementary
libraries to ease the use of their devices

44
00:02:55,890 --> 00:02:57,879
and speed up the design process.

45
00:02:59,090 --> 00:03:04,200
After the code is written and an
executable file is built, the firmware can

46
00:03:04,200 --> 00:03:09,720
be loaded via programming interface such
as or be a bootloader if it is installed.

47
00:03:10,910 --> 00:03:15,160
The next steps will be to execute
the solution, verify it and

48
00:03:15,160 --> 00:03:16,580
refine the program if needed.

49
00:03:18,970 --> 00:03:23,340
The design flow for
FPGAs comprises design entry,

50
00:03:23,340 --> 00:03:29,348
design synthesis, design
implementation and device programming.

51
00:03:29,348 --> 00:03:33,112
Design entry creation includes
creating a project and

52
00:03:33,112 --> 00:03:35,820
adding it to the project design files.

53
00:03:35,820 --> 00:03:41,187
Those files include the actual description
of the hardware that you want to have in

54
00:03:41,187 --> 00:03:46,580
one of the hardware description languages
such as for example, VHDL or Verilog.

55
00:03:47,670 --> 00:03:52,310
Also the design entry might include pin
assignment and area constraint files.

56
00:03:54,480 --> 00:03:58,220
In a simplified way an FPGA
design can be represented

57
00:03:58,220 --> 00:04:01,190
as module that has inputs and outputs.

58
00:04:02,310 --> 00:04:06,430
The top module can include many other
smaller modules connected together.

59
00:04:07,950 --> 00:04:11,060
BHDL which is a widely used for

60
00:04:11,060 --> 00:04:14,710
outdoor development supports such
modular style of development.

61
00:04:15,930 --> 00:04:21,560
To make a simple example, let's see how a
basic OR gate can be implemented in BHDO.

62
00:04:23,290 --> 00:04:28,220
The description consists of two parts,
entity and architecture.

63
00:04:29,290 --> 00:04:35,530
Entity declares inputs and outputs as
well as their types In later stages,

64
00:04:35,530 --> 00:04:40,290
this inputs and outputs can be mapped
to certain physical pings of an FPGA.

65
00:04:41,710 --> 00:04:45,090
The architecture describes
the actual implementation.

66
00:04:45,090 --> 00:04:49,920
In other words, in the architecture
section inputs are mapped to outputs.

67
00:04:51,110 --> 00:04:58,080
A certain entity may have several
architectures before the design synthesis,

68
00:04:58,080 --> 00:05:02,890
it is important to verify the design
entry by running simulations.

69
00:05:02,890 --> 00:05:07,200
Simulation allows to check if the
functionality of the design is correct.

70
00:05:08,460 --> 00:05:12,750
During the design synthesis stage,
the code syntax will be checked.

71
00:05:14,150 --> 00:05:17,480
The hierarchy of the design
will also be analyzed,

72
00:05:17,480 --> 00:05:21,850
which ensures that the design is
optimized for the chosen architecture.

73
00:05:23,390 --> 00:05:26,190
The result of this stage is a Netlist,

74
00:05:26,190 --> 00:05:30,480
which is a textual representation of
a circuit diagram or a schematic.

75
00:05:32,130 --> 00:05:36,120
Design implementation
consists of four phases.

76
00:05:36,120 --> 00:05:40,100
They are translate, map,
place and route, and program.

77
00:05:41,380 --> 00:05:45,660
During the translate phase,
all the input netlists generated

78
00:05:45,660 --> 00:05:49,389
by synthesis are merged together
with design constraints.

79
00:05:50,510 --> 00:05:53,910
The output of this phase
is a database file

80
00:05:53,910 --> 00:05:57,440
which describes the logical
design reduced to primitives.

81
00:05:58,580 --> 00:06:02,910
During the map phase,
the logic defined by the database file

82
00:06:02,910 --> 00:06:06,709
is mapped into the FPGA
elements such as logic blocks.

83
00:06:08,250 --> 00:06:12,380
The output of this phase is a circuit
description file which contains

84
00:06:12,380 --> 00:06:17,350
a fiscal representation of the design,
map to the components of the FPGA.

85
00:06:19,210 --> 00:06:24,380
Place and route process takes
the circuit description file, places and

86
00:06:24,380 --> 00:06:28,340
routes the design and
produces another circuit description file

87
00:06:28,340 --> 00:06:31,760
that will be used as input for
the bit stream generation.

88
00:06:33,190 --> 00:06:36,910
Finally, during the last phase
fo programming file generation,

89
00:06:36,910 --> 00:06:41,630
the actual file that will be used to be
uploaded to the hardware is generated.

90
00:06:43,760 --> 00:06:48,955
Now I hope you have an insight of
where and how to apply a processor and

91
00:06:48,955 --> 00:06:52,890
FPGAs, as well as you know
the application areas.

92
00:06:54,380 --> 00:06:58,990
As it very often happens, the optimal
solution, lies between extremes.

93
00:07:00,370 --> 00:07:03,970
In a sense, It is also true in our case,

94
00:07:03,970 --> 00:07:06,580
where we choose between a processor and
an FPGA.

95
00:07:07,750 --> 00:07:12,090
But how to find a solution that is
flexible, energy efficient, and

96
00:07:12,090 --> 00:07:13,500
fast at the same time?

97
00:07:14,590 --> 00:07:18,730
This is where hybrid platforms, or
systems on chips, come into the picture.

98
00:07:20,090 --> 00:07:23,730
An SoC is a microchip
circuit that integrates

99
00:07:23,730 --> 00:07:27,450
all the necessary components for
a system into a single chip.

100
00:07:28,630 --> 00:07:33,750
An SoC might leverage advantages of
embedded processors and an FPGA.

101
00:07:34,900 --> 00:07:39,160
Indeed, an embedded processor,
surrounded by programmable logic,

102
00:07:39,160 --> 00:07:42,869
is a powerful tool for
building complex, flexible solutions.

103
00:07:44,460 --> 00:07:47,870
When comparing an SoC implementation

104
00:07:47,870 --> 00:07:51,790
with another one where all
the components are not in a single chip.

105
00:07:51,790 --> 00:07:55,720
But let's say spread over
the printed circuit board,

106
00:07:55,720 --> 00:08:00,460
the SoC will provide a lower cost
solution that benefits from fast

107
00:08:00,460 --> 00:08:05,330
data transfers Higher speeds,
smaller sizes, and is more reliable.

108
00:08:07,030 --> 00:08:13,663
As an example of an SOC let's take
a look at the Xilinx Zynq-7000 chip.

109
00:08:13,663 --> 00:08:18,680
The Zynq-7000 is a hybrid
platform that has dual ARM cortex

110
00:08:18,680 --> 00:08:24,100
A9 processors and or programmable logic.

111
00:08:24,100 --> 00:08:29,060
An AXI bus serves as a messenger between
a processor and the programmable logic.

112
00:08:31,030 --> 00:08:36,100
The design flow for hybrid platforms
comprises both hardware and

113
00:08:36,100 --> 00:08:41,289
software development and testing, as well
as system integration as the final step.

114
00:08:42,930 --> 00:08:47,420
There are several representatives
of Zynq-7000 family.

115
00:08:47,420 --> 00:08:51,890
They are different in many parameters
such as the maximum speed of the hardcore

116
00:08:51,890 --> 00:08:56,810
processor, amount of available FPG logic,
RAM size, etc.

117
00:08:56,810 --> 00:09:02,970
There are also several Zynq-7000-based
platforms on the market.

118
00:09:02,970 --> 00:09:07,700
They've arrived in the amount
available resources, sizes and costs.

119
00:09:07,700 --> 00:09:11,900
From PicoZed, that is the smallest and
the cheapest option,

120
00:09:11,900 --> 00:09:17,500
to Zynq Mini-ITX that is the same
size as the standard PC mother board.

121
00:09:18,610 --> 00:09:22,080
There are obviously many more
platforms available in the market

122
00:09:22,080 --> 00:09:24,580
than the ones that we
mentioned in the course.

123
00:09:24,580 --> 00:09:29,770
Each one of them with different
features,platforms are just tools

124
00:09:29,770 --> 00:09:30,780
to build on application.

125
00:09:31,970 --> 00:09:38,328
Although the tool itself is important, the
purpose it serves is even more important.

126
00:09:38,328 --> 00:09:44,460
In other words, when selecting a tool,
the approach should be application based.

127
00:09:44,460 --> 00:09:47,180
This is all I have for this lesson.

128
00:09:47,180 --> 00:09:50,420
In this video,
we discussed the possible design flows for

129
00:09:50,420 --> 00:09:53,310
microcontrollers and FPGAs.

130
00:09:53,310 --> 00:09:58,100
We also covered hybrid platforms which
can provide a more flexible solution for

131
00:09:58,100 --> 00:09:59,219
certain applications.

132
00:10:00,220 --> 00:10:03,861
This lesson is also the last
one of this morning but

133
00:10:03,861 --> 00:10:06,211
I hope to see you in the next one.

134
00:10:06,211 --> 00:10:08,900
Thank you for watching.