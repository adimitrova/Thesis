[MUSIC] Hello and welcome back to the course. By now,
I hope you know about microcontrollers and NetFPGAs as well as about their features. In this video, we will show the steps you
need to follow to make them actually work this sequence of steps is
called a design of work flow. Obviously, design flows for
microcontrollers and SPGAs are different. We will start with microcontrollers, so after the application that you
want to implement is selected. And the choice of the appropriate
microcontroller platform is done, it is time to actually start
building the solution. First, you may want to select
a programming language that you will use. There are three popular
programming languages for microcontrollers, assembler, C, and C++. Sometimes developers use the language
which they know the best or the choice may be dictated
by the project itself. If, for example,
the project is built using C and it will cause less trouble if a project
extension will be done on C as well. However, the solution can benefit from
each programming language differently. Assembler is a very efficient
way to build a solution where the generated code is fast and
takes less memory. Also, assembler lets you investigate
the inner structure of the hardware. But unluckily, it is less convenient for humans to read a program
written in assembler. What is more,
the larger the solution becomes, the more difficult it is to maintain and
debug assembly code. Fortunately, memory cost is low and micro controllers nowadays
are cheaper than they used to be. This fact enables the use of more
human friendly programming languages, such as C or C++. These languages allow
developers to build vigor and more complex solutions,
which are easier to maintain and extend. Though, it is still possible
to write assembly code for critical parts of the program,
combining C and assembler. Even though all required tools,
such as compilers, linkers, can be used manually, to build
an executable for a microcontroller. It is often more convenient, to build a solution in an integrated
development environment. Some vendors develop their own IDs. For example, Admil, has Admil Studio but
there, of course, more options. Eclipse IDE is one of them. This is a free IDE for our range of
platforms and programming languages. Usually vendors release supplementary
libraries to ease the use of their devices and speed up the design process. After the code is written and an
executable file is built, the firmware can be loaded via programming interface such
as or be a bootloader if it is installed. The next steps will be to execute
the solution, verify it and refine the program if needed. The design flow for
FPGAs comprises design entry, design synthesis, design
implementation and device programming. Design entry creation includes
creating a project and adding it to the project design files. Those files include the actual description
of the hardware that you want to have in one of the hardware description languages
such as for example, VHDL or Verilog. Also the design entry might include pin
assignment and area constraint files. In a simplified way an FPGA
design can be represented as module that has inputs and outputs. The top module can include many other
smaller modules connected together. BHDL which is a widely used for outdoor development supports such
modular style of development. To make a simple example, let's see how a
basic OR gate can be implemented in BHDO. The description consists of two parts,
entity and architecture. Entity declares inputs and outputs as
well as their types In later stages, this inputs and outputs can be mapped
to certain physical pings of an FPGA. The architecture describes
the actual implementation. In other words, in the architecture
section inputs are mapped to outputs. A certain entity may have several
architectures before the design synthesis, it is important to verify the design
entry by running simulations. Simulation allows to check if the
functionality of the design is correct. During the design synthesis stage,
the code syntax will be checked. The hierarchy of the design
will also be analyzed, which ensures that the design is
optimized for the chosen architecture. The result of this stage is a Netlist, which is a textual representation of
a circuit diagram or a schematic. Design implementation
consists of four phases. They are translate, map,
place and route, and program. During the translate phase,
all the input netlists generated by synthesis are merged together
with design constraints. The output of this phase
is a database file which describes the logical
design reduced to primitives. During the map phase,
the logic defined by the database file is mapped into the FPGA
elements such as logic blocks. The output of this phase is a circuit
description file which contains a fiscal representation of the design,
map to the components of the FPGA. Place and route process takes
the circuit description file, places and routes the design and
produces another circuit description file that will be used as input for
the bit stream generation. Finally, during the last phase
fo programming file generation, the actual file that will be used to be
uploaded to the hardware is generated. Now I hope you have an insight of
where and how to apply a processor and FPGAs, as well as you know
the application areas. As it very often happens, the optimal
solution, lies between extremes. In a sense, It is also true in our case, where we choose between a processor and
an FPGA. But how to find a solution that is
flexible, energy efficient, and fast at the same time? This is where hybrid platforms, or
systems on chips, come into the picture. An SoC is a microchip
circuit that integrates all the necessary components for
a system into a single chip. An SoC might leverage advantages of
embedded processors and an FPGA. Indeed, an embedded processor,
surrounded by programmable logic, is a powerful tool for
building complex, flexible solutions. When comparing an SoC implementation with another one where all
the components are not in a single chip. But let's say spread over
the printed circuit board, the SoC will provide a lower cost
solution that benefits from fast data transfers Higher speeds,
smaller sizes, and is more reliable. As an example of an SOC let's take
a look at the Xilinx Zynq-7000 chip. The Zynq-7000 is a hybrid
platform that has dual ARM cortex A9 processors and or programmable logic. An AXI bus serves as a messenger between
a processor and the programmable logic. The design flow for hybrid platforms
comprises both hardware and software development and testing, as well
as system integration as the final step. There are several representatives
of Zynq-7000 family. They are different in many parameters
such as the maximum speed of the hardcore processor, amount of available FPG logic,
RAM size, etc. There are also several Zynq-7000-based
platforms on the market. They've arrived in the amount
available resources, sizes and costs. From PicoZed, that is the smallest and
the cheapest option, to Zynq Mini-ITX that is the same
size as the standard PC mother board. There are obviously many more
platforms available in the market than the ones that we
mentioned in the course. Each one of them with different
features,platforms are just tools to build on application. Although the tool itself is important, the
purpose it serves is even more important. In other words, when selecting a tool,
the approach should be application based. This is all I have for this lesson. In this video,
we discussed the possible design flows for microcontrollers and FPGAs. We also covered hybrid platforms which
can provide a more flexible solution for certain applications. This lesson is also the last
one of this morning but I hope to see you in the next one. Thank you for watching.