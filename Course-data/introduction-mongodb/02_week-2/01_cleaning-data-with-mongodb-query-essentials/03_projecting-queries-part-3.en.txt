So continuing with the reshaping that we're doing here, as we did with released, let's parse a time stamp out of the last updated field. As we look at that field as it currently exists, we can see that there's a time stamp here, but it is encoded as a string and it has some extraneous data here. In fact, that means it doesn't quite match some of the standard time stamp formatting that we're expecting. So what we'll do here is using a conditional expression very similar to what we did for the released field, because again, lastUpdated might be an empty string. We're going to rename the lastupdated no capital U to last updated with a capital U. But, if lastupdated, the current value is not equal to the empty string, we're going to parse the time stamp out of it. Now, we're going to use dateFromString again and again remember the dateFromString operator is available only in MongoDB 36 and later. And we're specifying using a field path expression that we want to parse the current value of lastupdated. But, we're also supplying an additional parameter to the dateFromString operator and that is specifying the timezone. Here, I'm simply specifying that it should use New York time or US Eastern Time. Now, there's one additional complicating factor here and that is due to this little bit of extra data here after the dot. And it's not so much the fact that there's a little bit of extra data here after a dot, it's the number of digits that are here, that's really causing us a problem. But, the fact is we don't care about milliseconds, down to the second is good enough. But in its current form, dateFromString will not be able to parse this because the format does not match its expectations. So I need to do a little bit of pre-processing on this data. And I'm doing that here with the stage I'm introducing just before the project. So here what we're going to do is split on that dot that we see in those values. And then we're going to use an operator we've not seen yet called arrayElemAt. ArrayElemAt will select the value stored at a particular index within an array. And here, what we're doing is as the value to arrayElemAt, we're specifying that we're going to use as our array, the array that we get by splitting on the dot character for the value of lastUpdated. So here, this portion here, will be the zeroth element in that array, and this would be the element at index 1. ArrayElemAt expects as a value, an array. The first value in the array should be the array we want to index into. And the second value should be the index we're interested in within that array or the element we're interested in. Again, we're interested in the element at index 0. And the semantics of this then will be such that lastupdated will be added to every document that flows through this stage and it will have as its value the string that's found at index 0, after we split the current value of lastupdated, that string value. Okay. So one thing I didn't mention about addFields when we talked about it before, is that if the field already exists, it will simply replace it. So what we're doing here is replacing the existing lastupdated field, with a string that is just the left side essentially of a split that happens at this dot, for every document in the collection. This is actually a good place to call out two things. One is that as you're building up an aggregation pipeline, it's a really good idea to test each stage individually. So, what I did as I was building this particular pipeline, was to end the pipeline here at this addFields stage, to make sure that the data was being split and created properly so that it would be passed as expected into the project stage. I encourage you to do that as an exercise for yourself in testing this a little bit and in getting familiar with the aggregation framework. That brings me to the second thing I'd like to draw your attention to. And that is that, we're not doing a comprehensive deep dive of the aggregation framework here in this particular course. What I'm doing here is trying to whet your appetite with what's possible here and we'll do a deeper dive in the second course in this specialization. Undoubtedly, you'd like to know a little bit more about the add framework. So, I encourage you to take a look at the MongoDB documentation. In particular, this aggregation pipeline quick reference. It's linked in the lecture notes for this lesson and here you can find information on all of the operators and expressions that we've been using throughout these examples. Here for example, are the array expressions and the arrayElemAt operator is listed first. So returning to our example, again we're taking the output of the project stage, which now is going to parse the date from both released and the lastUpdated. And, we are writing that data into the movies_scratch collection. So let's go ahead and run this. And if we refresh in compass, we'll see that now for lastUpdated, we do in fact have a real time stamp, not just a string representation of a date time.