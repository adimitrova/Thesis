1
00:00:00,000 --> 00:00:02,700
So continuing with the reshaping that we're doing here,

2
00:00:02,700 --> 00:00:05,055
as we did with released,

3
00:00:05,055 --> 00:00:09,625
let's parse a time stamp out of the last updated field.

4
00:00:09,625 --> 00:00:11,985
As we look at that field as it currently exists,

5
00:00:11,985 --> 00:00:14,370
we can see that there's a time stamp here,

6
00:00:14,370 --> 00:00:21,170
but it is encoded as a string and it has some extraneous data here.

7
00:00:21,170 --> 00:00:24,255
In fact, that means it doesn't quite

8
00:00:24,255 --> 00:00:29,575
match some of the standard time stamp formatting that we're expecting.

9
00:00:29,575 --> 00:00:31,440
So what we'll do here is using

10
00:00:31,440 --> 00:00:35,888
a conditional expression very similar to what we did for the released field,

11
00:00:35,888 --> 00:00:39,915
because again, lastUpdated might be an empty string.

12
00:00:39,915 --> 00:00:46,980
We're going to rename the lastupdated no capital U to last updated with a capital U.

13
00:00:46,980 --> 00:00:52,545
But, if lastupdated, the current value is not equal to the empty string,

14
00:00:52,545 --> 00:00:54,810
we're going to parse the time stamp out of it.

15
00:00:54,810 --> 00:00:57,615
Now, we're going to use dateFromString again and again remember

16
00:00:57,615 --> 00:01:03,615
the dateFromString operator is available only in MongoDB 36 and later.

17
00:01:03,615 --> 00:01:08,070
And we're specifying using a field path expression that we want

18
00:01:08,070 --> 00:01:13,200
to parse the current value of lastupdated.

19
00:01:13,200 --> 00:01:16,380
But, we're also supplying an additional parameter to

20
00:01:16,380 --> 00:01:20,635
the dateFromString operator and that is specifying the timezone.

21
00:01:20,635 --> 00:01:26,815
Here, I'm simply specifying that it should use New York time or US Eastern Time.

22
00:01:26,815 --> 00:01:30,465
Now, there's one additional complicating factor here and that is

23
00:01:30,465 --> 00:01:34,740
due to this little bit of extra data here after the dot.

24
00:01:34,740 --> 00:01:38,631
And it's not so much the fact that there's a little bit of extra data here after a dot,

25
00:01:38,631 --> 00:01:41,190
it's the number of digits that are here,

26
00:01:41,190 --> 00:01:43,370
that's really causing us a problem.

27
00:01:43,370 --> 00:01:46,605
But, the fact is we don't care about milliseconds,

28
00:01:46,605 --> 00:01:49,230
down to the second is good enough.

29
00:01:49,230 --> 00:01:50,460
But in its current form,

30
00:01:50,460 --> 00:01:53,730
dateFromString will not be able to parse

31
00:01:53,730 --> 00:01:58,050
this because the format does not match its expectations.

32
00:01:58,050 --> 00:02:01,545
So I need to do a little bit of pre-processing on this data.

33
00:02:01,545 --> 00:02:07,800
And I'm doing that here with the stage I'm introducing just before the project.

34
00:02:07,800 --> 00:02:14,130
So here what we're going to do is split on that dot that we see in those values.

35
00:02:14,130 --> 00:02:18,345
And then we're going to use an operator we've not seen yet called arrayElemAt.

36
00:02:18,345 --> 00:02:25,785
ArrayElemAt will select the value stored at a particular index within an array.

37
00:02:25,785 --> 00:02:30,815
And here, what we're doing is as the value to arrayElemAt,

38
00:02:30,815 --> 00:02:36,265
we're specifying that we're going to use as our array,

39
00:02:36,265 --> 00:02:44,110
the array that we get by splitting on the dot character for the value of lastUpdated.

40
00:02:44,110 --> 00:02:48,696
So here, this portion here,

41
00:02:48,696 --> 00:02:50,780
will be the zeroth element in that array,

42
00:02:50,780 --> 00:02:53,645
and this would be the element at index 1.

43
00:02:53,645 --> 00:02:58,445
ArrayElemAt expects as a value, an array.

44
00:02:58,445 --> 00:03:02,685
The first value in the array should be the array we want to index into.

45
00:03:02,685 --> 00:03:05,150
And the second value should be the index we're

46
00:03:05,150 --> 00:03:08,285
interested in within that array or the element we're interested in.

47
00:03:08,285 --> 00:03:11,985
Again, we're interested in the element at index 0.

48
00:03:11,985 --> 00:03:20,305
And the semantics of this then will be such that lastupdated will be added to

49
00:03:20,305 --> 00:03:24,430
every document that flows through this stage and it will have

50
00:03:24,430 --> 00:03:29,600
as its value the string that's found at index 0,

51
00:03:29,600 --> 00:03:34,405
after we split the current value of lastupdated, that string value.

52
00:03:34,405 --> 00:03:38,665
Okay. So one thing I didn't mention about addFields when we talked about it before,

53
00:03:38,665 --> 00:03:40,705
is that if the field already exists,

54
00:03:40,705 --> 00:03:42,550
it will simply replace it.

55
00:03:42,550 --> 00:03:47,884
So what we're doing here is replacing the existing lastupdated field,

56
00:03:47,884 --> 00:03:55,660
with a string that is just the left side essentially of a split that happens at this dot,

57
00:03:55,660 --> 00:03:58,810
for every document in the collection.

58
00:03:58,810 --> 00:04:00,610
This is actually a good place to call out two things.

59
00:04:00,610 --> 00:04:04,060
One is that as you're building up an aggregation pipeline,

60
00:04:04,060 --> 00:04:08,770
it's a really good idea to test each stage individually.

61
00:04:08,770 --> 00:04:12,295
So, what I did as I was building this particular pipeline,

62
00:04:12,295 --> 00:04:17,200
was to end the pipeline here at this addFields stage,

63
00:04:17,200 --> 00:04:20,410
to make sure that the data was being split and created

64
00:04:20,410 --> 00:04:24,970
properly so that it would be passed as expected into the project stage.

65
00:04:24,970 --> 00:04:28,240
I encourage you to do that as an exercise for yourself in testing

66
00:04:28,240 --> 00:04:32,585
this a little bit and in getting familiar with the aggregation framework.

67
00:04:32,585 --> 00:04:35,950
That brings me to the second thing I'd like to draw your attention to.

68
00:04:35,950 --> 00:04:37,780
And that is that,

69
00:04:37,780 --> 00:04:40,420
we're not doing a comprehensive deep dive of

70
00:04:40,420 --> 00:04:45,125
the aggregation framework here in this particular course.

71
00:04:45,125 --> 00:04:48,400
What I'm doing here is trying to whet your appetite with what's possible

72
00:04:48,400 --> 00:04:53,320
here and we'll do a deeper dive in the second course in this specialization.

73
00:04:53,320 --> 00:04:57,700
Undoubtedly, you'd like to know a little bit more about the add framework.

74
00:04:57,700 --> 00:05:02,335
So, I encourage you to take a look at the MongoDB documentation.

75
00:05:02,335 --> 00:05:06,310
In particular, this aggregation pipeline quick reference.

76
00:05:06,310 --> 00:05:12,980
It's linked in the lecture notes for this lesson and here you can find information

77
00:05:12,980 --> 00:05:21,150
on all of the operators and expressions that we've been using throughout these examples.

78
00:05:21,150 --> 00:05:27,635
Here for example, are the array expressions and the arrayElemAt operator is listed first.

79
00:05:27,635 --> 00:05:29,380
So returning to our example,

80
00:05:29,380 --> 00:05:32,365
again we're taking the output of the project stage,

81
00:05:32,365 --> 00:05:37,860
which now is going to parse the date from both released and the lastUpdated.

82
00:05:37,860 --> 00:05:42,610
And, we are writing that data into the movies_scratch collection.

83
00:05:42,610 --> 00:05:45,375
So let's go ahead and run this.

84
00:05:45,375 --> 00:05:48,495
And if we refresh in compass,

85
00:05:48,495 --> 00:05:51,090
we'll see that now for lastUpdated,

86
00:05:51,090 --> 00:05:53,400
we do in fact have a real time stamp,

87
00:05:53,400 --> 00:05:56,130
not just a string representation of a date time.