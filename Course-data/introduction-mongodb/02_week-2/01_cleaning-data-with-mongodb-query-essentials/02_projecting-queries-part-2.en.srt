1
00:00:00,390 --> 00:00:02,920
Okay, so let's take this a step further.

2
00:00:02,920 --> 00:00:08,640
This is exactly the same pipeline that
we looked at in the previous lesson.

3
00:00:08,640 --> 00:00:11,550
The difference is that we're
now going to begin to do

4
00:00:11,550 --> 00:00:15,135
a little bit more sophisticated
work within our project stage.

5
00:00:15,135 --> 00:00:19,390
In order to handle some other problems
with the data in this particular data set.

6
00:00:20,450 --> 00:00:25,660
So here you can see the same pass throughs
and these split operations again.

7
00:00:25,660 --> 00:00:30,140
But for released,
if we take a look at what we have for

8
00:00:30,140 --> 00:00:32,700
values in this collection,
it's just a string.

9
00:00:33,760 --> 00:00:37,540
We can do quite a bit more in terms
of range filters, searching for

10
00:00:37,540 --> 00:00:42,520
all movies released at a particular
time of year, in a given month etcetera,

11
00:00:42,520 --> 00:00:45,420
if we actually convert these to dates.

12
00:00:45,420 --> 00:00:46,970
So that's what we're doing here.

13
00:00:46,970 --> 00:00:48,840
Let me explain this a little bit.

14
00:00:48,840 --> 00:00:53,990
If it wasn't for
the case that values could be empty,

15
00:00:53,990 --> 00:00:55,630
this would be significantly simpler.

16
00:00:55,630 --> 00:00:58,680
We would simply need to use
date from string operator to

17
00:00:58,680 --> 00:01:00,022
parse the date out of the string.

18
00:01:00,022 --> 00:01:03,690
But because we can have empty
strings as the value for

19
00:01:03,690 --> 00:01:06,520
released, we need to
use the cond operator.

20
00:01:07,520 --> 00:01:10,100
Cond is simply a conditional expression.

21
00:01:10,100 --> 00:01:12,780
We have an if, then, and an else.

22
00:01:12,780 --> 00:01:15,790
Because everything is
document based in MongoDB,

23
00:01:15,790 --> 00:01:19,908
we express this using this
document based syntax.

24
00:01:19,908 --> 00:01:24,780
So the cond operator has as
its value a document, and

25
00:01:24,780 --> 00:01:31,236
that document has three keys within
in it: an if, a then and an else.

26
00:01:31,236 --> 00:01:35,160
For if, we specify a conditional
expression, and the conditional expression

27
00:01:35,160 --> 00:01:39,895
we're using here is making use
of this dollar ne operator.

28
00:01:39,895 --> 00:01:43,155
$ne simply means not equal to.

29
00:01:43,155 --> 00:01:48,210
$ne expects an array as its value where
we have two values to be compared.

30
00:01:49,270 --> 00:01:53,760
Here we're using this field path
specifier to get the value for released.

31
00:01:53,760 --> 00:01:59,610
And we're simply saying, if that value
is not equal to the empty string,

32
00:01:59,610 --> 00:02:02,480
then we want to go ahead and
parse the string from it.

33
00:02:02,480 --> 00:02:07,530
Otherwise, just go ahead and
let released equal the empty string.

34
00:02:07,530 --> 00:02:11,000
Let's talk a little bit about the meat
of this particular reshaping,

35
00:02:11,000 --> 00:02:14,125
which is really parsing
the date out of a string.

36
00:02:14,125 --> 00:02:19,410
$dateFromString is an operator
that expects us to specify

37
00:02:20,570 --> 00:02:25,780
the value we want to parse as
an expression that evaluates to a string.

38
00:02:25,780 --> 00:02:28,830
Here we're using a field path specifier,
so

39
00:02:28,830 --> 00:02:31,080
whatever the current value for
released is.

40
00:02:31,080 --> 00:02:33,640
And we have to specify that
as the value for dateString,

41
00:02:33,640 --> 00:02:37,980
there are some other options you
can specify to date from string.

42
00:02:37,980 --> 00:02:39,700
We're not going to talk
about those right now.

43
00:02:39,700 --> 00:02:43,150
But that's why this has
the structure that it does.

44
00:02:43,150 --> 00:02:47,210
The result here is that,
if the expression is true,

45
00:02:48,280 --> 00:02:53,760
then the value that will be assigned
to the release key, in this projection,

46
00:02:54,830 --> 00:02:59,304
is the date value parsed
using the dateFromString

47
00:02:59,304 --> 00:03:04,610
operator from the current string
representation of that date,

48
00:03:04,610 --> 00:03:06,970
which is the current value
of the released field.

49
00:03:08,550 --> 00:03:12,290
Otherwise, we simply make released
have the value of the empty string.

50
00:03:13,320 --> 00:03:18,070
Again, as we build up this reshaping,
we're just looking at the first 100

51
00:03:18,070 --> 00:03:24,000
documents and we are again outputting
to the movies_scratch collection.

52
00:03:24,000 --> 00:03:24,952
So let's run this.

53
00:03:26,459 --> 00:03:29,419
And if we go into Compass and refresh,

54
00:03:29,419 --> 00:03:34,596
we see that now we have a real
timestamp as the value for released for

55
00:03:34,596 --> 00:03:41,180
all documents that actually had some sort
of string representation as their value.

56
00:03:41,180 --> 00:03:42,852
For others,
we'll just have the empty string.

57
00:03:42,852 --> 00:03:46,970
But we can see several here that have had

58
00:03:46,970 --> 00:03:51,520
their released field updated
to have a real time stamp,

59
00:03:51,520 --> 00:03:56,420
which we can then filter on in
a variety of interesting ways.

60
00:03:56,420 --> 00:04:01,120
So that's an example of how we can do
a little clean up with respect to dates.

61
00:04:01,120 --> 00:04:04,760
Now, one other thing that I want to point
out is dateFromString is an aggregation

62
00:04:04,760 --> 00:04:10,350
operator that is only available
in MongoDB 3.6 and later.

63
00:04:10,350 --> 00:04:14,570
So, if you're using an earlier version
of MongoDB in your atlas cluster, or

64
00:04:14,570 --> 00:04:18,840
in say a local installation that you have
created, you'll need to upgrade to MongoDB

65
00:04:18,840 --> 00:04:23,090
3.6 in order to take advantage
of this particular operator.