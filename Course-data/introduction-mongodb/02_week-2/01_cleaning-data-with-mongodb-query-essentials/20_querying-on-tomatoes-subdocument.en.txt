MongoDB allows you to define rich data
types, multi-dimensional data structures that are very similar to object-oriented
programming language objects. That means that we can define
complex objects like arrays with subdocuments embedded or
even fields with just subdocuments. Which in turn, can have complex
data structures with them. In this particular lesson, we are going to
be looking to how to querying on a field of our movies collection, called tomatoes, which corresponds to
Rotten Tomatoes' viewer reviews. And how to use the magic of
the dot notation to explore and express really complex
queries within MongoDB. All right, so we have these documents
with subdocuments in them, but what's so special and what's so great about them? Most relational systems can also
define columns of data type XML or even BLOB, where we can just throw
into it, very complex data structures. The reasoning behind MongoDB
is the ability to actually query within those data structures
without just having a dump of that data in a particular
column in a relational world. Therefore, you can model your data in
such a way that it doesn't restrict the queryability of your application. Now let's see how to use this in action,
using our mflix application. In this Jupyter notebook, that you have accessed through
the handouts of this lesson, you will have a way of expressing those
same queries against our mflix database. Now, first step would be to just
import the necessary modules. In this case,
I'm going to use pymongo and pprint. Second step would be to express
our connection string and the way to connect using
pymongo.MongoClient. Now, don't forget to get
this particular URI. You can just go to your Atlas cluster,
go to Connect. Say that you want to connect
from your application, and basically copy the URI in place and
replace the placeholder for your password by the password of our user
that in our case is analytics-password. I've done that due diligence myself,
and I can just pure and simply connect. No errors, everything seems to be good. Now to get started in analyzing
exactly how the substructures of our documents work,
let's have a look to the Titanic movie. Now I know there's some duplicates here,
and we'll take care of this later. So therefore, I'm going to just find
one where the title is Titanic. As we can see here, we have very,
very complex data structures and lots of embed fields in the arrays and
all sorts of different Data types here that we might want
to treat in a particular fashion. Or even just query on those fields
as we would query our normal, let's say, single field root level fields. But what's interesting about this is that
we can isolate it a little bit in python. So let's look into tomatoes. Now again tomatoes is basically a field that condenses the information of rotten
tomatoes for this particular movie and as we can see here we have a very
very rich internal data structure. So tomatoes itself is an field, it has other fields in it which
we can use to express queries. Those in that field themselves. Some of them are from to daytimes,
to strings and so forth. So can use this data structure to
do some very interesting queries. Going a little bit deeper, I can see that
tomatoes.viewer has a couple of other embedded fields themselves,
meter, numReviews, and rating. Now if I would like to get all the movies
that have the same rating as this particular Titanic movie, I can just use
the Titanic tomatoes.viewer.rating field, put its value into variable
that I'm going to call rating, which in this case is 3.6. And use that value here to
express a different query. Now, I'm going to look
into all the different movies that have the field
tomatoes viewer rating. Again, a subfield inside of another subfield with the same
value from previous movie. And I'm going to print only the title, so it doesn't mess up with
my view screen here. Let's pause just for a second and
look into this dot notation. What is this anyway? The moment we use the dot notation to
access elements of a complex object, arrays or sub documents or
embedded documents. They are embedded within
the documents of a collection. For example here, movies, we have that for
accessing a field within tomatoes. And within viewer we would need
to use this dot connecting those different fields. If we look back into the structure
of this particular document, we see that we have several different data
types or fields in this case that could use the same dot notation for us to
access the embed information within it. Tomatoes is one of the most complex ones. You could have writers, which has an array
and we can access the elements or indexes of those arrays to
express queries as well. You always using the dot notation. So every time we want or
need to access fields, within sub documents or within arrays,
we will be using the dot notation. Now the dot notation is not only used for the find query or for
the filter that we express in our queries. Can also be used for
our sorts, meaning that, we can sort on any embed
field that we wish. In this particular case, we are going
to be using tomatoes.lastupdated. We are going to be sorting the results
by the ASCENDING last update. Once we do that,
we can see that we have our title, rampage that has been
last updated on 2012. Then the following is The Suspect,
in 2014, and so forth. These capability shows us that
no matter how deep our field is, if we need to express a query or
even a sort condition for our Queriability of our application, Mongo
DB allows us to do that using the dot notation explicitly to get the type of
queryability that our application demands, and this is how you can express
queries using embedded fields.