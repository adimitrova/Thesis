Viewing the new collection we've created here in compass, let's search for movies that use the Korean language. Note that we need to use the key languages. With this filter applied we have 542 matching documents. Let's take a look at some of the matching documents. The first has both English and Korean listed for languages and if we scroll down a bit we can find a movie that has just Korean listed as the language. And if we scroll down even further this movie lists five languages including Latin. So let's stop and think about what's happening here a little bit. First, we've simply filtered on the movie's collection using exactly the same syntax as we would if languages were a scalar field, for example, a field containing string values rather than array values. The difference is that now we're not relying on a string representation of a list of languages. We can take full advantage of MongoDB support for array valued fields. If searching for all movies that list a single language regardless of what other languages are listed, we can use the syntax that we've employed here. If we'd like to filter for movies that use both Korean and say English we can do that using the dollar all operator. When applied this filter will limit results to those movies that list both Korean and English among their languages as we see here. The all operator filters for documents with an array as the value for the key specified that contain all of the elements listed as the value for the all operator itself. So the semantics of this are, find me all documents where for the languages key, there is an array containing all of the elements listed here in this array. These elements can occur in any position or order in the array field but they must each be present. The Pymongo driver supports the entire MongoDB query language so we can do exactly the same thing in Python. Here's an example. Note that here we're specifying a filter with this dictionary and then passing this dictionary to the find method. And this should actually be find called on the movie scratch collection because that's the collection we've been looking at here in compass. And if we run this we see that the results are now limited to only those movies using the languages we've specified. Movies that also use other languages will be included but every movie returned uses both Korean and English. The semantics of the language is listed in this data set are such that the languages are listed in decreasing order based on the frequency with which they are used in each movie. If we want to do an exact match on movies that use Korean and English, with Korean being the language more heavily used, we can do an exact match on the array containing these two elements, Korean first followed by English. Note that we're not using the dollar all operator here. What this filter means is find the all documents where for the languages key, the value is precisely this array, Korean listed first as the zeroth element and English listed second as the element at index one. Applying this filter in compass we can see that there are 27 matching documents and that in fact for each of them, the value for languages is an array with Korean as the element at index zero and English as the element at index one. If we flip this and look instead for movies where English is listed first and Korean second for the languages field, we find 23 documents. For these types of queries MongoDB is looking for an exact match against the key in question for the array we've specified as the value in the filter. With respect to array field, one last thing you might be interested in doing is filtering for documents that have a specific value in a particular slot within an array. For example, we might like to filter for all documents that list Korean as the primary language for the film regardless of what other languages are listed. We can do that specifying the array index we want to match against using dot notation. In compass this looks like this. As we scroll through the results, we see that every movie lists Korean first. We can do the same thing in Python though we'll need to wrap the key four or filter in quotes so that it's a valid dictionary. Now it's a little hard to read this to find just the languages field so let's limit the results to just provide the languages field. We can do that using a projection and pass that to the find method. As with most MongoDB query language syntax, we define a projection as a document. The semantics of this projection are that only the languages field for any matching document should be returned together with the title to provide a little context. Find will accept the dictionary as its second argument and interprets this as a projection specification. In projections we want to use one for all fields to explicitly include and zero for any fields you want to explicitly exclude. If we only explicitly include fields as we've done here, MongoDB assumes we want to exclude all others. Running this we see now that our search results are much more readable. However, I wasn't being precise when I said that project would return only the languages and title fields. The underscore ID field is special because it is the unique identifier for all documents in a collection. To eliminate the underscore ID field from a projection, we must explicitly exclude it. Let's do this and then run again. There. Now we have just the title and languages field for each result document. In addition to making results much more human readable, projecting fields means that the other fields are not even returned from the server. Each document here represents an entire document matched by our filter but because of the projection we've specified the server will only return the title and languages fields rather than all of the data for each matching document. So we can use projection to significantly reduce the amount of data that gets transmitted between our client and the database server. That's a pretty good overview of how to filter on array fields in MongoDB and a brief introduction to projections. We'll do a lot more work with both topics in this course in other lessons.