1
00:00:00,000 --> 00:00:04,150
In this lesson, we're going to talk about how we can graph data with MongoDB.

2
00:00:04,150 --> 00:00:07,140
Throughout this course, we've spent time discussing the power of

3
00:00:07,140 --> 00:00:10,825
MongoDB's flexible data model as expressive query language.

4
00:00:10,825 --> 00:00:13,830
This lesson is going to be focused on how to use MongoDB with a tool commonly

5
00:00:13,830 --> 00:00:16,958
used by idea scientists and analysts, matplotlib.

6
00:00:16,958 --> 00:00:20,865
Specifically, we're going to look at how to use matplotlib to create scatter plots,

7
00:00:20,865 --> 00:00:22,860
3D plots and box,

8
00:00:22,860 --> 00:00:25,950
also commonly referred to as box and whisker plots,

9
00:00:25,950 --> 00:00:28,505
using matplotlib with MongoDB.

10
00:00:28,505 --> 00:00:32,560
Before we get started talking about how to create each of these plots,

11
00:00:32,560 --> 00:00:36,195
first we need to talk about how we pass data to matplotlib.

12
00:00:36,195 --> 00:00:38,005
When graphing with matplotlib,

13
00:00:38,005 --> 00:00:42,720
it almost always expects the data to be passed in via one or more arrays.

14
00:00:42,720 --> 00:00:47,040
So, for this example, here I've created an array with values 1-5.

15
00:00:47,040 --> 00:00:49,440
And then, I take each of those values and,

16
00:00:49,440 --> 00:00:51,360
using list comprehensions here,

17
00:00:51,360 --> 00:00:53,235
I square each value.

18
00:00:53,235 --> 00:00:55,500
And we can go ahead and print this to see what it looks like,

19
00:00:55,500 --> 00:00:56,639
and as you expect,, we see one, two, three,

20
00:00:56,639 --> 00:00:58,158
four, five and one.

21
00:00:58,158 --> 00:00:59,995
four, nine, 16, 25.

22
00:00:59,995 --> 00:01:02,355
And how do you pass these arrays to matplotlib?

23
00:01:02,355 --> 00:01:04,980
It's pretty easy if we want to create a scatter plot.

24
00:01:04,980 --> 00:01:07,440
This is a common convention to go ahead and clear figure,

25
00:01:07,440 --> 00:01:11,865
we then go ahead and set up our subplots so we can actually access our axes.

26
00:01:11,865 --> 00:01:15,525
And then with our ax, we're able to use the scatter method,

27
00:01:15,525 --> 00:01:17,228
passing in our two arrays,

28
00:01:17,228 --> 00:01:19,615
and then finally, we go ahead and show the plot.

29
00:01:19,615 --> 00:01:21,720
And when I scroll down here, you can see,

30
00:01:21,720 --> 00:01:25,940
matplotlib figures out these ranges of values on both axes and plots our coordinates.

31
00:01:25,940 --> 00:01:27,180
As you can see,

32
00:01:27,180 --> 00:01:29,460
it forms a nice little X squared curve.

33
00:01:29,460 --> 00:01:32,590
And, we can do this exact same thing for data stored in MongoDB.

34
00:01:32,590 --> 00:01:34,675
We go ahead and import pymongo,

35
00:01:34,675 --> 00:01:36,245
create our cluster string,

36
00:01:36,245 --> 00:01:37,785
connect to our cluster,

37
00:01:37,785 --> 00:01:40,140
and then we can go ahead and write a query.

38
00:01:40,140 --> 00:01:43,890
Now in this example, I want to plot the length of a movie,

39
00:01:43,890 --> 00:01:46,680
it's runtime against its rating.

40
00:01:46,680 --> 00:01:51,735
So, let's create a query where we return only documents that have both of these values.

41
00:01:51,735 --> 00:01:55,165
And then I'm going to go ahead and just project out just those two fields.

42
00:01:55,165 --> 00:01:56,715
We'll go ahead and create these variables,

43
00:01:56,715 --> 00:01:59,360
and then run the query, and turn into a list.

44
00:01:59,360 --> 00:02:02,100
And when we print this, as you can see,

45
00:02:02,100 --> 00:02:04,140
when we print this the first time, you can see that we get

46
00:02:04,140 --> 00:02:06,705
both our metacritic and runtime values.

47
00:02:06,705 --> 00:02:08,830
However, like I demonstrated earlier,

48
00:02:08,830 --> 00:02:13,433
matplotlib expects a separate array for each value,

49
00:02:13,433 --> 00:02:16,025
not a single array or pairs of values.

50
00:02:16,025 --> 00:02:21,120
To do this, we're just going to iterate over each value in our RM array,

51
00:02:21,120 --> 00:02:22,980
pulling out the runtime.

52
00:02:22,980 --> 00:02:25,886
As you can see, this is now just an array of runtimes,

53
00:02:25,886 --> 00:02:28,590
and similarly, we're going to do the same thing for the ratings.

54
00:02:28,590 --> 00:02:31,170
So now that we have two arrays,

55
00:02:31,170 --> 00:02:34,099
each for one of the values that we're comparing,

56
00:02:34,099 --> 00:02:36,705
we can now go ahead and just pass this matplotlib.

57
00:02:36,705 --> 00:02:39,600
You can see that I'm using some additional parameters now.

58
00:02:39,600 --> 00:02:40,950
I'm using an Alpha,

59
00:02:40,950 --> 00:02:44,445
so that each point on the plot isn't fully opaque,

60
00:02:44,445 --> 00:02:47,523
so this way we can kind of see where lots of points overlap.

61
00:02:47,523 --> 00:02:50,525
And then also, I'm giving a title and labeling my axes.

62
00:02:50,525 --> 00:02:51,795
And when we plot this,

63
00:02:51,795 --> 00:02:54,690
as you can see here, there is a bit of correlation.

64
00:02:54,690 --> 00:02:59,605
Movies that are very long in runtime seem to do pretty well on ratings.

65
00:02:59,605 --> 00:03:04,605
There are very few points where we have very long movies that have low ratings,

66
00:03:04,605 --> 00:03:06,370
which is kind of an interesting correlation.

67
00:03:06,370 --> 00:03:08,415
But I don't want to spend too much time analyzing this,

68
00:03:08,415 --> 00:03:11,895
I want to kind of show you more of the functionalities that you can do with matplotlib.

69
00:03:11,895 --> 00:03:17,485
The same process can be applied to 3D plots where we want to compare three values.

70
00:03:17,485 --> 00:03:21,015
In this case, we're going to continue to plot the same variables as before,

71
00:03:21,015 --> 00:03:22,440
but we're also going to see if there's a correlation

72
00:03:22,440 --> 00:03:25,140
between year and either of these variables.

73
00:03:25,140 --> 00:03:28,200
So first, we're going to go ahead and import the Axes3D module,

74
00:03:28,200 --> 00:03:29,575
go ahead and clear our queries,

75
00:03:29,575 --> 00:03:31,770
this time I'm making sure that not only does

76
00:03:31,770 --> 00:03:34,410
year exist but also that it's an integer, and then, of course,

77
00:03:34,410 --> 00:03:36,145
I'm going to project out those three values,

78
00:03:36,145 --> 00:03:38,400
going to go ahead and execute my query,

79
00:03:38,400 --> 00:03:39,840
turning it into a list of values.

80
00:03:39,840 --> 00:03:41,000
And just like before,

81
00:03:41,000 --> 00:03:44,540
we're going to use list comprehensions to pull out each variable,

82
00:03:44,540 --> 00:03:46,170
and very similarly before,

83
00:03:46,170 --> 00:03:49,485
the syntax is a little bit different now because we're creating a 3D plot but,

84
00:03:49,485 --> 00:03:51,360
as you can see, we're really just doing the same things,

85
00:03:51,360 --> 00:03:53,685
we're clearing our figure, getting our figure,

86
00:03:53,685 --> 00:03:56,535
getting our ax, using a scatter plot function,

87
00:03:56,535 --> 00:03:57,905
and then setting our labels.

88
00:03:57,905 --> 00:03:59,865
The key difference here being that we had to use

89
00:03:59,865 --> 00:04:04,050
add_subplot and passing in a 3D projection parameter.

90
00:04:04,050 --> 00:04:06,510
And when we go ahead and plot this, as you can see,

91
00:04:06,510 --> 00:04:08,443
we now have a cooler 3D plot,

92
00:04:08,443 --> 00:04:13,150
and what we're really seeing here is that there aren't very many years of data.

93
00:04:13,150 --> 00:04:17,070
We have movies that go all the way down to 1940, but as you can see,

94
00:04:17,070 --> 00:04:21,840
we don't really have any runtime data or any rating data for these values.

95
00:04:21,840 --> 00:04:25,050
Finally, let's talk about one more plot which is the box plot,

96
00:04:25,050 --> 00:04:28,395
also commonly referred to as the box and whisker plot,

97
00:04:28,395 --> 00:04:30,180
because you have this little box and these lines that

98
00:04:30,180 --> 00:04:32,505
come off that kind of look like cat whiskers.

99
00:04:32,505 --> 00:04:36,060
Box plots are used to visualize the minimum, maximum,

100
00:04:36,060 --> 00:04:41,245
median, and first and third quartiles for a given set of values.

101
00:04:41,245 --> 00:04:43,050
In our case, we're going to plot several of

102
00:04:43,050 --> 00:04:46,650
these box plots representing each day in a week.

103
00:04:46,650 --> 00:04:50,370
Specifically, we're going to visualize the distribution of the hours of

104
00:04:50,370 --> 00:04:55,320
days that people watch movies on mflix across each day of the week.

105
00:04:55,320 --> 00:04:58,145
To do this, we're going to use this watching ping's dataset.

106
00:04:58,145 --> 00:05:00,850
So, imagine for a moment that if every 15

107
00:05:00,850 --> 00:05:04,565
seconds that someone is watching a movie on mflix, we recorded that.

108
00:05:04,565 --> 00:05:06,675
And that's what each of these documents kind of looks like.

109
00:05:06,675 --> 00:05:09,355
It's a reference to which video they were watching,

110
00:05:09,355 --> 00:05:11,330
the user ID of the person so,

111
00:05:11,330 --> 00:05:15,580
who was watching, and then a time stamp for when they were watching.

112
00:05:15,580 --> 00:05:18,050
And so, since we send this every 15 seconds,

113
00:05:18,050 --> 00:05:19,855
that someone is watching a movie,

114
00:05:19,855 --> 00:05:21,820
we can now use this data to visualize

115
00:05:21,820 --> 00:05:25,475
a distribution of what hour of the day people are watching movies.

116
00:05:25,475 --> 00:05:28,000
But first, we're going to transform our data a little bit.

117
00:05:28,000 --> 00:05:30,070
So, here we use the aggregation framework.

118
00:05:30,070 --> 00:05:32,920
We're first going to take a sample of 50,000 documents,

119
00:05:32,920 --> 00:05:35,350
we're going to add some fields that we know which day of

120
00:05:35,350 --> 00:05:38,360
the week and which hour of the day they were watching, and then finally,

121
00:05:38,360 --> 00:05:40,585
we are going to group by day of the week,

122
00:05:40,585 --> 00:05:44,040
pushing each document into an array field called pings.

123
00:05:44,040 --> 00:05:45,820
And finally, we're going to sort by ID,

124
00:05:45,820 --> 00:05:47,485
which is the day of the week,

125
00:05:47,485 --> 00:05:51,095
so that Sunday is first and Saturday is last.

126
00:05:51,095 --> 00:05:54,535
So, what this means is that this cursor is going to return seven documents,

127
00:05:54,535 --> 00:05:57,850
each document is going to have an array field called pings that's

128
00:05:57,850 --> 00:06:01,405
going to contain a sample of the pings for that day of the week.

129
00:06:01,405 --> 00:06:03,895
But what we really want is an array of arrays,

130
00:06:03,895 --> 00:06:08,550
not an array of dictionaries of array of dictionaries.

131
00:06:08,550 --> 00:06:11,905
So, let's go ahead and run this query and then we can fix

132
00:06:11,905 --> 00:06:16,570
our data a little bit by pulling out our array of pings,

133
00:06:16,570 --> 00:06:20,380
and now that we have an array of documents,

134
00:06:20,380 --> 00:06:22,450
we want to get to an array of arrays.

135
00:06:22,450 --> 00:06:25,030
So, now we can really just pull out the hour of the day

136
00:06:25,030 --> 00:06:27,945
for each pings. And now we have that matrix.

137
00:06:27,945 --> 00:06:30,730
We now have an array where each entry is

138
00:06:30,730 --> 00:06:34,940
another array containing the hourOfDay for each ping.

139
00:06:34,940 --> 00:06:38,170
So, the outer array is the day of the week,

140
00:06:38,170 --> 00:06:41,320
and the inner array is the hour of the day.

141
00:06:41,320 --> 00:06:46,040
We can now take this matrix and very simply pass it to the box plot function.

142
00:06:46,040 --> 00:06:49,945
And as you can see, we now have seven box plots,

143
00:06:49,945 --> 00:06:52,210
each representing a day of the week.

144
00:06:52,210 --> 00:06:54,190
And then it kind of makes sense, there's more people watching

145
00:06:54,190 --> 00:06:56,680
movies on the weekends on average,

146
00:06:56,680 --> 00:06:59,420
but people are still watching a lot of movies during the week.

147
00:06:59,420 --> 00:07:03,210
And as you can see, people watch movies later in the day on the weekends.

148
00:07:03,210 --> 00:07:05,250
There's lots of people watching movies late at night.

149
00:07:05,250 --> 00:07:07,595
These little circles are outliers in

150
00:07:07,595 --> 00:07:10,730
our data and we don't really see any of these during the week.

151
00:07:10,730 --> 00:07:13,660
And moreover, people seem to be watching movies later

152
00:07:13,660 --> 00:07:17,150
in the day on average relative to during the week.

153
00:07:17,150 --> 00:07:19,870
So to recap, we saw how we can create each of

154
00:07:19,870 --> 00:07:23,905
these different kinds of plots using matplotlib in MongoDB.

155
00:07:23,905 --> 00:07:26,435
It's very easy to get the information we want out in MongoDB,

156
00:07:26,435 --> 00:07:28,930
it just requires a little bit of transformation in order to make it

157
00:07:28,930 --> 00:07:31,750
work well with matplotlib to get the..