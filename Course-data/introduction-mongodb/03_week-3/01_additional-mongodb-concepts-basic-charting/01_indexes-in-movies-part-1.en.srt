1
00:00:00,000 --> 00:00:06,255
Our Mflix application allows us to do a lot of different things including listing,

2
00:00:06,255 --> 00:00:08,888
for example, the movies of our catalog.

3
00:00:08,888 --> 00:00:13,590
Now, this means that we perform a couple of queries to the database.

4
00:00:13,590 --> 00:00:17,520
For example, we have the query that allows us to click

5
00:00:17,520 --> 00:00:22,510
on a particular movie and go to its detail page, which is great.

6
00:00:22,510 --> 00:00:29,190
The query that allows us to do that is the get_movie here that basically sets a query

7
00:00:29,190 --> 00:00:32,655
that looks for its _id based on some

8
00:00:32,655 --> 00:00:37,230
_id that we know and we pass along and get back the movie details.

9
00:00:37,230 --> 00:00:38,700
That's all great and fine,

10
00:00:38,700 --> 00:00:41,745
but there's other functionality like, for example,

11
00:00:41,745 --> 00:00:44,880
if we want to find all the Titanic movies,

12
00:00:44,880 --> 00:00:47,960
you can search and it finds it for us.

13
00:00:47,960 --> 00:00:52,650
So all the movies that have the word Titanic somewhere either in the title but

14
00:00:52,650 --> 00:00:57,710
also not that much like Titan and Clash of Titans.

15
00:00:57,710 --> 00:01:00,165
Why is this related with Titanic?

16
00:01:00,165 --> 00:01:03,145
How does MongoDB know about that?

17
00:01:03,145 --> 00:01:05,745
To answer that and other questions,

18
00:01:05,745 --> 00:01:07,755
we can use indexes.

19
00:01:07,755 --> 00:01:09,180
In particular in this lesson,

20
00:01:09,180 --> 00:01:13,555
we are going to look into indexes present in the movies collection.

21
00:01:13,555 --> 00:01:18,720
But before we go and jump directly into the different index types that MongoDB supports,

22
00:01:18,720 --> 00:01:24,180
it is important for you to realize that indexes are special data structures used

23
00:01:24,180 --> 00:01:29,580
by databases including MongoDB that allows us to do some enhanced functionality like,

24
00:01:29,580 --> 00:01:34,040
for example, making our queries more efficient and faster.

25
00:01:34,040 --> 00:01:35,880
In MongoDB in particular, we have

26
00:01:35,880 --> 00:01:38,910
other functionality that is also supported by indexes like,

27
00:01:38,910 --> 00:01:43,800
for example, the geospatial capabilities and the text indexes.

28
00:01:43,800 --> 00:01:48,765
Now, to help us out uncover the indexes in movies, we have,

29
00:01:48,765 --> 00:01:51,975
as part of this lesson and part of the material for this lesson,

30
00:01:51,975 --> 00:01:55,255
the indexes on movies, Jupyter notebook.

31
00:01:55,255 --> 00:01:57,885
Now, as usual, what we need to do is

32
00:01:57,885 --> 00:02:01,380
basically initialize by importing the necessary modules,

33
00:02:01,380 --> 00:02:04,350
connect to our Atlas accounts,

34
00:02:04,350 --> 00:02:06,205
and provide in the URI.

35
00:02:06,205 --> 00:02:08,610
As you can see here, we are able to connect,

36
00:02:08,610 --> 00:02:11,520
no errors, and we have a database object.

37
00:02:11,520 --> 00:02:15,555
Fantastic. But what we are interested on knowing is,

38
00:02:15,555 --> 00:02:17,835
what type of indexes do we have?

39
00:02:17,835 --> 00:02:20,265
Now, this method here,

40
00:02:20,265 --> 00:02:23,700
movies.index_information provides us back with

41
00:02:23,700 --> 00:02:27,700
a list of the existing indexes for this collection.

42
00:02:27,700 --> 00:02:34,350
In this example here, we have four _id_ which is the primary key index of our collection.

43
00:02:34,350 --> 00:02:36,360
And then, we have three other indexes.

44
00:02:36,360 --> 00:02:37,920
These are secondary indexes,

45
00:02:37,920 --> 00:02:39,390
indexes that the user,

46
00:02:39,390 --> 00:02:41,871
in our case, in our application Mflix,

47
00:02:41,871 --> 00:02:44,670
created to support its queries.

48
00:02:44,670 --> 00:02:47,790
So let's have a look into detail in a couple of them.

49
00:02:47,790 --> 00:02:53,100
Now, the nomenclature used by MongoDB to name the indexes is as follows.

50
00:02:53,100 --> 00:02:55,035
We're going to have the index fields,

51
00:02:55,035 --> 00:02:58,545
then we're going to have _id and a value,

52
00:02:58,545 --> 00:03:00,270
either 1 or -1,

53
00:03:00,270 --> 00:03:05,525
telling us if the field itself is sort of ascending or descending.

54
00:03:05,525 --> 00:03:09,060
And if it's an index that spans over more than one field,

55
00:03:09,060 --> 00:03:12,405
like in this case, tomatoes.viewer.numReviews,

56
00:03:12,405 --> 00:03:14,965
is a embedded field,

57
00:03:14,965 --> 00:03:16,810
and it's sorted descending,

58
00:03:16,810 --> 00:03:20,820
where the sign -1 will tell us just that.

59
00:03:20,820 --> 00:03:24,420
And then, you have these keys that are exactly that translation.

60
00:03:24,420 --> 00:03:30,660
The key genres 1 and tomatoes.viewer.numReviews, -1.

61
00:03:30,660 --> 00:03:34,000
All indexes in MongoDB follow that nomenclature,

62
00:03:34,000 --> 00:03:35,265
but you can set,

63
00:03:35,265 --> 00:03:37,530
at creation time, a different name.

64
00:03:37,530 --> 00:03:41,230
In this case, we've been lazy and let's MongoDB do it's magic.

65
00:03:41,230 --> 00:03:43,995
Now, something very interesting about MongoDB is,

66
00:03:43,995 --> 00:03:49,425
regardless if it is a root-level field like genres,

67
00:03:49,425 --> 00:03:55,145
or even a very nested embedded field like tomatoes.viewer.numReviews,

68
00:03:55,145 --> 00:04:00,375
we can create different types of indexes that span across those different fields,

69
00:04:00,375 --> 00:04:03,865
no matter where they are placed inside of the document.

70
00:04:03,865 --> 00:04:06,370
In this particular case, this is a compound index.

71
00:04:06,370 --> 00:04:09,180
Compound index stands for an index that spans

72
00:04:09,180 --> 00:04:13,015
across different fields inside your documents.

73
00:04:13,015 --> 00:04:17,970
So the combination of those two values on these fields will generate an index,

74
00:04:17,970 --> 00:04:20,685
a data structure that will map those two together,

75
00:04:20,685 --> 00:04:28,450
so we can fastly access all queries that inside of genres and numReviews on tomatoes.

76
00:04:28,450 --> 00:04:30,690
Now, although indexes are very cool,

77
00:04:30,690 --> 00:04:34,050
and they are used to enhance our reads and

78
00:04:34,050 --> 00:04:37,290
making sure that we have the combinations needed to, for example,

79
00:04:37,290 --> 00:04:40,580
do efficient sorts, it is important to raise to

80
00:04:40,580 --> 00:04:44,205
your attention that the fact that we have indexes,

81
00:04:44,205 --> 00:04:46,170
or the more indexes we have,

82
00:04:46,170 --> 00:04:51,990
the slower our rides on the collection that supports those indexes will become.

83
00:04:51,990 --> 00:04:57,353
There's also a max number of indexes which is 64 per collection in MongoDB,

84
00:04:57,353 --> 00:05:00,540
so be careful about the number of indexes because they will have