1
00:00:00,000 --> 00:00:03,210
Okay, before we do anything in this course,

2
00:00:03,210 --> 00:00:11,210
we need to understand what the MongoDB document model really is.

3
00:00:11,210 --> 00:00:12,865
If you're familiar with JSON,

4
00:00:12,865 --> 00:00:19,150
JSON makes a great mental model for what records in MongoDB look like.

5
00:00:19,150 --> 00:00:21,430
In a relational database,

6
00:00:21,430 --> 00:00:25,030
you simply store rows in a table,

7
00:00:25,030 --> 00:00:26,315
and each row is a record.

8
00:00:26,315 --> 00:00:29,005
MongoDB is a document database,

9
00:00:29,005 --> 00:00:32,230
and the type of record that's stored in MongoDB,

10
00:00:32,230 --> 00:00:36,880
or a document, is a hierarchical data structure that matches the type of

11
00:00:36,880 --> 00:00:41,850
data structure you'll see in high level programming languages like Python.

12
00:00:41,850 --> 00:00:45,325
You can think of MongoDB as storing JSON documents,

13
00:00:45,325 --> 00:00:47,065
so if you're familiar with JSON,

14
00:00:47,065 --> 00:00:50,080
you'll be very comfortable with what's possible in

15
00:00:50,080 --> 00:00:53,313
terms of a structure for documents in MongoDB.

16
00:00:53,313 --> 00:00:57,210
A MongoDB document consists of fields.

17
00:00:57,210 --> 00:01:00,425
Each field has a key and a value.

18
00:01:00,425 --> 00:01:01,945
So here, these are keys,

19
00:01:01,945 --> 00:01:03,640
and these are values.

20
00:01:03,640 --> 00:01:08,950
Where things get interesting is that values can be integers,

21
00:01:08,950 --> 00:01:10,150
they can be strings,

22
00:01:10,150 --> 00:01:12,535
they can be floating point numbers,

23
00:01:12,535 --> 00:01:16,690
but they can also be arrays, embedded documents,

24
00:01:16,690 --> 00:01:22,485
or documents, or arrays that contain embedded documents.

25
00:01:22,485 --> 00:01:28,240
There are essentially three different structures that values in MongoDB can take on.

26
00:01:28,240 --> 00:01:30,160
Those are scalar values such as an integer,

27
00:01:30,160 --> 00:01:31,990
or floating point number, or string.

28
00:01:31,990 --> 00:01:35,115
Dates would be another type of scalar value.

29
00:01:35,115 --> 00:01:38,110
Then there are arrays, and finally,

30
00:01:38,110 --> 00:01:40,470
as values, you can have documents,

31
00:01:40,470 --> 00:01:42,525
here's another example here.

32
00:01:42,525 --> 00:01:47,315
The idea here is that MongoDB allows application developers

33
00:01:47,315 --> 00:01:53,300
to model their data in a way that makes the most sense for an application.

34
00:01:53,300 --> 00:01:56,885
Here, we have an example drawn from the e-commerce space,

35
00:01:56,885 --> 00:02:00,365
and this data is modeled so that reads

36
00:02:00,365 --> 00:02:04,085
and writes to the database are as efficient as possible.

37
00:02:04,085 --> 00:02:06,200
As a data scientist,

38
00:02:06,200 --> 00:02:12,125
you will both have to work with application data that is stored in a MongoDB database,

39
00:02:12,125 --> 00:02:15,520
especially with the increasing popularity of MongoDB.

40
00:02:15,520 --> 00:02:20,810
But there are also advantages as a data scientist in storing your data in MongoDB and

41
00:02:20,810 --> 00:02:27,465
those advantages align pretty closely with the reason why developers use MongoDB.

42
00:02:27,465 --> 00:02:29,600
You have the ability to interact with

43
00:02:29,600 --> 00:02:33,995
the database in a much more efficient manner than you can with

44
00:02:33,995 --> 00:02:37,430
a relational database because we can construct

45
00:02:37,430 --> 00:02:41,285
complex structures like this and the MongoDB query language,

46
00:02:41,285 --> 00:02:45,230
secondary indexes, and built-in analytics tools such as

47
00:02:45,230 --> 00:02:50,105
the MongoDB aggregation framework all support these data models.

48
00:02:50,105 --> 00:02:54,590
So here we have an example that represents a particular type of shoe,

49
00:02:54,590 --> 00:02:58,820
and what's interesting here is that we're able to represent all of

50
00:02:58,820 --> 00:03:03,915
the attributes of the shoe and all of the variants for the shoe.

51
00:03:03,915 --> 00:03:06,860
So what we mean by variants here are all

52
00:03:06,860 --> 00:03:10,190
of the different choices you can make as a consumer for the shoe.

53
00:03:10,190 --> 00:03:13,340
So, size, color, and so on,

54
00:03:13,340 --> 00:03:16,580
and the way this data model is designed,

55
00:03:16,580 --> 00:03:21,365
we can construct an index that would allow us to query for

56
00:03:21,365 --> 00:03:27,200
all shoes for which we actually had a size six in orange in stock, for example.

57
00:03:27,200 --> 00:03:29,455
From the application developer's standpoint,

58
00:03:29,455 --> 00:03:33,260
the idea here is that we can store everything we need to store in

59
00:03:33,260 --> 00:03:39,855
a single document so that we can render a web page with a single request to the database.

60
00:03:39,855 --> 00:03:42,605
So rather than doing joins across multiple tables,

61
00:03:42,605 --> 00:03:44,780
which is necessarily less efficient,

62
00:03:44,780 --> 00:03:46,430
we do a simple request,

63
00:03:46,430 --> 00:03:50,570
all of the data is stored sequentially in the same place on disk and in memory,

64
00:03:50,570 --> 00:03:54,105
and the request ends up being very fast.

65
00:03:54,105 --> 00:03:55,760
Note that here in this data model,

66
00:03:55,760 --> 00:04:00,485
we're actually including the reviews in with the product data itself, again,

67
00:04:00,485 --> 00:04:04,580
so that we can do a single request to the database to

68
00:04:04,580 --> 00:04:10,290
produce the webpage that would be generated by this particular document.

69
00:04:10,290 --> 00:04:14,075
As a data scientist, especially as you get more and more comfortable with

70
00:04:14,075 --> 00:04:17,665
the MongoDB query language and the aggregation framework,

71
00:04:17,665 --> 00:04:22,400
you can leverage this same query efficiency for the different types of

72
00:04:22,400 --> 00:04:27,905
analysis that you'll want to do on whatever data set it is you're working with.

73
00:04:27,905 --> 00:04:33,195
So again, the takeaways for the MongoDB document model are,

74
00:04:33,195 --> 00:04:39,495
think of it as JSON or think of it as a dictionary in Python.

75
00:04:39,495 --> 00:04:41,730
And within that dictionary,

76
00:04:41,730 --> 00:04:44,880
values can be scalers,

77
00:04:44,880 --> 00:04:46,470
they can be arrays,

78
00:04:46,470 --> 00:04:49,515
or they can themselves be dictionaries.

79
00:04:49,515 --> 00:04:52,560
And you can have any level of embedding and nesting that

80
00:04:52,560 --> 00:04:56,040
makes sense for your particular application.

81
00:04:56,040 --> 00:05:00,340
Now of course, you could have a completely flat data model if you so desired,

82
00:05:00,340 --> 00:05:04,230
with simply keys and values and all of the values being scalar,

83
00:05:04,230 --> 00:05:09,320
but there's usually a good reason to have some level of hierarchy in your data model.

84
00:05:09,320 --> 00:05:12,045
And typically that reason is one of efficiency

85
00:05:12,045 --> 00:05:15,210
or simplicity in terms of working with the data.