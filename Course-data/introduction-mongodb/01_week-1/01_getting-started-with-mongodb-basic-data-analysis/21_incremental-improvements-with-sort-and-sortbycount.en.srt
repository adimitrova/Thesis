1
00:00:00,846 --> 00:00:04,441
You can get a clearer picture of
this data if we sort the results.

2
00:00:04,441 --> 00:00:07,523
Sort is just another pipeline stage.

3
00:00:07,523 --> 00:00:13,020
As with group we identify
the stage by its name $sort.

4
00:00:13,020 --> 00:00:16,789
The expression used to define
the sort is a dictionary.

5
00:00:16,789 --> 00:00:21,892
This document specify the field or
fields we want to sort on.

6
00:00:21,892 --> 00:00:25,043
Use 1 to indicate you want
to sort in ascending order.

7
00:00:25,043 --> 00:00:27,413
Use minus 1 for descending.

8
00:00:27,413 --> 00:00:31,373
In this pipeline,
the dollar group stage emits

9
00:00:31,373 --> 00:00:36,231
documents that contain just two fields,
_id and count.

10
00:00:36,231 --> 00:00:38,962
We are sorting on the count field.

11
00:00:38,962 --> 00:00:41,378
Let's run this.

12
00:00:41,378 --> 00:00:46,069
Now in scanning through these results,
we can get a sense for the variety and

13
00:00:46,069 --> 00:00:49,381
relative frequency of
language combinations used.

14
00:00:49,381 --> 00:00:53,736
So, what we've done here is
grouped in order to count and

15
00:00:53,736 --> 00:00:55,748
then sorted on the count.

16
00:00:55,748 --> 00:00:58,761
This is a very common
sequence of operations.

17
00:00:58,761 --> 00:01:01,441
So common that the aggregation
framework actually

18
00:01:01,441 --> 00:01:04,129
includes a single stage
that supports this idiom.

19
00:01:04,129 --> 00:01:07,060
It's called "sort by count".

20
00:01:07,060 --> 00:01:13,305
So, we can simplify this
pipeline to just this.

21
00:01:13,305 --> 00:01:17,807
The thing I love about this is that we're
able to perform an important operation

22
00:01:17,807 --> 00:01:19,295
with very little effort.

23
00:01:19,295 --> 00:01:22,336
There are a number of examples
with this type of power throughout

24
00:01:22,336 --> 00:01:23,755
the aggregation framework.