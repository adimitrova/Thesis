[MUSIC] Welcome to the lesson on
Application Layer Protocols which is part of the web connectivity
segment of the course. In the previous video lecture I
have explained the basic function of the application layer, which is
the top layer in the TCP/IP model. In this lesson, we will look into the
basics of application layer protocols and go through some of the protocols
that enable the World Wide Web. Let's start with understanding
Network Applications. First and foremost, not all applications
that you use have to be networked. This was very true previously, but
is gradually becoming uncommon. Applications that don't require
data exchange over the network and can work on their own are called
stand-alone applications. For example, many video and image editors, word processors and
CAP tools are such applications. Currently also these applications
are becoming connected, as there are, for example, photo editing applications that allow
you to share images over the Internet. Soon we will probably have
no standalone applications, except in critical security systems and
real time systems. Networked applications,
unlike standalone applications, need to connect to other
applications over the network. There are some applications
that are inherently networked, such as e-mail, web browser and
FTP tools for file transfer. On the other hand, there are applications that we have
made connected because of their utility. A good example is a word
processor which lets you collaborate with other authors around the
globe simultaneously on a shared document. In order to communicate over the network, these applications need to follow certain
rules so that there is consistency. The combinations of rules and
suggestions are called protocols. They can be different aspects
of these protocols, but some of the basic aspects that
every application layer protocol should provide, include the type
of data or payload format. That can be exchange
by these protocols and the way it should be formatted and
packaged. The last thing you want in network
communications is that the applications don't understand each other's messages. There can be different types of
messages that are exchanged. With a request message,
an application asks for some data. With a response message,
an application provides some data. With a control message,
an application commands and controls a remote application. These are just the three basic types. They can be more as we will see later. After defining the message type,
the protocol should define the fields within the message,
including their position and meaning. The last important thing is to define
control and communication rules and regulations, addressing questions
such as when and how can applications send messages, what happens
when a response is received or is not received at all, or
when an undesired response is received. And how to react to
different control messages. The more such rules are specified, the more compatible two different
implementations of the protocol will be. But it will also increase
the complexity of the protocol. To understand the application
layer protocols, we will take the technologies that
enable our web experience as an example. The web is the most dominant way for
humans to exchange and consume information and
media over the Internet. The key technologies that enable this
exchange of information are the following. HTML or
the Hypertext Markup Language that defines how the content or
webpages should be formatted. A web browser, the application
that reads the HTML files and presents them in a human
understandable formats. A URI or Uniform Resource Identifier, is a way to address pages and
information on the web. This is how you and the web browser know where to go to
find the next piece of information. For example, www.google.com is a URI which tells you want to go for a Google search. Finally, HTTP,
the hypertext transfer protocol. You have a browser that will
access the information and URI, the location from
where to access it and HTML is the format of the information. Now the question is how will the browser
send a request and receive the HTML pages? That is where HTTP comes in. It's the protocol via which
applications communicate. Is not the only one, but
is the one you encounter the most. Out of these technologies,
the one that concerns us the most is HTTP. So let's look at it in the light of
the characteristics we defined for application layer protocols previously,
namely payload formats, message types, message syntax and rules. HTTP is the protocol via which your browser sends a request to
remote server over the Internet. It is inherently a stateless protocol, meaning that it keeps no information
about the state of the connection. Each subsequent request is
sent via a new TCP connection. There is an HTTP property
called keep alive, which tells the server to keep the
connection open for subsequent requests. As we are dealing with embedded
systems that have limited memory and might not need to
communicate that frequently, it is recommended to disable
keep-alive to save up memory. A simple HTTP request has three sections. First, method, which defines what
type of message you are sending, or for the sake of simplicity what type of
command you want the server to execute. Second, URI at rest of the remote server, and third the protocol version. There can be another
section called headers, which gives extra information
about the command. Here's an example request for
accessing google.com. Let's go through the response message. 200 is a status code meaning okay, or that the command executed properly. The content type header
shows the type of data and the format in which the server
will send the data. In our case,
it's a text file formatted using HTML and UTF-8 is the text encoding. There is also information about the type
of the server that was running and the date, time and so on. Let's look at another example. This time we send another command to
the Google server, a POST command. POST means that you want the server to
accept the data you are sending to it. We see that the response code is now 405. Meaning that you are not
allowed to execute that specific command on the server. The server sends you the list of
allowed commands as a response. These examples demonstrated
the characteristics an application protocol should have. Different message types,
formatting options and control mechanisms that determine
what happens when a desired or undesired request or action happens. HTTP is a very mature protocol and
has response and control messages for
a wide variety of situations. The web is not composed
of just text files. There are other types of content as well. For example, images. HTTP supports transporting
a different types of medium such as text,
images, audio and video. The receiving end or the client side should be able to
display and process this data. The content type header tells the client
what type of data was sent to it. Depending upon your browser and
target system, you are either able or unable to play the received contents. Here are some of the common audio and video format supported across systems and
browsers. For audio, MP3 and
AAC license dependent and therefore not supported by
browsers like Opera and Firefox. But if your operating system
has the proper codex installed, Opera and Firefox will play these formats. Ogg Vorbis on the other hand
is an open standard format and is supported by Firefox and
Opera but not by Internet Explorer. The WAV format is supported
by all modern browsers. For video,
H.264 is supported by all major browsers. And there are hardware
decoders available for it too. It also offers good compression, but
it might not be royalty free and requires a license. Among free video codecs, VP8 and Theora are the formats
supported by the major browsers except for Internet Explorer. There are different protocols that
allow you to stream media instead of merely downloading them in chunks. Progressive downloads, meaning
downloading files in small chunks and streaming technically work the same way. A large file is cut into small pieces and
then transferred. However, when progressively
downloading a video file, you might have to wait for the whole
file to download before you can play it. Or you can play it right away but you can move forward past the portion
that has been already downloaded. You need streaming protocols to
achieve fast forward, rewind, and play, pause features. The benefit of streaming
media via HTTP is that the traffic goes through a port
which is rarely blocked. It is also an affordable solution as
the infrastructure is already available. And HTTP streaming solutions can scale
according to the user's network. That is, the bit rate can be increased or decreased based on the user's
network conditions. A few examples of HTTP video
streaming protocols are HLS by Apple, MPEG-DASH developed under MPEG. It has been an international
standard since 2012. And then there is
Microsoft Smooth Streaming, supported by IIS, Microsoft's web server. So as a short review, in this
lecture we looked at some specifics of application layer protocols and
used HTTP as an example. Then we discussed briefly the types
of the web and streaming media. In later lectures we will look into
the protocols that make the web and video audio stream possible. More specifically, we will look at
transport protocols like TCP and UDP. [MUSIC]