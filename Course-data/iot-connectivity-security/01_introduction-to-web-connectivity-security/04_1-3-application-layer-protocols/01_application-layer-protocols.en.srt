1
00:00:00,000 --> 00:00:05,441
[MUSIC]

2
00:00:05,441 --> 00:00:10,095
Welcome to the lesson on
Application Layer Protocols which is

3
00:00:10,095 --> 00:00:14,041
part of the web connectivity
segment of the course.

4
00:00:14,041 --> 00:00:18,536
In the previous video lecture I
have explained the basic function

5
00:00:18,536 --> 00:00:23,449
of the application layer, which is
the top layer in the TCP/IP model.

6
00:00:24,550 --> 00:00:29,880
In this lesson, we will look into the
basics of application layer protocols and

7
00:00:29,880 --> 00:00:33,370
go through some of the protocols
that enable the World Wide Web.

8
00:00:34,930 --> 00:00:38,000
Let's start with understanding
Network Applications.

9
00:00:40,300 --> 00:00:45,240
First and foremost, not all applications
that you use have to be networked.

10
00:00:46,810 --> 00:00:52,889
This was very true previously, but
is gradually becoming uncommon.

11
00:00:52,889 --> 00:00:58,478
Applications that don't require
data exchange over the network and

12
00:00:58,478 --> 00:01:03,510
can work on their own are called
stand-alone applications.

13
00:01:03,510 --> 00:01:07,485
For example, many video and image editors,

14
00:01:07,485 --> 00:01:11,700
word processors and
CAP tools are such applications.

15
00:01:12,970 --> 00:01:17,690
Currently also these applications
are becoming connected,

16
00:01:17,690 --> 00:01:19,770
as there are, for example,

17
00:01:19,770 --> 00:01:25,070
photo editing applications that allow
you to share images over the Internet.

18
00:01:26,730 --> 00:01:30,480
Soon we will probably have
no standalone applications,

19
00:01:30,480 --> 00:01:35,260
except in critical security systems and
real time systems.

20
00:01:38,170 --> 00:01:41,880
Networked applications,
unlike standalone applications,

21
00:01:41,880 --> 00:01:46,010
need to connect to other
applications over the network.

22
00:01:47,350 --> 00:01:52,121
There are some applications
that are inherently networked,

23
00:01:52,121 --> 00:01:56,990
such as e-mail, web browser and
FTP tools for file transfer.

24
00:01:56,990 --> 00:01:58,210
On the other hand,

25
00:01:58,210 --> 00:02:03,420
there are applications that we have
made connected because of their utility.

26
00:02:03,420 --> 00:02:09,170
A good example is a word
processor which lets you

27
00:02:09,170 --> 00:02:14,830
collaborate with other authors around the
globe simultaneously on a shared document.

28
00:02:16,600 --> 00:02:19,720
In order to communicate over the network,

29
00:02:19,720 --> 00:02:24,940
these applications need to follow certain
rules so that there is consistency.

30
00:02:26,570 --> 00:02:30,670
The combinations of rules and
suggestions are called protocols.

31
00:02:33,050 --> 00:02:37,525
They can be different aspects
of these protocols, but

32
00:02:37,525 --> 00:02:42,781
some of the basic aspects that
every application layer protocol

33
00:02:42,781 --> 00:02:47,855
should provide, include the type
of data or payload format.

34
00:02:47,855 --> 00:02:51,065
That can be exchange
by these protocols and

35
00:02:51,065 --> 00:02:54,460
the way it should be formatted and
packaged.

36
00:02:55,520 --> 00:03:00,510
The last thing you want in network
communications is that the applications

37
00:03:00,510 --> 00:03:03,130
don't understand each other's messages.

38
00:03:05,920 --> 00:03:10,200
There can be different types of
messages that are exchanged.

39
00:03:12,170 --> 00:03:16,480
With a request message,
an application asks for some data.

40
00:03:18,060 --> 00:03:21,780
With a response message,
an application provides some data.

41
00:03:23,970 --> 00:03:27,660
With a control message,
an application commands and

42
00:03:27,660 --> 00:03:29,870
controls a remote application.

43
00:03:31,980 --> 00:03:35,140
These are just the three basic types.

44
00:03:35,140 --> 00:03:37,580
They can be more as we will see later.

45
00:03:40,190 --> 00:03:45,420
After defining the message type,
the protocol should define

46
00:03:45,420 --> 00:03:50,340
the fields within the message,
including their position and meaning.

47
00:03:52,480 --> 00:03:57,150
The last important thing is to define
control and communication rules and

48
00:03:57,150 --> 00:04:03,000
regulations, addressing questions
such as when and how can applications

49
00:04:03,000 --> 00:04:08,840
send messages, what happens
when a response is received or

50
00:04:08,840 --> 00:04:13,950
is not received at all, or
when an undesired response is received.

51
00:04:15,750 --> 00:04:18,619
And how to react to
different control messages.

52
00:04:20,220 --> 00:04:22,770
The more such rules are specified,

53
00:04:22,770 --> 00:04:27,240
the more compatible two different
implementations of the protocol will be.

54
00:04:28,380 --> 00:04:31,230
But it will also increase
the complexity of the protocol.

55
00:04:32,610 --> 00:04:35,940
To understand the application
layer protocols,

56
00:04:35,940 --> 00:04:41,030
we will take the technologies that
enable our web experience as an example.

57
00:04:43,350 --> 00:04:47,580
The web is the most dominant way for
humans to exchange and

58
00:04:47,580 --> 00:04:51,388
consume information and
media over the Internet.

59
00:04:53,019 --> 00:04:59,729
The key technologies that enable this
exchange of information are the following.

60
00:04:59,729 --> 00:05:05,045
HTML or
the Hypertext Markup Language that defines

61
00:05:05,045 --> 00:05:10,246
how the content or
webpages should be formatted.

62
00:05:10,246 --> 00:05:16,043
A web browser, the application
that reads the HTML files and

63
00:05:16,043 --> 00:05:20,942
presents them in a human
understandable formats.

64
00:05:20,942 --> 00:05:25,532
A URI or Uniform Resource Identifier,

65
00:05:25,532 --> 00:05:31,660
is a way to address pages and
information on the web.

66
00:05:33,284 --> 00:05:34,200
This is how you and

67
00:05:34,200 --> 00:05:38,668
the web browser know where to go to
find the next piece of information.

68
00:05:38,668 --> 00:05:44,622
For example, www.google.com is a URI which

69
00:05:44,622 --> 00:05:49,820
tells you want to go for a Google search.

70
00:05:51,880 --> 00:05:57,550
Finally, HTTP,
the hypertext transfer protocol.

71
00:05:58,830 --> 00:06:03,610
You have a browser that will
access the information and

72
00:06:03,610 --> 00:06:09,020
URI, the location from
where to access it and

73
00:06:09,020 --> 00:06:13,080
HTML is the format of the information.

74
00:06:13,080 --> 00:06:20,489
Now the question is how will the browser
send a request and receive the HTML pages?

75
00:06:21,630 --> 00:06:24,170
That is where HTTP comes in.

76
00:06:25,600 --> 00:06:29,830
It's the protocol via which
applications communicate.

77
00:06:31,680 --> 00:06:37,162
Is not the only one, but
is the one you encounter the most.

78
00:06:37,162 --> 00:06:43,600
Out of these technologies,
the one that concerns us the most is HTTP.

79
00:06:45,723 --> 00:06:50,911
So let's look at it in the light of
the characteristics we defined for

80
00:06:50,911 --> 00:06:56,189
application layer protocols previously,
namely payload formats,

81
00:06:56,189 --> 00:06:59,509
message types, message syntax and rules.

82
00:07:01,300 --> 00:07:04,650
HTTP is the protocol via which

83
00:07:04,650 --> 00:07:08,690
your browser sends a request to
remote server over the Internet.

84
00:07:10,490 --> 00:07:13,610
It is inherently a stateless protocol,

85
00:07:13,610 --> 00:07:17,939
meaning that it keeps no information
about the state of the connection.

86
00:07:19,580 --> 00:07:24,880
Each subsequent request is
sent via a new TCP connection.

87
00:07:26,658 --> 00:07:31,100
There is an HTTP property
called keep alive,

88
00:07:31,100 --> 00:07:35,829
which tells the server to keep the
connection open for subsequent requests.

89
00:07:37,580 --> 00:07:42,550
As we are dealing with embedded
systems that have limited memory and

90
00:07:42,550 --> 00:07:45,890
might not need to
communicate that frequently,

91
00:07:45,890 --> 00:07:49,840
it is recommended to disable
keep-alive to save up memory.

92
00:07:52,350 --> 00:07:56,389
A simple HTTP request has three sections.

93
00:07:58,280 --> 00:08:04,550
First, method, which defines what
type of message you are sending, or

94
00:08:04,550 --> 00:08:09,840
for the sake of simplicity what type of
command you want the server to execute.

95
00:08:11,170 --> 00:08:16,664
Second, URI at rest of the remote server,

96
00:08:16,664 --> 00:08:20,941
and third the protocol version.

97
00:08:20,941 --> 00:08:23,419
There can be another
section called headers,

98
00:08:23,419 --> 00:08:26,160
which gives extra information
about the command.

99
00:08:27,210 --> 00:08:34,000
Here's an example request for
accessing google.com.

100
00:08:34,000 --> 00:08:36,030
Let's go through the response message.

101
00:08:36,030 --> 00:08:42,030
200 is a status code meaning okay,

102
00:08:42,030 --> 00:08:44,670
or that the command executed properly.

103
00:08:46,060 --> 00:08:50,080
The content type header
shows the type of data and

104
00:08:50,080 --> 00:08:53,810
the format in which the server
will send the data.

105
00:08:53,810 --> 00:09:01,012
In our case,
it's a text file formatted using HTML and

106
00:09:01,012 --> 00:09:05,100
UTF-8 is the text encoding.

107
00:09:05,100 --> 00:09:09,410
There is also information about the type
of the server that was running and

108
00:09:09,410 --> 00:09:11,480
the date, time and so on.

109
00:09:13,250 --> 00:09:14,600
Let's look at another example.

110
00:09:17,360 --> 00:09:21,560
This time we send another command to
the Google server, a POST command.

111
00:09:22,960 --> 00:09:27,730
POST means that you want the server to
accept the data you are sending to it.

112
00:09:29,140 --> 00:09:33,590
We see that the response code is now 405.

113
00:09:33,590 --> 00:09:37,000
Meaning that you are not
allowed to execute

114
00:09:37,000 --> 00:09:39,100
that specific command on the server.

115
00:09:40,820 --> 00:09:45,130
The server sends you the list of
allowed commands as a response.

116
00:09:47,220 --> 00:09:50,580
These examples demonstrated
the characteristics

117
00:09:50,580 --> 00:09:52,960
an application protocol should have.

118
00:09:52,960 --> 00:09:56,761
Different message types,
formatting options and

119
00:09:56,761 --> 00:10:01,621
control mechanisms that determine
what happens when a desired or

120
00:10:01,621 --> 00:10:04,549
undesired request or action happens.

121
00:10:05,826 --> 00:10:10,423
HTTP is a very mature protocol and
has response and

122
00:10:10,423 --> 00:10:15,250
control messages for
a wide variety of situations.

123
00:10:18,190 --> 00:10:22,130
The web is not composed
of just text files.

124
00:10:22,130 --> 00:10:24,980
There are other types of content as well.

125
00:10:24,980 --> 00:10:26,360
For example, images.

126
00:10:28,110 --> 00:10:33,113
HTTP supports transporting
a different types of

127
00:10:33,113 --> 00:10:38,130
medium such as text,
images, audio and video.

128
00:10:38,130 --> 00:10:39,820
The receiving end or

129
00:10:39,820 --> 00:10:44,000
the client side should be able to
display and process this data.

130
00:10:45,510 --> 00:10:49,730
The content type header tells the client
what type of data was sent to it.

131
00:10:51,590 --> 00:10:57,110
Depending upon your browser and
target system, you are either able or

132
00:10:57,110 --> 00:11:00,280
unable to play the received contents.

133
00:11:01,770 --> 00:11:04,544
Here are some of the common audio and

134
00:11:04,544 --> 00:11:08,810
video format supported across systems and
browsers.

135
00:11:11,780 --> 00:11:16,776
For audio, MP3 and
AAC license dependent and

136
00:11:16,776 --> 00:11:23,450
therefore not supported by
browsers like Opera and Firefox.

137
00:11:25,300 --> 00:11:30,645
But if your operating system
has the proper codex installed,

138
00:11:30,645 --> 00:11:34,464
Opera and Firefox will play these formats.

139
00:11:34,464 --> 00:11:39,456
Ogg Vorbis on the other hand
is an open standard format and

140
00:11:39,456 --> 00:11:45,075
is supported by Firefox and
Opera but not by Internet Explorer.

141
00:11:46,362 --> 00:11:50,232
The WAV format is supported
by all modern browsers.

142
00:11:52,028 --> 00:11:59,010
For video,
H.264 is supported by all major browsers.

143
00:11:59,010 --> 00:12:01,790
And there are hardware
decoders available for it too.

144
00:12:04,490 --> 00:12:09,478
It also offers good compression, but
it might not be royalty free and

145
00:12:09,478 --> 00:12:11,031
requires a license.

146
00:12:11,031 --> 00:12:14,656
Among free video codecs, VP8 and

147
00:12:14,656 --> 00:12:19,406
Theora are the formats
supported by the major

148
00:12:19,406 --> 00:12:23,781
browsers except for Internet Explorer.

149
00:12:23,781 --> 00:12:27,902
There are different protocols that
allow you to stream media instead of

150
00:12:27,902 --> 00:12:30,040
merely downloading them in chunks.

151
00:12:31,130 --> 00:12:35,790
Progressive downloads, meaning
downloading files in small chunks and

152
00:12:35,790 --> 00:12:38,680
streaming technically work the same way.

153
00:12:39,950 --> 00:12:44,400
A large file is cut into small pieces and
then transferred.

154
00:12:46,090 --> 00:12:50,860
However, when progressively
downloading a video file,

155
00:12:50,860 --> 00:12:55,330
you might have to wait for the whole
file to download before you can play it.

156
00:12:56,470 --> 00:12:58,540
Or you can play it right away but

157
00:12:58,540 --> 00:13:03,030
you can move forward past the portion
that has been already downloaded.

158
00:13:04,490 --> 00:13:09,206
You need streaming protocols to
achieve fast forward, rewind, and

159
00:13:09,206 --> 00:13:10,924
play, pause features.

160
00:13:12,339 --> 00:13:16,405
The benefit of streaming
media via HTTP is that

161
00:13:16,405 --> 00:13:21,420
the traffic goes through a port
which is rarely blocked.

162
00:13:21,420 --> 00:13:29,380
It is also an affordable solution as
the infrastructure is already available.

163
00:13:29,380 --> 00:13:34,510
And HTTP streaming solutions can scale
according to the user's network.

164
00:13:35,530 --> 00:13:38,720
That is, the bit rate can be increased or

165
00:13:38,720 --> 00:13:42,940
decreased based on the user's
network conditions.

166
00:13:43,950 --> 00:13:51,595
A few examples of HTTP video
streaming protocols are HLS by Apple,

167
00:13:51,595 --> 00:13:56,370
MPEG-DASH developed under MPEG.

168
00:13:57,560 --> 00:14:00,544
It has been an international
standard since 2012.

169
00:14:02,090 --> 00:14:05,420
And then there is
Microsoft Smooth Streaming,

170
00:14:05,420 --> 00:14:09,460
supported by IIS, Microsoft's web server.

171
00:14:10,700 --> 00:14:16,110
So as a short review, in this
lecture we looked at some specifics

172
00:14:16,110 --> 00:14:20,720
of application layer protocols and
used HTTP as an example.

173
00:14:22,030 --> 00:14:25,660
Then we discussed briefly the types
of the web and streaming media.

174
00:14:27,110 --> 00:14:31,050
In later lectures we will look into
the protocols that make the web and

175
00:14:31,050 --> 00:14:33,580
video audio stream possible.

176
00:14:33,580 --> 00:14:39,118
More specifically, we will look at
transport protocols like TCP and UDP.

177
00:14:39,118 --> 00:14:44,239
[MUSIC]