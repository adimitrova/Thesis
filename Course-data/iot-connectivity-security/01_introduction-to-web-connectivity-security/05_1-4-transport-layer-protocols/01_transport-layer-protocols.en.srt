1
00:00:00,000 --> 00:00:05,433
[MUSIC]

2
00:00:05,433 --> 00:00:09,000
Welcome to the lesson on
Transport Layer Protocol.

3
00:00:10,220 --> 00:00:14,220
Previously, we have looked at
Application Layer Protocols or

4
00:00:14,220 --> 00:00:19,470
protocols designed to help programs and
services understand each other.

5
00:00:19,470 --> 00:00:23,370
In this lesson,
we will look at transport layer protocols

6
00:00:23,370 --> 00:00:26,960
which take date from
application layer services and

7
00:00:26,960 --> 00:00:30,831
make sure they reach the service or
process the destination end.

8
00:00:32,570 --> 00:00:36,691
One thing that most of us
are familiar with is an IP address.

9
00:00:37,710 --> 00:00:42,540
An IP address is associated
with a machine or host and

10
00:00:42,540 --> 00:00:45,790
it's a way to make your data
reach that specific host.

11
00:00:47,175 --> 00:00:52,800
They can be multiple processes running
on that machine, such as Outlook mail,

12
00:00:52,800 --> 00:00:58,430
Firefox browser, FTP server,
Secure Shell, and Remote Desktop.

13
00:00:59,610 --> 00:01:04,850
Now, the host got the data but
how do you make sure that

14
00:01:04,850 --> 00:01:08,700
each process receives the data
that was intended for it?

15
00:01:10,070 --> 00:01:12,333
This is where transport
layer protocols come in.

16
00:01:14,999 --> 00:01:18,281
They receive information
from lower layers and

17
00:01:18,281 --> 00:01:21,899
pass it up to the right user
application or service.

18
00:01:22,950 --> 00:01:27,790
In this way, you can have multiple
services and applications running on your

19
00:01:27,790 --> 00:01:32,790
machine, although you have only one
IP address and network interface.

20
00:01:34,260 --> 00:01:37,660
Transport layer protocols do
a lot more than just that.

21
00:01:39,070 --> 00:01:43,660
They establish and manage these
connections between processes,

22
00:01:43,660 --> 00:01:47,710
they divide the data from user
applications into chunks so

23
00:01:47,710 --> 00:01:49,890
that they are easier to transport.

24
00:01:51,520 --> 00:01:56,670
Transport layer protocols can
also offer congestion control,

25
00:01:56,670 --> 00:02:00,780
they analyze the network and
adjust the throughput.

26
00:02:02,260 --> 00:02:06,850
Moreover, they can offer error
correction to detect and

27
00:02:06,850 --> 00:02:10,760
correct errors that occurred
during data transmission.

28
00:02:12,390 --> 00:02:16,600
Some can also offer other
services like reliability.

29
00:02:16,600 --> 00:02:19,340
Making sure that all
the data is transferred and

30
00:02:19,340 --> 00:02:21,970
received in the order
it was initially sent.

31
00:02:23,810 --> 00:02:30,840
Transport layer protocols do not dictate
how a packet is sent over the network.

32
00:02:30,840 --> 00:02:35,520
They simply hand off data to
the lower Internet layer, and

33
00:02:35,520 --> 00:02:37,550
pick up data from the Internet layer.

34
00:02:39,150 --> 00:02:45,030
In essence, they operate on the end nodes,
not on the network itself.

35
00:02:45,030 --> 00:02:48,000
And are therefore also
called end to end protocols.

36
00:02:49,150 --> 00:02:55,280
So a short round up of these services that
a transport layer protocol can provide.

37
00:02:58,100 --> 00:03:02,669
They can establish, manage,
and terminate the connections.

38
00:03:03,680 --> 00:03:09,110
Handle the flow of data in case
the receiving end is slower or

39
00:03:09,110 --> 00:03:10,300
has smaller buffers.

40
00:03:11,810 --> 00:03:16,190
Make sure all the packets are sent and
are arrow free and

41
00:03:16,190 --> 00:03:18,430
avoid too much traffic on the network.

42
00:03:20,150 --> 00:03:25,088
We will now look into two of
the main transport layer protocols,

43
00:03:25,088 --> 00:03:26,650
mainly TCP and UDP.

44
00:03:30,200 --> 00:03:34,370
Transmission Control Protocol is
a connection oriented transport

45
00:03:34,370 --> 00:03:34,980
layer protocol.

46
00:03:36,460 --> 00:03:41,350
In the Internet protocol suite TCP/IP,
this is where the acronym

47
00:03:41,350 --> 00:03:46,690
TCP comes from,
it's a fairly complex protocol.

48
00:03:46,690 --> 00:03:49,879
Especially compared to
its counterpart UDP,

49
00:03:49,879 --> 00:03:53,650
simply because of the multiple
services it provides.

50
00:03:55,450 --> 00:03:59,040
Some of the distinctive
features of TCP are,

51
00:04:01,670 --> 00:04:06,360
TCP offers the ability to receive
exactly the same numbers of

52
00:04:06,360 --> 00:04:09,700
packets as will send and
in the same order.

53
00:04:11,480 --> 00:04:16,580
All TCP packets are therefore
numbered making it easier for

54
00:04:16,580 --> 00:04:18,950
the end system to re-group them in order.

55
00:04:20,560 --> 00:04:24,480
For reliability TCP uses acknowledgements,

56
00:04:24,480 --> 00:04:27,840
each transmission is
acknowledged by the receiver.

57
00:04:29,100 --> 00:04:34,870
If the packet is not acknowledged in
a certain time frame, it is retransmitted.

58
00:04:34,870 --> 00:04:41,950
The receiver can also inform the sender of
the specific packets it has not received.

59
00:04:43,780 --> 00:04:50,520
TCP delays can sometimes be very high for
the upper layer application.

60
00:04:50,520 --> 00:04:54,840
As TCP waits for
all the data to be received,

61
00:04:54,840 --> 00:04:58,939
puts the data in order and
then forwards it to the upper layer.

62
00:05:00,740 --> 00:05:06,083
Reliability is the reason why some
application layer protocols do not offer

63
00:05:06,083 --> 00:05:11,103
their own reliable communication
structures but rely on TCP instead.

64
00:05:14,946 --> 00:05:20,078
TCP offers bidirectional communication,
both parties can send and

65
00:05:20,078 --> 00:05:23,979
receive packets and
they can do it simultaneously.

66
00:05:27,632 --> 00:05:33,201
TCP offers flow control,
if the receiver buffers are small,

67
00:05:33,201 --> 00:05:40,930
TCP can reduce the rate of transmission in
order to avoid overflowing the end system.

68
00:05:42,400 --> 00:05:47,900
If the receiver buffers are full,
the receiver will start dropping packets,

69
00:05:47,900 --> 00:05:50,870
meaning the sender will not
get any acknowledgements.

70
00:05:52,200 --> 00:05:56,439
This lack of acknowledgments
acts as an indicator for

71
00:05:56,439 --> 00:05:59,556
the sender to either slow down or stop.

72
00:06:02,788 --> 00:06:07,607
Network congestion is the reduction
of throughput because of

73
00:06:07,607 --> 00:06:10,210
too much traffic on the network.

74
00:06:11,870 --> 00:06:17,290
TCP offers a mechanism called slow start,
it starts transmitting

75
00:06:17,290 --> 00:06:23,400
lower number of packets and gradually
increases until congestion occurs.

76
00:06:24,780 --> 00:06:29,620
An indication of congestion is
the lack of acknowledgements.

77
00:06:29,620 --> 00:06:34,212
That means either the sender
has reached the network's

78
00:06:34,212 --> 00:06:39,400
transmit capacity or
the receiver can't handle anymore packets.

79
00:06:39,400 --> 00:06:41,850
In both cases it scales back,

80
00:06:41,850 --> 00:06:47,836
this is a method to prevent the host
from causing immediate congestion.

81
00:06:50,753 --> 00:06:56,105
Finally, it's up to TCP how it
organizes and sends the data.

82
00:06:57,580 --> 00:07:00,329
TCP sends data in streams of bytes.

83
00:07:01,430 --> 00:07:04,190
It takes data from the application layer,

84
00:07:05,210 --> 00:07:10,540
let's say 1000 bytes,
chops it into pieces.

85
00:07:10,540 --> 00:07:14,380
For example, ten pieces of 100 bytes, and

86
00:07:14,380 --> 00:07:19,580
sends the pieces down to the network or
Internet layer for transmission.

87
00:07:21,650 --> 00:07:27,860
On the other hand it can take data in
multiple bytes from the application layer.

88
00:07:27,860 --> 00:07:31,988
For example, ten pieces,
each of 20 bytes, and

89
00:07:31,988 --> 00:07:35,544
send them as 100, 200 bytes packet.

90
00:07:38,900 --> 00:07:44,940
TCP is slow due to its
reliability controls.

91
00:07:44,940 --> 00:07:49,990
Another reason for TCP being slow
is the three-way handshake it uses,

92
00:07:51,630 --> 00:07:55,330
the initiator sends a synchronized packet.

93
00:07:55,330 --> 00:08:00,620
The receiver,
upon reception of the synchronized packet,

94
00:08:00,620 --> 00:08:03,500
sends a synchronized acknowledge packet.

95
00:08:03,500 --> 00:08:08,290
And lastly, the connection initiator
sends an acknowledge packet.

96
00:08:09,410 --> 00:08:12,630
This is why we call TCP
a connection oriented protocol,

97
00:08:13,760 --> 00:08:16,290
it first establishes a proper connection.

98
00:08:17,850 --> 00:08:19,791
When we want to close a connection,

99
00:08:19,791 --> 00:08:23,039
then there is even more
comprehensive four way handshake.

100
00:08:26,576 --> 00:08:31,336
Transport Layer Security, or
TLS, is another transport layer

101
00:08:31,336 --> 00:08:36,660
protocol that secures
communication between two parties.

102
00:08:36,660 --> 00:08:39,740
It's not a part of TCP but

103
00:08:39,740 --> 00:08:44,750
it relies on TCP,
which is why we are mentioning it here.

104
00:08:46,230 --> 00:08:48,155
This protocol will be discussed later on.

105
00:08:52,100 --> 00:08:56,643
TCP is a reliable means of
communication and therefore,

106
00:08:56,643 --> 00:09:01,860
it can be used in any situation
where a sure delivery is required.

107
00:09:03,410 --> 00:09:07,220
This assured delivery
comes at the cost of time.

108
00:09:07,220 --> 00:09:14,270
TCP is slow and delays can be very long as
it will wait to reorder all the packets.

109
00:09:15,570 --> 00:09:20,880
That's why it might not be the best option
for very time dependent applications.

110
00:09:23,990 --> 00:09:30,130
HTTP doesn't offer any built-in
reliability mechanisms but,

111
00:09:30,130 --> 00:09:34,590
as it runs on top of TCP,
TCP handles that for it.

112
00:09:34,590 --> 00:09:40,100
The file transfer protocol, FTP, and

113
00:09:40,100 --> 00:09:43,900
the chatting protocol, XMPP, also use TCP.

114
00:09:45,480 --> 00:09:51,060
XMPP is a chat protocol, so
if you send a good night message or

115
00:09:51,060 --> 00:09:54,970
message with some expression
of love to someone via XMPP.

116
00:09:54,970 --> 00:09:59,640
You don't want your message to get
lost and never reach its destination.

117
00:10:01,140 --> 00:10:05,490
TCP ensures that the receiver
gets your emotions,

118
00:10:05,490 --> 00:10:08,580
well maybe a little late,
but she or he will get it.

119
00:10:11,260 --> 00:10:14,720
TCP can handle that networks or
congestions.

120
00:10:16,280 --> 00:10:21,040
In unreliable network situations
its better to use TCP.

121
00:10:24,130 --> 00:10:28,339
Netflix uses TCP to send
a movie to your device.

122
00:10:29,670 --> 00:10:33,150
But you might say that
movies are real time and

123
00:10:33,150 --> 00:10:35,930
TCP is slow, I don't want stuttering.

124
00:10:37,460 --> 00:10:43,160
Well, avoiding that stuttering
is the reason Netflix uses TCP.

125
00:10:44,860 --> 00:10:50,780
First TCP's congestion
control mechanisms will probe

126
00:10:50,780 --> 00:10:56,740
the network and use all the available
bandwidth between you and Netflix.

127
00:10:56,740 --> 00:11:03,000
Secondly, TCP uses buffers to
temporarily store the received data.

128
00:11:03,000 --> 00:11:07,996
And therefore, the local application
can prefetch data from Netflix servers.

129
00:11:07,996 --> 00:11:15,220
Well, this was TCP,
now we will look at UDP.

130
00:11:15,220 --> 00:11:21,380
User Datagram Protocol or
UDP is another transport layer protocol.

131
00:11:22,730 --> 00:11:26,520
Unlike TCP,
it doesn't offer congestion control,

132
00:11:27,590 --> 00:11:31,830
it's not reliable and
it doesn't send data in packet streams.

133
00:11:33,200 --> 00:11:38,730
It also doesn't assure in-order delivery
or care if you receive duplicates.

134
00:11:40,530 --> 00:11:45,130
Also, there is no three
way handshake which is so

135
00:11:45,130 --> 00:11:47,800
far the only good thing
we have said about UDP.

136
00:11:50,240 --> 00:11:56,370
So why does it exist and
why would anyone use it?

137
00:11:56,370 --> 00:12:02,420
First of all, because of all the things
it doesn't do, it's very simple.

138
00:12:03,840 --> 00:12:08,820
This makes it light and
as it doesn't care about connections or

139
00:12:08,820 --> 00:12:11,190
handshakes, it's fast.

140
00:12:12,730 --> 00:12:17,000
It is stateless, meaning it doesn't
maintain session or connection state.

141
00:12:18,460 --> 00:12:22,080
Each request is treated as
a separate unique entity.

142
00:12:24,080 --> 00:12:28,839
This also makes it suitable for
simple request response queries.

143
00:12:30,820 --> 00:12:38,060
TCP sends numbered packet streams and
then reassembles them at the other end.

144
00:12:38,060 --> 00:12:44,220
UDP treats each packet as
an individual complete message.

145
00:12:44,220 --> 00:12:46,495
It sends one complete message and

146
00:12:46,495 --> 00:12:50,973
receives one complete message
with every sent receive request.

147
00:12:54,897 --> 00:12:59,045
To show you the difference
between the TCP and

148
00:12:59,045 --> 00:13:03,423
UDP formats, this is a 20-byte TCP header.

149
00:13:06,694 --> 00:13:10,334
And this is an 8-byte UDP header.

150
00:13:13,275 --> 00:13:20,730
This shows the relative size differences
between the two and the simplicity of UDP.

151
00:13:23,200 --> 00:13:28,091
UDP has its own use cases,
it is used for real time streaming,

152
00:13:28,091 --> 00:13:32,529
where timing is more important
than in order delivery.

153
00:13:32,529 --> 00:13:37,532
And where reliability is not
that important because one or

154
00:13:37,532 --> 00:13:42,240
two lost frames do not affect
the end user experience.

155
00:13:44,340 --> 00:13:49,020
Therefore, UDP is suitable for
time sensitive applications

156
00:13:49,020 --> 00:13:53,640
such as Voice Over IP and
multiplayer online games.

157
00:13:56,040 --> 00:14:00,622
The smaller header size of UDP compared to

158
00:14:00,622 --> 00:14:05,030
TCP makes UDP suitable for
bandwidth constraint environments.

159
00:14:06,570 --> 00:14:12,490
Also, it has a lower processing
overhead which is beneficial for

160
00:14:12,490 --> 00:14:14,840
very small low power devices.

161
00:14:17,482 --> 00:14:20,390
Being connectionless, UDP's good for

162
00:14:20,390 --> 00:14:25,010
broadcasting as well,
especially IPTV or streaming.

163
00:14:27,320 --> 00:14:31,020
The server doesn't have to
maintain a separate state, and

164
00:14:31,020 --> 00:14:33,180
session information for each connection.

165
00:14:34,520 --> 00:14:39,610
As it treats each message as
an independent entity, UDP is generally

166
00:14:39,610 --> 00:14:46,220
good for
simple request response style operations.

167
00:14:46,220 --> 00:14:53,099
Some protocols that employ and benefit
from UDP are Domain Name Service, DNS.

168
00:14:54,320 --> 00:15:02,640
Dynamic Host Configuration Protocol,
DHCP, and Network Time Protocol, NTP.

169
00:15:02,640 --> 00:15:07,346
In each of these, you send a query and
receive a response.

170
00:15:07,346 --> 00:15:11,634
One message is sent,
one message is received.

171
00:15:14,210 --> 00:15:19,690
And there is DTLS or
Datagram Transport Layer Security.

172
00:15:19,690 --> 00:15:25,410
It is not part of UDP but
it's used in conjunction with UDP.

173
00:15:26,630 --> 00:15:29,520
This security of protocol
will be discussed later on.

174
00:15:30,620 --> 00:15:35,070
In this lesson, we discussed the basic
functionalities of the transport layer.

175
00:15:36,110 --> 00:15:40,401
We also looked at the transport
layers protocols, TCP and UDP.

176
00:15:40,401 --> 00:15:44,401
In another lesson,
we will look into the Internet layer and

177
00:15:44,401 --> 00:15:48,810
see how data is moved from
the host over the network.

178
00:15:48,810 --> 00:15:53,517
So far, we have been dealing with data
that is still on the local machine.

179
00:15:53,517 --> 00:15:57,774
[SOUND]