[music] welcome to the lesson on transport layer protocol.
previously, we have looked at application layer protocols or protocols designed to help programs and services understand each other.
in this lesson, we will look at transport layer protocols which take date from application layer services and make sure they reach the service or process the destination end.
one thing that most of us are familiar with is an ip address.
an ip address is associated with a machine or host and it's a way to make your data reach that specific host.
they can be multiple processes running on that machine, such as outlook mail, firefox browser, ftp server, secure shell, and remote desktop.
now, the host got the data but how do you make sure that each process receives the data that was intended for it?
this is where transport layer protocols come in.
they receive information from lower layers and pass it up to the right user application or service.
in this way, you can have multiple services and applications running on your machine, although you have only one ip address and network interface.
transport layer protocols do a lot more than just that.
they establish and manage these connections between processes, they divide the data from user applications into chunks so that they are easier to transport.
transport layer protocols can also offer congestion control, they analyze the network and adjust the throughput.
moreover, they can offer error correction to detect and correct errors that occurred during data transmission.
some can also offer other services like reliability.
making sure that all the data is transferred and received in the order it was initially sent.
transport layer protocols do not dictate how a packet is sent over the network.
they simply hand off data to the lower internet layer, and pick up data from the internet layer.
in essence, they operate on the end nodes, not on the network itself.
and are therefore also called end to end protocols.
so a short round up of these services that a transport layer protocol can provide.
they can establish, manage, and terminate the connections.
handle the flow of data in case the receiving end is slower or has smaller buffers.
make sure all the packets are sent and are arrow free and avoid too much traffic on the network.
we will now look into two of the main transport layer protocols, mainly tcp and udp.
transmission control protocol is a connection oriented transport layer protocol.
in the internet protocol suite tcp/ip, this is where the acronym tcp comes from, it's a fairly complex protocol.
especially compared to its counterpart udp, simply because of the multiple services it provides.
some of the distinctive features of tcp are, tcp offers the ability to receive exactly the same numbers of packets as will send and in the same order.
all tcp packets are therefore numbered making it easier for the end system to re-group them in order.
for reliability tcp uses acknowledgements, each transmission is acknowledged by the receiver.
if the packet is not acknowledged in a certain time frame, it is retransmitted.
the receiver can also inform the sender of the specific packets it has not received.
tcp delays can sometimes be very high for the upper layer application.
as tcp waits for all the data to be received, puts the data in order and then forwards it to the upper layer.
reliability is the reason why some application layer protocols do not offer their own reliable communication structures but rely on tcp instead.
tcp offers bidirectional communication, both parties can send and receive packets and they can do it simultaneously.
tcp offers flow control, if the receiver buffers are small, tcp can reduce the rate of transmission in order to avoid overflowing the end system.
if the receiver buffers are full, the receiver will start dropping packets, meaning the sender will not get any acknowledgements.
this lack of acknowledgments acts as an indicator for the sender to either slow down or stop.
network congestion is the reduction of throughput because of too much traffic on the network.
tcp offers a mechanism called slow start, it starts transmitting lower number of packets and gradually increases until congestion occurs.
an indication of congestion is the lack of acknowledgements.
that means either the sender has reached the network's transmit capacity or the receiver can't handle anymore packets.
in both cases it scales back, this is a method to prevent the host from causing immediate congestion.
finally, it's up to tcp how it organizes and sends the data.
tcp sends data in streams of bytes.
it takes data from the application layer, let's say 1000 bytes, chops it into pieces.
for example, ten pieces of 100 bytes, and sends the pieces down to the network or internet layer for transmission.
on the other hand it can take data in multiple bytes from the application layer.
for example, ten pieces, each of 20 bytes, and send them as 100, 200 bytes packet.
tcp is slow due to its reliability controls.
another reason for tcp being slow is the three-way handshake it uses, the initiator sends a synchronized packet.
the receiver, upon reception of the synchronized packet, sends a synchronized acknowledge packet.
and lastly, the connection initiator sends an acknowledge packet.
this is why we call tcp a connection oriented protocol, it first establishes a proper connection.
when we want to close a connection, then there is even more comprehensive four way handshake.
transport layer security, or tls, is another transport layer protocol that secures communication between two parties.
it's not a part of tcp but it relies on tcp, which is why we are mentioning it here.
this protocol will be discussed later on.
tcp is a reliable means of communication and therefore, it can be used in any situation where a sure delivery is required.
this assured delivery comes at the cost of time.
tcp is slow and delays can be very long as it will wait to reorder all the packets.
that's why it might not be the best option for very time dependent applications.
http doesn't offer any built-in reliability mechanisms but, as it runs on top of tcp, tcp handles that for it.
the file transfer protocol, ftp, and the chatting protocol, xmpp, also use tcp.
xmpp is a chat protocol, so if you send a good night message or message with some expression of love to someone via xmpp.
you don't want your message to get lost and never reach its destination.
tcp ensures that the receiver gets your emotions, well maybe a little late, but she or he will get it.
tcp can handle that networks or congestions.
in unreliable network situations its better to use tcp.
netflix uses tcp to send a movie to your device.
but you might say that movies are real time and tcp is slow, i don't want stuttering.
well, avoiding that stuttering is the reason netflix uses tcp.
first tcp's congestion control mechanisms will probe the network and use all the available bandwidth between you and netflix.
secondly, tcp uses buffers to temporarily store the received data.
and therefore, the local application can prefetch data from netflix servers.
well, this was tcp, now we will look at udp.
user datagram protocol or udp is another transport layer protocol.
unlike tcp, it doesn't offer congestion control, it's not reliable and it doesn't send data in packet streams.
it also doesn't assure in-order delivery or care if you receive duplicates.
also, there is no three way handshake which is so far the only good thing we have said about udp.
so why does it exist and why would anyone use it?
first of all, because of all the things it doesn't do, it's very simple.
this makes it light and as it doesn't care about connections or handshakes, it's fast.
it is stateless, meaning it doesn't maintain session or connection state.
each request is treated as a separate unique entity.
this also makes it suitable for simple request response queries.
tcp sends numbered packet streams and then reassembles them at the other end.
udp treats each packet as an individual complete message.
it sends one complete message and receives one complete message with every sent receive request.
to show you the difference between the tcp and udp formats, this is a 20-byte tcp header.
and this is an 8-byte udp header.
this shows the relative size differences between the two and the simplicity of udp.
udp has its own use cases, it is used for real time streaming, where timing is more important than in order delivery.
and where reliability is not that important because one or two lost frames do not affect the end user experience.
therefore, udp is suitable for time sensitive applications such as voice over ip and multiplayer online games.
the smaller header size of udp compared to tcp makes udp suitable for bandwidth constraint environments.
also, it has a lower processing overhead which is beneficial for very small low power devices.
being connectionless, udp's good for broadcasting as well, especially iptv or streaming.
the server doesn't have to maintain a separate state, and session information for each connection.
as it treats each message as an independent entity, udp is generally good for simple request response style operations.
some protocols that employ and benefit from udp are domain name service, dns.
dynamic host configuration protocol, dhcp, and network time protocol, ntp.
in each of these, you send a query and receive a response.
one message is sent, one message is received.
and there is dtls or datagram transport layer security.
it is not part of udp but it's used in conjunction with udp.
this security of protocol will be discussed later on.
in this lesson, we discussed the basic functionalities of the transport layer.
we also looked at the transport layers protocols, tcp and udp.
in another lesson, we will look into the internet layer and see how data is moved from the host over the network.
so far, we have been dealing with data that is still on the local machine.
[sound]
