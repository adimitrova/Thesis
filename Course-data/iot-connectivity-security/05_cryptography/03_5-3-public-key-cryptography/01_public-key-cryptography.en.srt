1
00:00:00,000 --> 00:00:06,024
[MUSIC]

2
00:00:06,024 --> 00:00:07,430
Hi, welcome back.

3
00:00:08,460 --> 00:00:11,820
Previously, we introduced
cryptography as a tool for

4
00:00:11,820 --> 00:00:15,690
security solutions in
cyber physical systems.

5
00:00:15,690 --> 00:00:22,300
We also presented how symmetry key ciphers
are used for securing wireless networks.

6
00:00:22,300 --> 00:00:27,190
In this video lecture, we will learn
how public key cryptography works,

7
00:00:27,190 --> 00:00:30,760
we will have a close look at
the well-known RSA algorithm.

8
00:00:32,340 --> 00:00:36,550
Public key cryptography
comprises a set of algorithms

9
00:00:36,550 --> 00:00:39,470
that are designed based on
some mathematical problems.

10
00:00:40,730 --> 00:00:44,688
As we discussed earlier,
unlike in symmetric cryptography,

11
00:00:44,688 --> 00:00:51,110
in public key cryptography the decryption
key is not the same as the encryption key.

12
00:00:52,220 --> 00:00:56,050
And for this reason it is also
known as asymmetric cryptography.

13
00:00:57,860 --> 00:01:03,650
A pair of key is called a public key and
a private key are used in such a system.

14
00:01:05,290 --> 00:01:08,950
The public key,
as it is clear from its name,

15
00:01:08,950 --> 00:01:13,170
is publicly known by everybody and
is used for

16
00:01:13,170 --> 00:01:18,639
encryption, while the private key is
kept secret and used for decryption.

17
00:01:20,020 --> 00:01:25,630
So anybody can encrypt the message
with the recipient's public key,

18
00:01:25,630 --> 00:01:30,820
but only the recipient can decrypt
it using his or her own private key.

19
00:01:32,430 --> 00:01:34,460
This eliminates the need for

20
00:01:34,460 --> 00:01:38,009
a secure channel to exchange
the key between two parties.

21
00:01:39,490 --> 00:01:44,900
In a public key cryptography, the key
pairs are mathematically related, but it

22
00:01:44,900 --> 00:01:50,170
is computationally infeasible to get the
decryption key from the encryption key.

23
00:01:51,300 --> 00:01:54,140
Let's have a brief look
at some important and

24
00:01:54,140 --> 00:01:56,768
popular public key encryption algorithms.

25
00:01:56,768 --> 00:02:02,337
The Rivest-Shamir-Adlerman or
RSA algorithm is one of

26
00:02:02,337 --> 00:02:07,673
the most practical and
secure public key algorithms,

27
00:02:07,673 --> 00:02:12,434
which is widely used for
secure communication.

28
00:02:12,434 --> 00:02:21,133
RSA, which is named after its three
inventors was published in 1977.

29
00:02:21,133 --> 00:02:25,312
It provides three main functionalities,

30
00:02:25,312 --> 00:02:30,203
key generation, encryption,
and decryption.

31
00:02:30,203 --> 00:02:35,220
Diffie-Hellman, or DH protocol,

32
00:02:35,220 --> 00:02:40,753
provides an efficient and secure way
of exchanging an encryption key often

33
00:02:40,753 --> 00:02:46,825
symmetric cipher through a public channel
without any need for a secure channel.

34
00:02:46,825 --> 00:02:51,770
Diffie-Hellman is one of
the earliest applications

35
00:02:51,770 --> 00:02:56,500
of public key encryption,
published in 1976.

36
00:02:56,500 --> 00:03:00,819
This protocol is still
used in many applications.

37
00:03:02,870 --> 00:03:05,220
Elliptic Curve Cryptography or

38
00:03:05,220 --> 00:03:09,950
ECC provides an alternative mechanism for
public key encryption.

39
00:03:10,960 --> 00:03:13,680
It was introduced in 1985.

40
00:03:13,680 --> 00:03:20,310
ECC is based on algebraic elliptic
curves over finite fields.

41
00:03:20,310 --> 00:03:24,310
And offer smaller keys with
a reasonable level of security

42
00:03:24,310 --> 00:03:27,020
compared to other public
key encryption algorithms.

43
00:03:27,020 --> 00:03:31,610
It is therefore known as
a lightweight encryption method.

44
00:03:33,390 --> 00:03:38,600
ECC is widely use in embedded
resource constraint devices and

45
00:03:38,600 --> 00:03:43,430
provides many applications of
public encryption such as,

46
00:03:43,430 --> 00:03:49,100
encryption and decryption, digital
signatures, and digital certificates.

47
00:03:51,100 --> 00:03:56,665
To demonstrate how a public key
system mathematically works,

48
00:03:56,665 --> 00:04:02,658
we will first have a bit closer look
into the popular RSA algorithm.

49
00:04:02,658 --> 00:04:08,100
In another lecture, we will also have
a look at the Diffie-Hellman algorithm.

50
00:04:08,100 --> 00:04:12,840
We use these classic algorithms as
examples, because they are well known and

51
00:04:12,840 --> 00:04:15,360
relatively easy to present
in a short lecture.

52
00:04:16,430 --> 00:04:21,800
If you are interested in details of ECC,
I encourage you to search for

53
00:04:21,800 --> 00:04:23,550
related online documentation.

54
00:04:24,780 --> 00:04:28,970
There is a lot of information on
ECC in a reader friendly forum.

55
00:04:30,500 --> 00:04:35,090
The complex mathematics behind ECC
is out of the scope of this course.

56
00:04:36,400 --> 00:04:38,150
So, let's look at RSA.

57
00:04:39,790 --> 00:04:43,690
We start with generation of the public and
private keys.

58
00:04:45,680 --> 00:04:50,850
The first step is to choose two
relatively large prime numbers p and q.

59
00:04:51,960 --> 00:04:55,736
Typically, 1,024 bits or more in length.

60
00:04:57,831 --> 00:05:03,168
The next step is to calculate
product of n of p and q,

61
00:05:03,168 --> 00:05:08,519
and product phi(n) of (p-1) and (q-1).

62
00:05:08,519 --> 00:05:12,830
N later becomes the modulus
of the public and

63
00:05:12,830 --> 00:05:15,500
private keys, which we will see shortly.

64
00:05:17,320 --> 00:05:26,300
Now, the encryption key e is chosen in
such a way that it needs two properties.

65
00:05:26,300 --> 00:05:32,230
First, e has to be
relatively prime to phi(n).

66
00:05:32,230 --> 00:05:37,169
Second, e has to be greater than 1 and
less than phi(n).

67
00:05:38,800 --> 00:05:44,520
Two integers are relatively prime if
they share no common positive factors or

68
00:05:44,520 --> 00:05:46,111
divisors except 1.

69
00:05:47,935 --> 00:05:54,580
In other words, the greatest common
divisor of e and phi(n) must be 1.

70
00:05:54,580 --> 00:06:00,630
We use a tuple notation for the greatest
common divisor as shown on the screen.

71
00:06:02,560 --> 00:06:06,240
Now our public key is the pair of e and n.

72
00:06:10,280 --> 00:06:12,680
Let's see how the private
key is calculated.

73
00:06:14,250 --> 00:06:19,890
If e and phi n are prime,
then there is some integer d for

74
00:06:19,890 --> 00:06:25,585
decryption, such that e times
d equals one modular phi(n).

75
00:06:27,430 --> 00:06:31,120
Our private key is then defined
as the pair of d and n.

76
00:06:33,270 --> 00:06:38,810
Notice that without knowing p and q it is
practically impossible to determine d.

77
00:06:40,330 --> 00:06:43,840
Security of RSA relies
on this observation.

78
00:06:47,710 --> 00:06:52,642
Now that we have generated the keys,
we can encrypt and decrypt a message.

79
00:06:53,845 --> 00:06:57,555
In RSA, a full message is
presented as a sequence of

80
00:06:57,555 --> 00:07:02,025
positive integers between 0 and n-1.

81
00:07:02,025 --> 00:07:07,435
Each taking a fix number of bits
depending on the value of the modulus n.

82
00:07:09,215 --> 00:07:12,135
The same applies to
the produced cipher text.

83
00:07:13,150 --> 00:07:17,671
For simplicity,
let's consider a message m,

84
00:07:17,671 --> 00:07:23,330
which is composed of a single
integer between 0 and n- 1.

85
00:07:23,330 --> 00:07:27,884
For encryption, we take the message m and

86
00:07:27,884 --> 00:07:34,012
compute the ciphertext c as m
to the power of e modular n.

87
00:07:34,012 --> 00:07:38,199
For decryption we take
the cypher text c and

88
00:07:38,199 --> 00:07:43,210
compute the message m as c
to the power of d modulo n.

89
00:07:46,312 --> 00:07:47,800
Now let's try an example.

90
00:07:49,330 --> 00:07:54,350
Suppose our two primes, p and
q, are 5 and 11 respectively.

91
00:07:55,980 --> 00:08:02,400
Then n is equal to 55,
and phi(n) is equal to 40.

92
00:08:02,400 --> 00:08:06,630
Now we should select
the encryption exponent, e.

93
00:08:08,130 --> 00:08:15,400
Divisors of phi(n) are 1,
2, 4, 5, 8, 10, 20, and 40.

94
00:08:15,400 --> 00:08:19,540
So, it could be any number less than 40,

95
00:08:19,540 --> 00:08:23,640
which has no common divisor with 40.

96
00:08:23,640 --> 00:08:27,280
Of the candidates, well, let's pick seven.

97
00:08:32,230 --> 00:08:35,550
We should now select
the decryption exponent d,

98
00:08:36,550 --> 00:08:41,060
such that d times e equals 1 mod 40.

99
00:08:41,060 --> 00:08:47,500
Let's pick 23,
which satisfies the given condition,

100
00:08:47,500 --> 00:08:51,910
because 23 times 7 equals 161,

101
00:08:51,910 --> 00:08:55,569
which equals 4 times 40 plus 1.

102
00:08:58,270 --> 00:09:01,660
Determining d is computationally
a non-trivial task.

103
00:09:02,780 --> 00:09:07,020
The best way is to use
the extended Euclidean algorithm.

104
00:09:07,020 --> 00:09:09,070
We don't study this algorithm here though.

105
00:09:11,900 --> 00:09:17,034
So, here it is,
our public key is the pair 7,

106
00:09:17,034 --> 00:09:22,722
55, and
our private key is the pair 23, 55.

107
00:09:25,794 --> 00:09:30,451
Now, let's check how encryption and
decryption work.

108
00:09:30,451 --> 00:09:37,792
First, our message m could be
any integer between 0 and 54.

109
00:09:37,792 --> 00:09:40,580
Let's randomly pick the number 8.

110
00:09:40,580 --> 00:09:45,830
For encryption to get the ciphertext c,
we calculate 8

111
00:09:45,830 --> 00:09:50,770
to the power of 7 modulo 55,
which equals 2.

112
00:09:50,770 --> 00:09:53,734
So our ciphertext c is 2.

113
00:09:55,290 --> 00:09:58,040
Let's then decrypt the cypher text and

114
00:09:58,040 --> 00:10:01,730
see if we get our original message or
plain text in or not.

115
00:10:03,760 --> 00:10:08,830
We calculate 2 to the power of 23,
modulo 55,

116
00:10:08,830 --> 00:10:12,500
which, amazingly, equals 8.

117
00:10:12,500 --> 00:10:17,070
So it worked, we managed to
retrieve the original message m.

118
00:10:18,680 --> 00:10:24,030
In this lesson, we learned about
basics of public key cryptography.

119
00:10:24,030 --> 00:10:29,074
Moreover, we saw how we can
protect confidentiality

120
00:10:29,074 --> 00:10:32,667
of data by RSA public key encryption.

121
00:10:32,667 --> 00:10:34,330
In the next video lecture,

122
00:10:34,330 --> 00:10:38,236
we will learn how public key
encryption is used for establishing

123
00:10:38,236 --> 00:10:42,985
a shared secret between two parties
that don't know each other previously.

124
00:10:42,985 --> 00:10:48,064
[SOUND]