1
00:00:00,000 --> 00:00:05,134
[MUSIC]

2
00:00:05,134 --> 00:00:09,390
Welcome to the lesson on
RESTful web services.

3
00:00:09,390 --> 00:00:12,770
In this video lecture,
we will have a deep look at REST.

4
00:00:13,800 --> 00:00:15,300
But what is REST, actually?

5
00:00:16,500 --> 00:00:21,290
REST, or Representational State Transfer,
is an architectural style.

6
00:00:22,500 --> 00:00:25,490
A set of guidelines to
serve network applications.

7
00:00:26,960 --> 00:00:32,000
It specifies a set of constraints
on developing web services, and

8
00:00:32,000 --> 00:00:35,550
if those constraints are met
we call that service RESTful.

9
00:00:38,300 --> 00:00:43,160
The first constraint is the separation
of the client and server functions and

10
00:00:43,160 --> 00:00:44,209
architectures.

11
00:00:45,520 --> 00:00:49,560
The client doesn't care about
the task executed on the server.

12
00:00:49,560 --> 00:00:53,900
For example, database access or
memory management.

13
00:00:53,900 --> 00:00:57,100
And the server doesn't care
how the client operates.

14
00:00:58,450 --> 00:01:01,280
This way they both can be
developed independently.

15
00:01:03,790 --> 00:01:06,497
Clients can send multiple requests, but

16
00:01:06,497 --> 00:01:09,985
these requests should be
independent of each other.

17
00:01:13,327 --> 00:01:19,890
Responses should be clearly identified
as cacheable or non-cacheable.

18
00:01:19,890 --> 00:01:21,890
This is more of a performance constraint.

19
00:01:23,240 --> 00:01:27,590
Multiple clients might request
the same resource, and in this case,

20
00:01:27,590 --> 00:01:32,070
caching will help in reducing response
time and reducing a server load.

21
00:01:34,620 --> 00:01:39,470
There should be a uniform way of
identifying and accessing resources.

22
00:01:40,970 --> 00:01:45,200
Each resource must have a URI and
representation.

23
00:01:46,570 --> 00:01:49,850
The representation can be in JSON or XML.

24
00:01:51,810 --> 00:01:56,290
The last constraint is that
an application can have multiple layers.

25
00:01:56,290 --> 00:02:02,590
Layers between client and server,
like cash servers and load balancers.

26
00:02:02,590 --> 00:02:05,545
If there is a load balancer
between a client and a server,

27
00:02:05,545 --> 00:02:08,326
the client shouldn't see
beyond the load balancer.

28
00:02:08,326 --> 00:02:13,030
And the server shouldn't be concerned
with who the load balancer is talking to.

29
00:02:13,030 --> 00:02:18,302
This restriction reduces complexity and

30
00:02:18,302 --> 00:02:23,278
makes it easy to add and remove layers.

31
00:02:23,278 --> 00:02:27,939
As a design consideration
rather than a constraint,

32
00:02:27,939 --> 00:02:33,500
there should be one to one
mapping between CRUD operations.

33
00:02:33,500 --> 00:02:36,630
That is create, read, update, and

34
00:02:36,630 --> 00:02:40,990
delete operations, and
operations provided by the server.

35
00:02:44,450 --> 00:02:50,160
In light of these constraints,
let's look at how HTTP fits REST.

36
00:02:52,660 --> 00:02:58,710
HTTPs is stateless,
it has a client-server model,

37
00:03:01,000 --> 00:03:08,520
it supports caches, and
uses URLs to identify resources.

38
00:03:10,590 --> 00:03:15,460
The last design consideration
is mapping of craft operations.

39
00:03:15,460 --> 00:03:19,589
This can be done by a HTTP
methods as shown in the table.

40
00:03:20,900 --> 00:03:25,280
We see that it is simple to build
a RESTful web service via HTTP.

41
00:03:27,610 --> 00:03:32,770
But why should we use rest when exposing
the functionality of an embedded or

42
00:03:32,770 --> 00:03:34,510
cyber physical system to the web.

43
00:03:36,800 --> 00:03:40,939
First of all,
a central idea of rest is a resource.

44
00:03:42,280 --> 00:03:45,420
A resource is a component
of an application

45
00:03:45,420 --> 00:03:47,120
that can be uniquely identified.

46
00:03:48,720 --> 00:03:52,780
The same logic applies
to embedded systems.

47
00:03:52,780 --> 00:03:55,770
We have resources in
the form of sensor and

48
00:03:55,770 --> 00:04:00,439
actuators, which need to be
individually identified and accessed.

49
00:04:02,100 --> 00:04:08,600
Identification is achieved via URI's,
and they're representation via JSON.

50
00:04:09,600 --> 00:04:13,820
An access comes by a HTTP
methods like GET and POST.

51
00:04:15,740 --> 00:04:20,790
In REST, we call for CRUD operations,
create, read, update and delete.

52
00:04:22,450 --> 00:04:28,100
In most cases, these are the only
operations that we need on our sensors.

53
00:04:28,100 --> 00:04:31,705
Create the stages,
update them, or shut them off.

54
00:04:31,705 --> 00:04:35,066
REST and JSON, used together,

55
00:04:35,066 --> 00:04:40,669
create a lightweight
representation of resources.

56
00:04:42,190 --> 00:04:44,830
Being lightweight makes
it more power efficient.

57
00:04:44,830 --> 00:04:51,815
The statelessness of REST means that
it is more memory efficient as a server

58
00:04:51,815 --> 00:04:56,070
doesn't store our main information
about the state of the connection.

59
00:04:57,950 --> 00:05:02,609
So, not only does rest fulfill
our design considerations, but

60
00:05:02,609 --> 00:05:08,749
it also fulfills real-world considerations
related to limited power and memory.

61
00:05:12,527 --> 00:05:17,870
We looked into REST, and its applicability
to embed in systems in general.

62
00:05:19,410 --> 00:05:22,320
Now we will talk about some best practices

63
00:05:22,320 --> 00:05:25,580
to follow when designing
web-enabled embedded systems.

64
00:05:27,290 --> 00:05:33,980
First of all, identify the sensors or
functionalities that are available to you,

65
00:05:35,520 --> 00:05:39,690
and then decide which ones you
would like to enable as a resource.

66
00:05:42,090 --> 00:05:45,430
Each of these resources
should have a simple and

67
00:05:45,430 --> 00:05:48,740
focused URI to identify and access them.

68
00:05:50,740 --> 00:05:56,170
And finally, what actions would you like
to allow on each of these resources?

69
00:05:58,040 --> 00:06:01,830
To better understand, we will look
at an example development board.

70
00:06:05,730 --> 00:06:12,973
On the screen, you see a Texas
Instruments Smart RF06 Evaluation Board.

71
00:06:12,973 --> 00:06:18,095
It has an accelerometer,
light sensor, LCD display,

72
00:06:18,095 --> 00:06:23,639
an SD card slot, and
some push buttons and LEDs.

73
00:06:25,220 --> 00:06:29,600
In this case,
it is easy to identify our resources.

74
00:06:29,600 --> 00:06:32,750
All of the mentioned
components are resources

75
00:06:32,750 --> 00:06:36,010
that can be uniquely identified and
accessed.

76
00:06:37,870 --> 00:06:43,130
The next step is to assign each
one a unique and logical URI.

77
00:06:45,250 --> 00:06:49,740
Here you see an example mapping
of URIs against each resource.

78
00:06:51,330 --> 00:06:55,110
The next step is to specify which
operations you would allow on

79
00:06:55,110 --> 00:06:56,090
each resource.

80
00:06:57,380 --> 00:07:03,190
So when you enter in a browser the URL
of whichever sensor you want to access,

81
00:07:03,190 --> 00:07:08,070
the response will depend on whether the
specific HTTP method is allowed or not.

82
00:07:09,480 --> 00:07:13,340
If it's allowed you will
get an okay status message

83
00:07:13,340 --> 00:07:14,817
with the value of the sensor.

84
00:07:15,830 --> 00:07:20,520
If the method is not allowed, you will get
the method not allowed status message.

85
00:07:21,570 --> 00:07:25,990
On the screen you see an example
mapping of methods to resources.

86
00:07:27,810 --> 00:07:32,580
As we will be only reading data
from the accelerometer and

87
00:07:32,580 --> 00:07:36,040
licencer, the only method
we can use is GET.

88
00:07:37,850 --> 00:07:41,890
An LED can have a GET method
to tell us it status on or

89
00:07:41,890 --> 00:07:45,220
off and
a PUT method to change that status.

90
00:07:47,070 --> 00:07:53,390
And LCD can be updated to output certain
information, and for that we need PUT.

91
00:07:55,750 --> 00:08:02,500
If we are reading and writing to the SD
card, we can have all of these methods,

92
00:08:02,500 --> 00:08:07,210
create a file, update a file,
read it, and delete it.

93
00:08:07,210 --> 00:08:12,220
In this lesson, we looked at how
the REST style of designing web services

94
00:08:12,220 --> 00:08:15,540
is beneficial for
cyber physical systems, and

95
00:08:15,540 --> 00:08:20,140
then we described an example mapping of
REST to an embedded development board.

96
00:08:21,260 --> 00:08:24,575
Next we will learn about another type
of service called cloud computing.

97
00:08:24,575 --> 00:08:30,259
[MUSIC]