1
00:00:00,012 --> 00:00:06,426
We saw that the one remaining challenge 
is, how do we actually make our real 

2
00:00:06,426 --> 00:00:13,522
robot or a model of the real robot, which 
was the unicyle model, behave or act like 

3
00:00:13,522 --> 00:00:18,650
the simpler model x dot is equal to u, 
that we used when we designed our 

4
00:00:18,650 --> 00:00:23,992
navigation architecture. 
And we really have a problem because we 

5
00:00:23,992 --> 00:00:28,825
used the simplest possible model, 
x dot equal to u, as the basis for our 

6
00:00:28,825 --> 00:00:32,723
control design. 
And then, we started switching between go 

7
00:00:32,723 --> 00:00:37,937
to goal, follow wall, follow wall 
counterclockwise avoid obstacles and so 

8
00:00:37,937 --> 00:00:43,556
forth. And the navigation architecture we 
ended up with is this, as we've seen a 

9
00:00:43,556 --> 00:00:47,767
couple of times now, rather messy-looking 
hybrid system. 

10
00:00:47,767 --> 00:00:53,244
Now, what we need to do is somehow come 
up with a way of making the real robot 

11
00:00:53,244 --> 00:00:57,045
relevant or this model relevant to the 
real robot. 

12
00:00:57,045 --> 00:01:00,112
And 
we would like also to do this in such a 

13
00:01:00,112 --> 00:01:05,242
way that we don't have to worry too much 
about what kind of robot is it that we're 

14
00:01:05,242 --> 00:01:09,333
using? We want this navigation 
architecture to be relevant for 

15
00:01:09,333 --> 00:01:14,100
differential drive robots or 4-wheel 
robots or snake robots or flying 

16
00:01:14,100 --> 00:01:17,474
quadrotors. 
So, the question is, how do we do this? 

17
00:01:17,474 --> 00:01:22,467
And the standard way of approaching this 
problem is to produce a layered 

18
00:01:22,467 --> 00:01:27,797
architecture, where you have different 
levels of abstraction. So, in today's 

19
00:01:27,797 --> 00:01:33,177
lecture, I'm going to talk about the 
standard layers that people think of when 

20
00:01:33,177 --> 00:01:38,636
they build architectures high-level 
architectures for robotic systems. 

21
00:01:38,636 --> 00:01:44,512
Well, the standard and most canonical way 
in which people approach this is to have 

22
00:01:44,512 --> 00:01:50,362
three levels and borrowing terms from the 
military tactical literature people 

23
00:01:50,362 --> 00:01:55,387
typically talk about a strategic level 
and operational level and a tactical 

24
00:01:55,387 --> 00:01:58,627
level. 
So, the strategic level is high level. 

25
00:01:58,627 --> 00:02:02,942
Where do we go? Recall, for instance, 
that we have go to golal behaviors, 

26
00:02:02,942 --> 00:02:07,271
we have a goal point, well, where did 
that goal point come from? Who decided 

27
00:02:07,271 --> 00:02:10,721
that that's reasonable? 
Well, that happens at the strategic 

28
00:02:10,721 --> 00:02:13,932
level, where the high level decisions are 
being made. 

29
00:02:13,932 --> 00:02:19,742
And then at the operational level, you're 
trying to figure out, okay, I know that 

30
00:02:19,742 --> 00:02:25,127
there is a goal point somewhere out 
there, where do I go now? Meaning, this 

31
00:02:25,127 --> 00:02:30,457
is a short term, low-level planning 
problem. And in many ways, we can think 

32
00:02:30,457 --> 00:02:33,977
of our x dot equal to u model to live at 
the operational level. 

33
00:02:33,977 --> 00:02:39,002
But then, we have the lowest level, the 
tactical level, which asks, well, okay, I 

34
00:02:39,002 --> 00:02:42,667
know that I want to go this way but how 
do I actually do that? 

35
00:02:42,667 --> 00:02:47,457
I am snake robot, how does a snake go in 
this direction or I am a differential 

36
00:02:47,457 --> 00:02:51,942
drive mobile robot, 
a unicycle, how do I actually go in this 

37
00:02:51,942 --> 00:02:57,857
direction? So, the question of mapping x 
dot equal to u onto the real robot is a 

38
00:02:57,857 --> 00:03:03,732
question of moving in between these two 
levels or layers in the architecture. 

39
00:03:03,732 --> 00:03:07,792
While, if you want to be slightly less 
militaristic, 

40
00:03:07,792 --> 00:03:13,053
which, maybe we do we can call the 
highest level a high-level planning 

41
00:03:13,053 --> 00:03:16,242
level. 
We want to plan where the intermediary 

42
00:03:16,242 --> 00:03:21,350
goal points should really be. 
And then, the low-level planning that's 

43
00:03:21,350 --> 00:03:26,292
the question of which direction to move 
in-between these goal points. 

44
00:03:26,292 --> 00:03:31,257
And then at the execution level that we 
previously called the tactical level, 

45
00:03:31,257 --> 00:03:36,347
it's just a matter of how do we actually 
execute this? How do we make the robot do 

46
00:03:36,347 --> 00:03:41,320
what it is that we want it to do? And I 
should point out that the highest level, 

47
00:03:41,320 --> 00:03:46,360
we haven't touched at all in this course. 
In fact, we have assumed that someone 

48
00:03:46,360 --> 00:03:50,895
very clever has designed a, an AI, 
artificial intelligence algorithm for 

49
00:03:50,895 --> 00:03:53,915
somehow producing the correct goal 
points. 

50
00:03:53,915 --> 00:03:59,697
And then, at the low-level, well, that's 
where our navigation architecture sits. 

51
00:03:59,697 --> 00:04:04,777
That's where we're assuming that x dot is 
equal to u, which really tells the robot, 

52
00:04:04,777 --> 00:04:09,879
if I'm here, this is x, then u is really 
going to be, this is the direction in 

53
00:04:09,879 --> 00:04:15,316
which I would like to move. 
So, the navigation architecture we've 

54
00:04:15,316 --> 00:04:20,393
seen really sits squarely at the 
low-level planning layer. 

55
00:04:20,393 --> 00:04:27,092
And then, of course the execution level. 
Well, one thing we can do is simply say, 

56
00:04:27,092 --> 00:04:32,052
here is our actual system. 
Let's say x dot is, oh, let's, let's say, 

57
00:04:32,052 --> 00:04:36,882
it's a complicated nonlinear system. 
This is a slithering robot, that every 

58
00:04:36,882 --> 00:04:40,762
now and then, can fly. 
I don't know how to build that, but if I 

59
00:04:40,762 --> 00:04:45,812
did, that's what this system would be. 
And now, I would like it to follow, let's 

60
00:04:45,812 --> 00:04:49,637
say, this reference. 
And this reference is generated as if x 

61
00:04:49,637 --> 00:04:52,344
dot is equal to u. 
Well, this is simply r, right, a 

62
00:04:52,344 --> 00:04:56,219
reference signal. 
And we have seen repeatedly how to design 

63
00:04:56,219 --> 00:05:01,199
controllers for making systems, general 
systems, track reference signals. 

64
00:05:01,199 --> 00:05:05,966
So, the execution problem be, really 
becomes a question of how do you track 

65
00:05:05,966 --> 00:05:10,880
reference signals? Well, we kind of know 
how to do this, at least for linear 

66
00:05:10,880 --> 00:05:14,662
systems, so that seems rather promising, 
as far as I can, 

67
00:05:14,662 --> 00:05:18,262
I can tell. 
Okay, let's discuss these levels a little 

68
00:05:18,262 --> 00:05:21,587
bit more. 
at the high-level, like I said, it's 

69
00:05:21,587 --> 00:05:26,730
really not part of the, the course, there 
are many, many different ways in which 

70
00:05:26,730 --> 00:05:30,837
people think about how to produce these 
high-level plans. 

71
00:05:30,837 --> 00:05:35,462
Typically, you somehow discretize the 
world into a graph structure or somehow, 

72
00:05:35,462 --> 00:05:41,209
a kind of grid structure and then you can 
use Dijkstra's algorithm for searching 

73
00:05:41,209 --> 00:05:44,625
through graphs, something called Dynamic 
Programming. 

74
00:05:44,625 --> 00:05:49,414
There are more specialized robotic 
planning algorithms, something called A*, 

75
00:05:49,414 --> 00:05:53,792
a version of A* called D*, which is a 
dynamic version of A*, or something 

76
00:05:53,792 --> 00:05:56,873
called RRTs, Rapidly Exploring Randomized 
Trees. 

77
00:05:56,873 --> 00:06:01,202
These are all methods for generating 
these intermediary waypoints. 

78
00:06:01,202 --> 00:06:05,979
And this big picture here, you're seeing 
underneath it is, this is the kind of 

79
00:06:05,979 --> 00:06:10,781
maps that we produce at the high-level 
kind of plans and maps we produce at the 

80
00:06:10,781 --> 00:06:15,000
high-level at, when we're building this 
autonomous self-driving car. 

81
00:06:15,000 --> 00:06:19,641
So, this map clearly doesn't tell us how 
the car should drive but it tells us 

82
00:06:19,641 --> 00:06:25,001
where do we want to go and how are the 
things that we want to go to connect it. 

83
00:06:25,001 --> 00:06:28,098
So, 
all I want to say about this is if your'e 

84
00:06:28,098 --> 00:06:33,759
interested in probing further when it 
comes to high-level methods this six 

85
00:06:33,759 --> 00:06:39,266
different methods are good places to 
start if you want to to learn more about 

86
00:06:39,266 --> 00:06:44,745
these high-level methods. 
Okay, low-level, well, ta-da, we already 

87
00:06:44,745 --> 00:06:49,842
know how to do this. 
The simplest thing is to assume a very 

88
00:06:49,842 --> 00:06:56,604
simple model, in our case, we've said x 
dot is equal to u, and then we simply go 

89
00:06:56,604 --> 00:07:00,434
to work. 
Again, if I do that, my model, x dot is 

90
00:07:00,434 --> 00:07:04,191
equal u model, 
is going to produce a trajectory that we 

91
00:07:04,191 --> 00:07:09,945
would like the actual robot to follow. 
So, this trajectory becomes the plan, the 

92
00:07:09,945 --> 00:07:15,022
low-level plan that will take us, let's 
say, that here is a, a goal point and 

93
00:07:15,022 --> 00:07:19,297
here was an obstacle. 
Well, this low-level plan will tell us 

94
00:07:19,297 --> 00:07:24,490
how we should go about avoiding the 
obstacle and going to goal, but it 

95
00:07:24,490 --> 00:07:30,516
doesn't at all tell us how to achieve it, 
which leaves us with the execution level. 

96
00:07:30,516 --> 00:07:36,271
as you can see, this is the video that 
I've shown before of our self-driving car 

97
00:07:36,271 --> 00:07:39,473
that is trying to to drive around in the 
world. 

98
00:07:39,473 --> 00:07:43,867
Well, the car, it's not a unicycle, but 
it's almost a unicycle. 

99
00:07:43,867 --> 00:07:48,882
but, if we're trying to build a 
navigation system explicitly for a 

100
00:07:48,882 --> 00:07:53,047
unicycle, it's not going to work, it's 
going to be too complex. 

101
00:07:53,047 --> 00:07:58,612
So, what we had to do in order to make 
this car actually drive, was well, plan 

102
00:07:58,612 --> 00:08:03,990
at a high-level, then a low-level, and 
then make the car execute the trajectory. 

103
00:08:03,990 --> 00:08:08,586
So, for instance here, you're seeing the 
car overtaking an obstacle and what's 

104
00:08:08,586 --> 00:08:13,169
going on here is that we have a low-level 
planner that's telling it roughly how to 

105
00:08:13,169 --> 00:08:15,649
do it. 
And as you can see, the car overshoots a 

106
00:08:15,649 --> 00:08:19,779
little bit and this is due to the fact 
that the execution level reference 

107
00:08:19,779 --> 00:08:24,372
trajectory isn't perfect. 
Okay, so, what we've now arrived at is a 

108
00:08:24,372 --> 00:08:30,792
layered architecture where at the highest 
level, we're generating sequences of 

109
00:08:30,792 --> 00:08:35,927
intermediary waypoints. 
Well, those waypoints are fed into the 

110
00:08:35,927 --> 00:08:41,717
plan level or the low-level plan level 
where our navigation architecture 

111
00:08:41,717 --> 00:08:47,508
generates reference trajectories. 
Well, these reference trajectories are 

112
00:08:47,508 --> 00:08:50,952
then fed into our actual nonlinear 
systems. 

113
00:08:50,952 --> 00:08:56,858
The actual dynamics were u now, well, 
it's going to be function of this state, 

114
00:08:56,858 --> 00:09:02,478
and r, where r is the reference and then 
out of the trajectory comes the actual 

115
00:09:02,478 --> 00:09:08,930
trajectory, the actual control signals 
that will be running on the robot. 

116
00:09:08,930 --> 00:09:15,617
So, what I want to do in the next lecture 
is take this high-level view of a layered 

117
00:09:15,617 --> 00:09:22,278
architecture for robots and apply it to 
the [UNKNOWN] or 2-differential drive 

118
00:09:22,278 --> 00:09:25,634
mobile robots, in general. 
So that's it. 