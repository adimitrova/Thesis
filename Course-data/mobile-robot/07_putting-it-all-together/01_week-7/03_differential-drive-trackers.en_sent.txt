in the last lecture, we saw that one way  of overcoming this inherent or seeming  tension between x.+u was a way of  generating, references,  and the actual robot dynamics was to  introduce a layered architecture,  where you had a planner that planned  reference directories, and a tracker that  tracked these reference directories.
what i want to do today, in today's  lecture is, see how do we make, this,  architecture concrete for the particular  example of a differential drive wheeled  mobile robot.
and if you recall, going back in time to  module 2,  a differential drive mobile robot has 2  wheels,  and the wheel velocities can be  independently controlled.
so we have v sub l for the left wheel,  and v sub r for the right wheel.
and if,  this robot is located at x,y and in this  case it's heading straight up.
so this is the angel phi then we saw that  the dynamic for the differential drive  mobile robot was given by this  expression.
we also quickly realize that there was  something.
rather unintuitive about this.
it's hard to feel real velocities.
it's much easier to feel what' happening  if you're, assuming that you can control  the speed of the robot directly and the  angler velocity meaning how quickly  you're turning.
if you're doing that you instead get a  unicycle model.
the differencial drive mobile robot,  dynamics is not the unicycle dynamics but  it's close, and infact module 2 part of  the the things we did in that module was  connection these 2 and we actually  derived, derived this expression where  the right and the left wheel volocities  could be related to ve anomia directly  meaning, the control signals we produce  under the unicycle assumption can be  directly mapped onto v sub r and v sub l.  and that's nice.
because v and [inaudible] are intuitively  clear about v sub r and v sub l are not.
so, the way we think about differential  drive mobile robots is really in terms of  unicycles.
and then, we make this final  transformation onto the actual real  velocities before resending the, the com  the actuation commands.
so that's the model we have to deal with.
well, if we now buy that we can use  unicycles then, we really have already  seen how to make the unicycle go in a  desired direction.
so here is the unicycle model again.
well i would like it to go in the  direction phi sub d or phi desired.
well, we actually saw early on that, why  not use a pid regulator?
well, if i let  the error between the desired angle and  the actual angle, be given by e, and in  particular, if you don't do e but you use  arc tan 2 of sine phi [unknown] minus phi  comma cosine, the same thing.
then you get something that's between -pi  and pi,  then you don't have to worry about the  angles being, poorly behaved.
well, if you use a pid regulator.
then we've seen that this actually allows  us to track this, reference direction,  theta or phi sub d, rather elegantly.
and,  as a recap, this is what the pid  regulator looks like.
it looks rather hairy, but, we also saw  how to implement it in a rather direct  way.
so we know, already, how to track angles.
well, all we need to do then is add in  the speed component.
so, let's assume that the low level  planner has given us a desired velocity,  u, where we have assumed then, that x  does equal to u.  well, we have, actually, the unicycle,  right?
and now, this vector, is actually  the desired direction and magnitude, we  want to move in, and, why not simply set  that equal to u?
u is the desired  velocity.
well, if we do that, then we can start  seeing, okay, how do we get, desired  headings out, and what should our  velocity be?
well, it's very simple.
if we simply take arc tangents of u2 over  u1, where u2 is the y component of u, and  u1 is the x component, then that is the  angle.
so phi desired, we get for free.
all that remains to be designed, then, is  the velocity component, but hey check  this out.
if i take the unicycle model and i take x  dot squared plus y dot squared and then i  take the square root of this, i get this  square root here.
well, that is the square root of v^2  cosine squared phi plus sin^2 phi.
well, this is one of the well-known  trigonometric identities.
this is exactly equal to 1, so all i get  is square root of v ^ 2.  which is v itself.
so what i noticed is that, if i'm moving  the unicycle around.
the magnitude of this vector in the  direction i'm going with.
well, that's v.  well, but i know what the magnitude is of  the u vector.
it's just the absolute value, or the, the  norm of u.  so what this simply means, is.
you know what?
v should be equal to the  norm of u.  well, the norm of u is the square root of  v1^2+u2^2.
so, i immediately know, not only which  direction i would like to go in but how  quickly i should go in that direction.
so, the way to build a tracker for the  unicycle robot is simply to take arc  tangents of u2 over u1 as the desired  heading, and then let omega be equal to  pid of e, where e is phi desired minus  phi, and v be the magnitude of the u  vector itself.
that's good news, because this gives us  all we need.
before, as before, we plan using our  navigation algorithm.
out of the navigation algorithm comes u1  and u2, the direction in which we would  like to move.
well, at the end of the day, the tracker  needs to spit out v sub r and v sub l,  which is derived from the left wheel  velocities for the differential drive  mobile robot, and now we know what to put  inside a tracker block.
if i desire, the desired heading is the  arc tangents of u2 over u1 then we use a  pid regulator, for instance, or some  other regulator, for regulating the  angle.
so omega = pid of phi desired - phi.
the velocity is simply the magnitude of  the u vector, which we know how to  compute now.
so, this gives us omega and v for the  unicycle.
and then we take this and map it onto the  left and right wheel velocities of the  actual robot.
so this means that we can actually  successfully use this layered arcitecture  for our differential drive mobile robots,  and this is the way we did it in the  experiments that we saw in the previous  module.
now, for the unicycle.
there is an even more clever trick that  is not involving layered architecture,  but it's letting the unicycle really act  like x dot = u.  and in the next lecture, we will not use  this pid based tracker, but this clever  trick as a way of being eeven more  elegant when handling differential drive  mobile robots.
