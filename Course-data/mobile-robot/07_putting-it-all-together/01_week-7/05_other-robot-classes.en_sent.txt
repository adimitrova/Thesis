the punch line with last lecture was that  we can, in fact, make the unicycle model  or a differential drive mobile robot, act  like a simple x dot equal to u.  what this means is that if we have some  desired direction we want to go in,  direction and magnitude, we can come up  with v's and omega's, speeds and angular  velocities that make the differential  drive robot execute this controller.
and we did it in two ways.
first, we saw that we can actually use  some kind of tracking controller to  follow this.
but then, in last lecture, we came up  with a rather clever transformation that  allowed us to, to actually track this u  vector more or less perfectly.
and when i say more or less, what i mean  is that we really ignored orientation.
so, we only cared about where the robot  actually was,  not particularly which direction it was  pointing.
and we couldn't track or used the  original point, we had to accept this  small offset error.
but it was rather elegant, because no  longer did we have to design trackers.
the question one should ask then, of  course, is does this apply to other types  of robots?
meaning, this idea of starting  with a unicycle and then somehow making  it behave well,  how, how relevant is that to other kinds  of robots?
so, we have dealt with the  differential drive robots.
we know that it's super important in  relevance to that but you know what, what  if you have flying things?
what if you  have snake bots?
what if you have, this  is called a snake board, what if you have  fixed-wing aircrafts or blimps or  underwater robots?
does this even apply?
well,  what i want to do today is basically see  that it does supply but, it does supply  if you squint your eyes a little bit and  focus on what these types of robots have  in common as opposed to what they don't  have in common.
so, what i want to do today is simply go  through a smorgasbord of different robot  classes and see how they actually are  like unicycles or maybe not.
we'll see.
okay.
here's the unicycle,  right?
we have, as always, position, x y,  and it's pointing in some direction,  phi, this is the standard robot model.
so, the states are position and  orientation.
the inputs to this model, this  abstraction, are angular and  transalational velocitiies.
meaning, how quickly do you turn and how  fast do you go.
well, let's start expanding this model to  encompass slightly more elaborate  systems.
so, let's start with what's called a  car-like robot.
a car-like robot is not a unicycle  because all of a sudden, we have more  states.
we have our old friends which is x and y,  which is the position.
we have phi which is the orientation, but  then we also have a new angle known as  the steering angle.
so, here is the picture we should have in  mind.
here's a car, here are the rear wheels.
well, the front wheels are going to be  turned because we're turning the steering  wheel.
so, if i call this point here, x and y,  as always, then this, of course, is, as  before, the heading.
and now, we also have this angle here,  which is psi, known as the steering  angle,  how much are we actually steering it.
and  all i wanted to show here is that we have  almost the same equation for x and y, the  only difference is that we are now going  in this direction, which is phi plus psi.
and then, the orientation has its own  dynamics that's a function of the  velocity and the steering angle.
and then, what we can do is we can  control how quickly we're steering.
so, psi dot is equal to u.  so, this is the next level up in  complexity where we no longer have a  unicycle but a car-like robot, four  wheels we can turn the front wheels.
well we've already seen the segway robot.
so, the segway robot is really a unicycle  or a differential drive robot at the  base.
and then, you know, this, this mess here.
i drew it like this because it actually  didn't fit in the box if i didn't make it  small and sideways.
the point is that, we had a rather  complicated equation describing the  pendulum part or the part that's sitting  on top of the unicycle.
so, we had a bunch of states, position,  orientation, tilt, angle, and here, we  actually had to deal with the tilt  velocities and other kinds of velocities  because we actually need to get into  dynamics.
many accelerations of what's happening  for this thing not to fall over and the  inputs were the wheel torques to this  model.
the point now is that this still has a  unicycle underneath and then this mass  sitting on top of it.
so, that would, would be the segway robot  that we actually already seen.
well, what about flying things?
well, a  standard model for a fixed-wing aircraft  is ta-da, a unicycle, right?
which means,  it's moving.
and then, it can change altitude.
so now, no one in their right mind would  actually say that this is what a,  an aircraft is actually doing but from a  high level obstruction point of view,  it's not a bad idea.
an aircraft can't go sideways but it can  kind of move like a unicyle in, in the  plane.
and then, you can change altitude.
now, you would actually have to couple  this to the real dynamics of the aircraft  if you wanted to do it for real.
the one thing to note though is that  there is something slightly fishy about  this and that's the fact that the fixed  wing aircraft cannot hover.
when you can't have v=0, but there's  really no constraint or no way of  capturing this in, this model, we see  later how to do it, but the point here is  that there are ways of thinking about  flying things as unicycles plus an  altitude component.
now, let's look at another model.
this is the standard model of an  underwater glider,  and, well, let's go back a slide.
aircraft, underwater glider, nothing  changed, right?
so, an underwater glider, people  typically model as a unicycle.
and then, you can go up and down.
so, you can go down to a lower depth or  you could climb up towards the surface.
so, again, unicycle plus an altitude or a  vertical component that describes how  high up or high down the, the robot  actually is.
well,  all of these robots have some notion of  where it is at least in the plane and  where it's pointing.
and if i call position plus heading for  pose, the punchline, at least based on  the models i showed you, cars, segways,  flying things, things on the water, and  as we know, differential drive robots,  they have this key thing to it known as  pose.
and pose is x, y, and phi.
you know, that's just, that's just what's  going on, where is it and which way is it  pointing.
it's pointing in the phi direction  instead of the x and y.  well, you know what, if you ignore the  dynamics, the actual dynamics and say at  the certain high level abstraction, we  already know how we should think about  this,  the unicycle.
so, almost everything  involves a pose.
and almost everything with pose is almost  a unicycle and i will make this more  precise.
but the point here is that whenever you  start dealing with postion and heading,  the unicycle model is applicable, maybe  not perfectly, but fairly well.
so, this model is still very, very rich.
so, the punchline then becomes that we  can almost use everything that we've  already done and then possibly add  another layer to to what's going on.
so, what you have, is you have, let's  say, your, your u plan, right, that comes  into your unit cycle, and out of that  comes our old friends, v and omega, and  then, whatever actual robot you have is  going to move like this.
[sound] and the point is that, in here,  we may be forced to somehow make the  actual robot look like a unicycle a  little bit.
but it's just another layer to our  already elegant and well-layered  architecture that we've discussed.
and, in fact, next time, what i want to  do is exactly this for the car robot, to  see how do you make a car act like a  unicycle and this is something i had to  do when i was dealing with the autonomous  self-driving cars.
we were reasoning about them at the level  of position and orientation and speeds  and angular velocities but then we have  to map it back onto the, onto the, the  car robot.
before we do that though, i need to talk  a little bit about constraints.
what i mean, mean by that is if you're  flying, for instance,  you can't hover.
you're going to have a certain minimum  velocity or a lot of times, it's  convenient to assume a fixed velocity and  then you can turn.
but here's an aircraft.
it can't immediately or very quickly just  spin either.
so, there are caps on how quickly you can  actually turn.
well, the most famous of all constrained  unicycle type models is known as dubins  vehicle.
and all it is is a unicycle with  the added caveat that we can only fly  with v=1 or drive with v=1, meaning we're  going to go with a constant velocity and  we have a max and a minimum angular  velocity.
if you want, you can say, you know, v0  there and omega v max or omega max plus  omega max instead of -1 and 1, but the  point is that we're constraining the  velocities.
this means, that dubins vehicle can  basically execute straight lines, it can  go along paths like this so, so it can go  along angles, i mean, along circular  arcs.
or it can go anything in between,  right?
but basically, you have, you  cannot go arbitrarily tight with a dubins  vehicle.
so, this is one way in which people  incorporate constraints.
and this makes the planning part  significantly harder.
we're not going to cover it, but i  encourage you to look up dubins vehicles,  for instance, to see how people think  about curvature constrained versions of  unicycles, for instance.
well, another version or another standard  constraint that people deal with is  what's known as the reeds-shepp model,  where omega again, is between -1 and 1,  or negative omega max and omega max, and  v can now be, well, the absolute value of  v is 1, which means that v is either +1  or -1, meaning it's a dubins vehicle that  can also go backwards.
that's all that this means.
you can go forward along these arcs or  you can actually pull back in in reverse.
and reeds-shepp is also a standard type  of model that people like to deal with  when they're dealing with mobile robots.
now, aircrafts typically can't back so  it's not a par, all that relevant of a  model for fixed wind aircraft, for  instance.
but there are, for instance, robots,  at the end of the day, we have a top  speed, for instance,  so we can't go faster than v=vmax, so,  but we can indeed go backwards.
so, the reeds-shepp model would not be a  bad model if you actually want to take  max velocities into account.
so, remember that this may or may not  come into play.
the last thing i want to say though is  that there are, of course, robots where  pose is not a reasonable way of  describing them.
you know, you have a humanoid, well,  people will have maybe a position and  orientation but there is so much more  going on in a humanoid.
a snake, you know, which way is the snake  pointing, well, you know, if the snake  looks like this, what's, what's the  orientation of the snake?
it's very  unclear.
what's the position of the snake?
who  knows?
it's not clear what we mean by  that.
same thing, we would like mobile  manipulators like this robots that we  have here at georgia tech, where, well,  the base is a unicycle.
so, if you only care about the base,  fine.
but if you want to do more things like  carry things around or opening doors and  so forth, we have to care about more than  the just the pose,  more than just position and orientation.
so, there are situations where we have to  worry about more things, but in a  surprising amount of situations, pose is  indeed the way to go.
and like i said, the next lecture will be  about cars and how to actually make a car  behave like a unicycle.
