1
00:00:00,012 --> 00:00:03,384
>> Welcome to the last module of this
entire course.

2
00:00:03,385 --> 00:00:08,043
In this module, Module 7, I will be
putting all of the pieces that we have

3
00:00:08,043 --> 00:00:11,418
developed together into one neat unified
package.

4
00:00:11,418 --> 00:00:17,040
And what we're going to have to do in this
module is, connect the robotics piece that

5
00:00:17,040 --> 00:00:22,422
we discussed early on differential drive,
mobile robots, odometry sensors to the

6
00:00:22,422 --> 00:00:26,373
control theoretic developments that we've
gone through.

7
00:00:26,373 --> 00:00:31,547
And in particular, we need to see how we
can take the navigation algorithms we have

8
00:00:31,547 --> 00:00:36,867
developed, and actually make them fit onto
the actual robotic platforms that we're

9
00:00:36,867 --> 00:00:40,710
interested in.
And the first lecture is really going to

10
00:00:40,710 --> 00:00:45,548
be a little bit of a high level
discussions of what are the things that we

11
00:00:45,548 --> 00:00:49,537
need to be aware of when we start putting
things together.

12
00:00:49,537 --> 00:00:54,343
I've call it approximations and
abstractions and the reason for that is

13
00:00:54,343 --> 00:00:59,783
whenever we try to design control systems
or navigation algorithms, we're using

14
00:00:59,783 --> 00:01:02,872
models.
And we need to understand when these

15
00:01:02,872 --> 00:01:06,678
models are indeed relevant or useful, or
applicable.

16
00:01:06,678 --> 00:01:11,213
So, recall our rather messy, yet exciting
hybrid automoton.

17
00:01:11,213 --> 00:01:16,460
When we developed this, we assumed that we
had perfect sensing.

18
00:01:16,460 --> 00:01:22,883
We even assumed that x dot was equal to u,
meaning that we directly could control the

19
00:01:22,883 --> 00:01:28,266
velocities of, of the robot.
But then, as we saw at the end of the last

20
00:01:28,266 --> 00:01:32,423
module, we ran it on a differential drive
mobile robot.

21
00:01:32,423 --> 00:01:38,392
And these two robot, or systems, the
actual differential drive mobile robot and

22
00:01:38,392 --> 00:01:43,134
x dot equal to u, it's very unclear what
they even have in common.

23
00:01:43,134 --> 00:01:48,240
How do we make our models fit the reality,
or more importantly, when are the models

24
00:01:48,240 --> 00:01:52,540
relevant to the real world?
Well, I like to think of models as fables.

25
00:01:52,540 --> 00:01:56,177
Let's return to our old friend, the hare
and the tortoise.

26
00:01:56,177 --> 00:02:00,786
So, when we discuss the Zeno phenomenon,
we had the hare race the tortoise.

27
00:02:00,786 --> 00:02:06,168
Well, I don't exactly know where all of
you live but chances are that where you

28
00:02:06,168 --> 00:02:10,805
live, very rarely do you see hares and
tortoises actually racing.

29
00:02:10,805 --> 00:02:16,223
So, here's a story or a fable that never
applies, but somehow, we still gain some

30
00:02:16,223 --> 00:02:19,933
kind of insight into the real world from
this story.

31
00:02:19,934 --> 00:02:23,067
Like, slow and steady wins the race if the
tortoise wins.

32
00:02:23,067 --> 00:02:25,828
Or, in the Zeno case, the hare is going to
win.

33
00:02:25,828 --> 00:02:30,122
Well, what we should take away from that
is, well, don't rush it when you're doing

34
00:02:30,122 --> 00:02:33,942
the quizzes for this course.
So now, the hare and the tortoise actually

35
00:02:33,942 --> 00:02:37,244
had something to say about how we should
approach the course.

36
00:02:37,244 --> 00:02:41,651
And similarly, the models are fables.
They have some relevance, but they're not

37
00:02:41,651 --> 00:02:45,885
exactly telling the full story.
So, let's take a step back and see what

38
00:02:45,885 --> 00:02:51,198
assumptions did we actually make and what
kind of models did we actually use when we

39
00:02:51,198 --> 00:02:55,737
were talking about the robots.
Well, we really had two main classes of

40
00:02:55,737 --> 00:02:58,131
assumptions.
One was the dynamics.

41
00:02:58,131 --> 00:03:04,025
And when we developed our control
algorithms, we made the assumption that we

42
00:03:04,025 --> 00:03:10,465
had this particle located at x, where we
immediately controlled the velocity, x dot

43
00:03:10,465 --> 00:03:14,716
is equal to u.
Well, that may or may not be reasonable.

44
00:03:14,716 --> 00:03:19,721
We also made this assumption that the
robot has a sensor suite.

45
00:03:19,721 --> 00:03:25,661
It's actually one of these sensor skirts
that allows the robot to see roughly, a

46
00:03:25,661 --> 00:03:31,509
disk around it that's not exactly true,
because as we saw in the last module, we

47
00:03:31,509 --> 00:03:37,093
only see certain parts of this disk.
But from, in assumption point of view, we

48
00:03:37,093 --> 00:03:43,113
still kind of made the assumption that, we
cannot, we can see everything around us up

49
00:03:43,113 --> 00:03:48,015
to a point and we can measure where
obstacles are and the angle to that

50
00:03:48,015 --> 00:03:51,465
obstacle.
When it turns out that the sensing

51
00:03:51,465 --> 00:03:56,575
assumption is more or less okay.
As the robot moves around, you can

52
00:03:56,575 --> 00:04:02,335
actually build up rather accurate models
or, or maps of what's going on in the

53
00:04:02,335 --> 00:04:05,587
world.
The problem is with the dynamics.

54
00:04:05,587 --> 00:04:08,950
This is not even close to being
reasonable.

55
00:04:08,950 --> 00:04:14,962
The Khepera [inaudible] that we've used a
lot, it's not, at all, looking like x dot

56
00:04:14,962 --> 00:04:18,988
is equal to u.
So, in order for our fable, or our model,

57
00:04:18,988 --> 00:04:24,904
or our navigation algorithm to be relevant
to the actual robot, we somehow need to

58
00:04:24,904 --> 00:04:30,360
remedy this lack of reasonability.
So, the problem, of course, is that we

59
00:04:30,360 --> 00:04:35,130
have the point mass.
And then we're using the unicycle model

60
00:04:35,130 --> 00:04:41,658
for actually describing the robot, where x
dot is v cosine phi, where v is the speed

61
00:04:41,658 --> 00:04:47,898
and phi is the heading, y dot was v sine
phi, and phi dot was equal to omega, where

62
00:04:47,898 --> 00:04:53,817
omega was the angular velocity.
Well, this robot, this model, doesn't act

63
00:04:53,817 --> 00:04:59,732
like x dot is equal to u and somehow for
what we've done during the last couple of

64
00:04:59,732 --> 00:05:05,374
modules to be relevant, we need to make
these two models actually co-exist

65
00:05:05,374 --> 00:05:09,957
peacefully.
So, what we're going to spend the next two

66
00:05:09,957 --> 00:05:17,233
lectures on is a very, very simple problem
which is, how do we make a unicycle robot

67
00:05:17,233 --> 00:05:22,821
or a differential drive model robot act
like x dot is equal to u?