In the last lecture, we saw that one way 
of overcoming this inherent or seeming tension between x.+u was a way of 
generating, references, and the actual robot dynamics was to 
introduce a layered architecture, where you had a planner that planned 
reference directories, and a tracker that tracked these reference directories. 
What I want to do today, in today's lecture is, see how do we make, this, 
architecture concrete for the particular example of a differential drive wheeled 
mobile robot. And if you recall, going back in time to 
module 2, a differential drive mobile robot has 2 
wheels, and the wheel velocities can be 
independently controlled. So we have v sub l for the left wheel, 
and v sub r for the right wheel. And if, 
this robot is located at x,y and in this case it's heading straight up. 
So this is the angel Phi then we saw that the dynamic for the differential drive 
mobile robot was given by this expression. 
We also quickly realize that there was something. 
Rather unintuitive about this. It's hard to feel real velocities. 
It's much easier to feel what' happening if you're, assuming that you can control 
the speed of the robot directly and the angler velocity meaning how quickly 
you're turning. If you're doing that you instead get a 
unicycle model. The differencial drive mobile robot, 
dynamics is not the unicycle dynamics but it's close, and infact module 2 part of 
the the things we did in that module was connection these 2 and we actually 
derived, derived this expression where the right and the left wheel volocities 
could be related to VE anomia directly meaning, the control signals we produce 
under the unicycle assumption can be directly mapped onto v sub r and v sub l. 
And that's nice. Because v and [INAUDIBLE] are intuitively 
clear about v sub r and v sub l are not. So, the way we think about differential 
drive mobile robots is really in terms of unicycles. 
And then, we make this final transformation onto the actual real 
velocities before resending the, the com the actuation commands. 
So that's the model we have to deal with. Well, if we now buy that we can use 
unicycles then, we really have already seen how to make the unicycle go in a 
desired direction. So here is the unicycle model again. 
Well I would like it to go in the direction phi sub d or phi desired. 
Well, we actually saw early on that, why not use a PID regulator? Well, if I let 
the error Between the desired angle and the actual angle, be given by E, and in 
particular, if you don't do E but you use arc tan 2 of sine phi [UNKNOWN] minus phi 
comma Cosine, the same thing. Then you get something that's between -pi 
and pi, then you don't have to worry about the 
angles being, poorly behaved. Well, if you use a PID regulator. 
Then we've seen that this actually allows us to track this, reference direction, 
theta or phi sub d, rather elegantly. And, 
as a recap, this is what the PID regulator looks like. 
It looks rather hairy, but, we also saw how to implement it in a rather direct 
way. So we know, already, how to track angles. 
Well, all we need to do then is add in the speed component. 
So, let's assume that the low level planner has given us a desired velocity, 
u, where we have assumed then, that x does equal to u. 
Well, we have, actually, the unicycle, right? And now, this vector, is actually 
the desired direction and magnitude, we want to move in, and, why not simply set 
that equal to u? U is the desired velocity. 
Well, if we do that, then we can start seeing, okay, how do we get, desired 
headings out, and what should our velocity be? Well, it's very simple. 
If we simply take arc tangents of u2 over u1, where u2 is the y component of u, and 
u1 is the x component, then that is the angle. 
So phi desired, we get for free. All that remains to be designed, then, is 
the velocity component, but hey check this out. 
If I take the unicycle model and I take X dot squared plus Y dot squared and then I 
take the square root of this, I get This square root here. 
Well, that is the square root of v^2 cosine squared phi plus sin^2 phi. 
Well, this is one of the well-known trigonometric identities. 
This is exactly equal to 1, so all I get is square root of v ^ 2. 
Which is v itself. So what I noticed is that, if I'm moving 
the unicycle around. The magnitude of this vector in the 
direction I'm going with. Well, that's v. 
Well, but I know what the magnitude is of the u vector. 
It's just the absolute value, or the, the norm of u. 
So what this simply means, is. You know what? V should be equal to the 
norm of u. Well, the norm of u is the square root of 
v1^2+u2^2. So, I immediately know, not only which 
direction I would like to go in but how quickly I should go in that direction. 
So, the way to build a tracker for the unicycle robot is simply to take arc 
tangents of u2 over u1 as the desired heading, and then let omega be equal to 
PID of e, where e is phi desired minus phi, and v be the magnitude of the u 
vector itself. That's good news, because this gives us 
all we need. Before, as before, we plan using our 
navigation algorithm. Out of the navigation algorithm comes u1 
and u2, the direction in which we would like to move. 
Well, at the end of the day, the tracker needs to spit out V sub R and V sub L, 
which is derived from the left wheel velocities for the differential drive 
mobile robot, and now we know what to put inside a tracker block. 
If I desire, the desired heading is the arc tangents of U2 over U1 Then we use a 
PID regulator, for instance, or some other regulator, for regulating the 
angle. So omega = PID of phi desired - phi. 
The velocity is simply the magnitude of the u vector, which we know how to 
compute now. So, this gives us omega and v for the 
unicycle. And then we take this and map it onto the 
left and right wheel velocities of the actual robot. 
So this means that we can actually successfully use this layered arcitecture 
for our differential drive mobile robots, and this is the way we did it in the 
experiments that we saw In the previous module. 
Now, for the unicycle. There is an even more clever trick that 
is not involving layered architecture, but it's letting the unicycle really Act 
like x dot = u. And in the next lecture, we will not use 
this PID based tracker, but this clever trick as a way of being eeven more 
elegant when handling differential drive mobile robots.