we saw that the one remaining challenge  is, how do we actually make our real  robot or a model of the real robot, which  was the unicyle model, behave or act like  the simpler model x dot is equal to u,  that we used when we designed our  navigation architecture.
and we really have a problem because we  used the simplest possible model,  x dot equal to u, as the basis for our  control design.
and then, we started switching between go  to goal, follow wall, follow wall  counterclockwise avoid obstacles and so  forth.
and the navigation architecture we  ended up with is this, as we've seen a  couple of times now, rather messy-looking  hybrid system.
now, what we need to do is somehow come  up with a way of making the real robot  relevant or this model relevant to the  real robot.
and  we would like also to do this in such a  way that we don't have to worry too much  about what kind of robot is it that we're  using?
we want this navigation  architecture to be relevant for  differential drive robots or 4-wheel  robots or snake robots or flying  quadrotors.
so, the question is, how do we do this?
and the standard way of approaching this  problem is to produce a layered  architecture, where you have different  levels of abstraction.
so, in today's  lecture, i'm going to talk about the  standard layers that people think of when  they build architectures high-level  architectures for robotic systems.
well, the standard and most canonical way  in which people approach this is to have  three levels and borrowing terms from the  military tactical literature people  typically talk about a strategic level  and operational level and a tactical  level.
so, the strategic level is high level.
where do we go?
recall, for instance,  that we have go to golal behaviors,  we have a goal point, well, where did  that goal point come from?
who decided  that that's reasonable?
well, that happens at the strategic  level, where the high level decisions are  being made.
and then at the operational level, you're  trying to figure out, okay, i know that  there is a goal point somewhere out  there, where do i go now?
meaning, this  is a short term, low-level planning  problem.
and in many ways, we can think  of our x dot equal to u model to live at  the operational level.
but then, we have the lowest level, the  tactical level, which asks, well, okay, i  know that i want to go this way but how  do i actually do that?
i am snake robot, how does a snake go in  this direction or i am a differential  drive mobile robot,  a unicycle, how do i actually go in this  direction?
so, the question of mapping x  dot equal to u onto the real robot is a  question of moving in between these two  levels or layers in the architecture.
while, if you want to be slightly less  militaristic,  which, maybe we do we can call the  highest level a high-level planning  level.
we want to plan where the intermediary  goal points should really be.
and then, the low-level planning that's  the question of which direction to move  in-between these goal points.
and then at the execution level that we  previously called the tactical level,  it's just a matter of how do we actually  execute this?
how do we make the robot do  what it is that we want it to do?
and i  should point out that the highest level,  we haven't touched at all in this course.
in fact, we have assumed that someone  very clever has designed a, an ai,  artificial intelligence algorithm for  somehow producing the correct goal  points.
and then, at the low-level, well, that's  where our navigation architecture sits.
that's where we're assuming that x dot is  equal to u, which really tells the robot,  if i'm here, this is x, then u is really  going to be, this is the direction in  which i would like to move.
so, the navigation architecture we've  seen really sits squarely at the  low-level planning layer.
and then, of course the execution level.
well, one thing we can do is simply say,  here is our actual system.
let's say x dot is, oh, let's, let's say,  it's a complicated nonlinear system.
this is a slithering robot, that every  now and then, can fly.
i don't know how to build that, but if i  did, that's what this system would be.
and now, i would like it to follow, let's  say, this reference.
and this reference is generated as if x  dot is equal to u.  well, this is simply r, right, a  reference signal.
and we have seen repeatedly how to design  controllers for making systems, general  systems, track reference signals.
so, the execution problem be, really  becomes a question of how do you track  reference signals?
well, we kind of know  how to do this, at least for linear  systems, so that seems rather promising,  as far as i can,  i can tell.
okay, let's discuss these levels a little  bit more.
at the high-level, like i said, it's  really not part of the, the course, there  are many, many different ways in which  people think about how to produce these  high-level plans.
typically, you somehow discretize the  world into a graph structure or somehow,  a kind of grid structure and then you can  use dijkstra's algorithm for searching  through graphs, something called dynamic  programming.
there are more specialized robotic  planning algorithms, something called a*,  a version of a* called d*, which is a  dynamic version of a*, or something  called rrts, rapidly exploring randomized  trees.
these are all methods for generating  these intermediary waypoints.
and this big picture here, you're seeing  underneath it is, this is the kind of  maps that we produce at the high-level  kind of plans and maps we produce at the  high-level at, when we're building this  autonomous self-driving car.
so, this map clearly doesn't tell us how  the car should drive but it tells us  where do we want to go and how are the  things that we want to go to connect it.
so,  all i want to say about this is if your'e  interested in probing further when it  comes to high-level methods this six  different methods are good places to  start if you want to to learn more about  these high-level methods.
okay, low-level, well, ta-da, we already  know how to do this.
the simplest thing is to assume a very  simple model, in our case, we've said x  dot is equal to u, and then we simply go  to work.
again, if i do that, my model, x dot is  equal u model,  is going to produce a trajectory that we  would like the actual robot to follow.
so, this trajectory becomes the plan, the  low-level plan that will take us, let's  say, that here is a, a goal point and  here was an obstacle.
well, this low-level plan will tell us  how we should go about avoiding the  obstacle and going to goal, but it  doesn't at all tell us how to achieve it,  which leaves us with the execution level.
as you can see, this is the video that  i've shown before of our self-driving car  that is trying to to drive around in the  world.
well, the car, it's not a unicycle, but  it's almost a unicycle.
but, if we're trying to build a  navigation system explicitly for a  unicycle, it's not going to work, it's  going to be too complex.
so, what we had to do in order to make  this car actually drive, was well, plan  at a high-level, then a low-level, and  then make the car execute the trajectory.
so, for instance here, you're seeing the  car overtaking an obstacle and what's  going on here is that we have a low-level  planner that's telling it roughly how to  do it.
and as you can see, the car overshoots a  little bit and this is due to the fact  that the execution level reference  trajectory isn't perfect.
okay, so, what we've now arrived at is a  layered architecture where at the highest  level, we're generating sequences of  intermediary waypoints.
well, those waypoints are fed into the  plan level or the low-level plan level  where our navigation architecture  generates reference trajectories.
well, these reference trajectories are  then fed into our actual nonlinear  systems.
the actual dynamics were u now, well,  it's going to be function of this state,  and r, where r is the reference and then  out of the trajectory comes the actual  trajectory, the actual control signals  that will be running on the robot.
so, what i want to do in the next lecture  is take this high-level view of a layered  architecture for robots and apply it to  the [unknown] or 2-differential drive  mobile robots, in general.
so that's it.
