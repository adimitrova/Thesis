the
outcome
of
the
last
handful
of
lectures
was
that
we
can
really
use
a
layered
architecture
to
make
our
robots
act
like
a
simpler
system
.
like
x
dot
=
u
,
in
our
case
.
and
they
key
idea
was
to
plan
using
the
simple
dynamics
.
and
then
track
using
some
clever
controller
.
and
what
we
saw
last
time
was
we
could
use
a
pid
regulator
,
for
instance
for
,
controlling
the
heading
of
the
robot
,
and
then
simply
set
the
velocity
of
the
robot
equal
to
the
magnitude
of
the
planned
velocity
,
u.
well
,
today
,
i
want
to
discuss
another
twist
to
this
theme
.
in
fact
,
i
want
to
be
even
more
clever
.
and
there
is
a
particularly
eloquent
and
cute
way
you
can
think
about
unicycles
.
and
in
general
i
'm
not
a
big
fan
of
clever
tricks
for
the
sake
of
clever
tricks
,
but
because
differential
drive
mobile
robots
are
so
common
.
and
we
know
that
unicycles
model
them
well
,
then
this
trick
becomes
more
than
just
a
piece
of
mathematical
curiosity
,
becomes
an
effective
way
of
thinking
about
a
large
,
a
large
and
rich
class
of
mobile
robots
.
so
,
instead
of
doing
tracking
,
we
're
going
to
transform
the
unicycle
dynamics
.
so
recall
that
we
have
the
position
xy
,
we
have
the
heading
phi
,
and
we
have
the
dynamics
as
seen
here
.
well
,
typically
,
what
we
've
seen
so
far
is
,
we
want
the
robot
not
to
slam
into
things
,
we
want
the
robot
to
end
up
on
top
of
goal
points
we
want
the
robot
to
folow
walls
.
we
do
n't
particularly
care
which
way
it
's
pointing
,
so
the
first
thing
we
're
going
to
do
is
say
,
you
know
what
let
's
just
pretend
that
we
do
n't
worry
about
orientation
whatsoever
.
well
,
we
still
have
a
rather
awkward
looking
nonlinear
differential
equation
but
let
,
now
,
pick
another
point
.
let
's
not
pick
x
,
y
,
which
as
you
remember
,
was
really
the
point
right
in
between
the
wheels
of
the
differential-drive
mobile
robot
.
what
if
we
picked
another
point
,
instead
?
let
's
pick
this
point
.
the
red
point
here
.
and
let
's
say
,
that
the
distance
between
,
the
red
point
and
the
black
point
.
that
's
,
that
's
some
distance
l
,
where
l
is
some
small
number
.
what
would
happen
if
we
looked
at
this
new
point
,
instead
?
well
,
let
's
place
the
new
point
at
x
tilde
y
tilde
the
next
tilde
is
simply
x
+
l
cosine
phi
.
simple
geometry
.
and
y
tilde
is
y
+
l
sine
phi
.
where
,
again
,
l
is
the
distance
removing
our
point
along
the
heading
of
,
of
the
robot
.
well
,
let
's
see
what
the
dynamics
of
this
new
point
.
the
tilde
point
actually
looks
like
.
well
,
this
is
our
old
dynamics
this
how
x
and
y
and
phata
actually
behaves
.
this
is
our
new
point
and
now
,
what
we
need
to
do
is
put
dots
over
the
tildes
to
see
.
what
do
the
time
derivatives
actually
look
like
?
well
,
it
's
not
so
complicated
.
x
till
the
dot
,
well
,
it
's
x
dot
+
the
time
derivative
of
this
thing
,
and
,
the
time
derivative
of
cosine
phi
,
and
remember
phi
is
a
function
of
t
,
if
i
take
ddt
of
this
thing
,
then
.
what
i
get
,
is
,
i
get
-
phi
dot
*
sin
phi
.
well
,
that
's
what
we
have
here
,
x
tilde
dot
,
is
x
dot
-
l
phi
dot
sin
phi
,
and
similarly
for
y
,
tilde
dot
.
alright
,
this
still
does
n't
seem
all
that
helpful
,
to
be
completely
honest
,
so
lets
simplify
this
a
little
bit
.
well
,
first
of
all
,
i
know
what
x
dot
is
.
it
's
this
thing
here
,
so
instead
of
that
,
i
'm
just
plugging
in
v
cosine
phi
.
i
also
know
what
phi
dot
is
.
it
's
,
it
's
omega
.
so
,
now
i
end
up
with
a
slightly
,
less
scary-looking
expression
.
and
,
then
we
do
the
same
thing
for
y
tilde
dot
.
well
okay
,
where
does
this
lead
us
?
well
,
let
's
assume
for
a
second
that
we
can
control
this
new
point
directly
.
that
this
new
point
is
indeed
,
the
point
that
we
before
have
called
x
dot
=
to
u
,
as
a
way
of
generating
reference
velocities
.
let
's
assume
that
we
can
actually
immediately
control
this
new
point
.
what
would
that
tell
us
?
well
,
x
tilde
dot
as
you
recall
,
was
given
by
this
mouthful
of
an
expression
.
well
,
let
's
set
this
equal
to
u1
which
is
our
desired
velocity
in
the
x
direction
.
and
similarly
,
we
set
y
tilde
dot
=
u2
.
now
,
all
we
need
to
do
at
least
,
well
i
can
say
all
we
need
to
do
,
i
do
n't
know
if
we
can
do
it
.
but
,
all
we
would
like
to
do
is
actually
solve
this
equation
with
respect
to
v
and
omega
.
because
,
if
we
did
that
,
we
would
relate
the
actual
velocities
of
the
unicycle
to
these
u1
and
u2
velocities
,
which
are
the
planned
velocities
.
so
let
's
see
if
we
can
do
that
.
well
the
first
thing
we
do
is
we
pull
out
the
cosine
and
the
sine
terms
.
so
we
get
that
cosine
*
v
-
sine
*
l
omega
well
that
's
that
thing
,
that
's
equal
to
u1
.
and
similarly
for
the
y
tilde
dot
,
or
the
u2
dot
,
sorry
,
the
u2
equation
.
i
do
n't
know
,
this
equation
still
looks
a
little
hairy
but
,
as
you
hopefully
recall
,
this
matrix
right
here
is
a
rather
nice
matrix
.
it
is
,
in
fact
,
a
rotation
matrix
.
all
it
's
doing
is
it
's
taking
a
vector
and
rotating
it
theta
degrees
.
actually
,
it
's
rotating
it
phi
degrees
,
but
it
is
a
very
well
behaved
and
well
understood
matrix
,
okay
?
i
do
n't
particularly
like
l
there
,
because
l
is
not
part
of
what
i
would
like
.
i
would
like
v
and
omega
and
,
no
l.
so
,
what
i
can
do
,
is
i
can
rewrite
this
thing
as
,
a
matrix
,
a
diagonal
matrix
,
with
one
on
the
first
diagonal
,
and
l
on
the
second
diagonal
,
simply
times
v
,
and
omega
.
and
if
i
do
that
,
i
get
the
following
expression
.
rotation
matrix
phi
,
sorry
,
yeah
,
phi
,
*
this
matrix
,
v
omega
.
well
,
these
are
all
invertable
.
what
is
the
inverse
of
the
rotation
matrix
?
well
,
the
rotation
matrix
rotates
something
phi
degrees
.
well
,
the
inverse
would
be
to
rotate
it
back
,
right
?
then
you
're
back
where
you
started
.
that
's
-5.
so
,
r
inverse
phi
always
exists
and
it
corresponds
to
rotating
it
back
five
degrees
.
so
,
we
can
invert
this
matrix
easily
.
well
,
this
is
a
diagonal
matrix
,
and
the
inverse
of
this
thing
is
simply
the
inverse
of
the
diagonal
,
1
/
1
00
1
/
l.
so
the
inverse
of
this
thing
is
also
trivial
.
that
means
that
i
can
actually
solve
directly
for
v
and
omega
,
no
problem
.
no
questions
asked
,
no
tracking
,
no
approximation
,
just
bam
,
i
get
the
right
velocities
out
.
so
if
i
have
my
low
level
plan
producing
u1
and
u2
,
then
i
can
transform
that
into
v
and
omega
directly
.
and
this
seems
almost
too
good
to
be
true
,
and
it
is
too
good
to
be
true
,
because
remember
we
're
actually
not
making
x
y
behave
perfectly
,
we
're
making
this
new
point
that
we
call
x
tilde
y
tilde
,
we
're
making
that
point
behave
perfectly
.
and
then
we
have
l
,
that
tells
us
how
far
away
we
are
,
and
by
making
l
small
,
we
're
getting
closer
to
x
and
y
,
so
you
practice
.
you
pick
l
tiny
and
then
you
go
to
work
.
so
what
does
this
mean
,
it
means
that
before
we
had
a
planner
we
used
our
complicated
navigation
algorithm
to
spid
out
u1
and
u2
all
right
and
then
we
had
a
tracker
and
in
our
case
we
use
the
pid
tracker
for
the
heading
and
simply
set
the
velocity
equal
to
the
magnitude
of
u
and
from
that
we
got
v
and
omega
out
.
well
now
,
we
do
n't
have
to
deal
with
trackers
.
we
've
actually
replaced
second
part
with
a
transformation
of
the
unicycle
where
we
're
simply
saying
that
v
and
omega
,
or
these
2
matrices
*
u1
,
u2
.
and
again
,
these
matrices
are
,
not
particularly
complicated
to
compute
.
this
,
is
simply
the
rotation
matrix
and
phi
of
course
we
have
.
this
is
one
,
easy
to
compute
,
it
's
just
one
.
and
;
;
is
something
that
we
decide
,
so
what
we
put
here
,
this
is
1
/
l
,
l
should
be
small
so
1
/
l
should
be
some
large
number
,
right
?
and
the
larger
this
number
becomes
the
closer
the
tilde
the
point
and
the
actual
point
approach
each
other
.
i
should
put
out
a
little
warning
though
that
if
you
make
this
number
too
large
,
then
you
get
a
behavior
where
the
robot
starts
turning
quite
a
bit
,
because
this
going
to
hit
omega
directly
.
okay
but
,
this
gives
us
a
direct
transformation
,
instead
of
a
tracker
,
to
produce
the
desired
velocities
.
and
the
reason
why
i
like
this
trick
,
and
why
this
trick
should
n't
be
thought
of
as
simply
,
an
interesting
little
curiosity
because
it
is
kind
of
interesting
is
that
so
many
robots
are
differential
drive
robots
,
and
this
transformation
applies
to
all
of
them
,
because
all
of
them
can
be
mapped
onto
the
unicycle
dynamics
.
so
,
that
takes
care
of
,
how
do
we
actually
go
from
low-level
plans
.
to
executable
,
desired
velocities
for
differential
drive
mobile
robots
.
