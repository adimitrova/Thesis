1
00:00:00,012 --> 00:00:06,649
In the last lecture, we saw that one way 
of overcoming this inherent or seeming 

2
00:00:06,649 --> 00:00:12,544
tension between x.+u was a way of 
generating, references, 

3
00:00:12,544 --> 00:00:18,784
and the actual robot dynamics was to 
introduce a layered architecture, 

4
00:00:18,784 --> 00:00:25,145
where you had a planner that planned 
reference directories, and a tracker that 

5
00:00:25,145 --> 00:00:30,802
tracked these reference directories. 
What I want to do today, in today's 

6
00:00:30,802 --> 00:00:37,255
lecture is, see how do we make, this, 
architecture concrete for the particular 

7
00:00:37,255 --> 00:00:42,099
example of a differential drive wheeled 
mobile robot. 

8
00:00:42,099 --> 00:00:46,464
And if you recall, going back in time to 
module 2, 

9
00:00:46,464 --> 00:00:50,729
a differential drive mobile robot has 2 
wheels, 

10
00:00:50,729 --> 00:00:56,004
and the wheel velocities can be 
independently controlled. 

11
00:00:56,004 --> 00:01:01,958
So we have v sub l for the left wheel, 
and v sub r for the right wheel. 

12
00:01:01,958 --> 00:01:05,807
And if, 
this robot is located at x,y and in this 

13
00:01:05,807 --> 00:01:11,427
case it's heading straight up. 
So this is the angel Phi then we saw that 

14
00:01:11,427 --> 00:01:16,947
the dynamic for the differential drive 
mobile robot was given by this 

15
00:01:16,947 --> 00:01:21,042
expression. 
We also quickly realize that there was 

16
00:01:21,042 --> 00:01:23,986
something. 
Rather unintuitive about this. 

17
00:01:23,986 --> 00:01:28,582
It's hard to feel real velocities. 
It's much easier to feel what' happening 

18
00:01:28,582 --> 00:01:33,404
if you're, assuming that you can control 
the speed of the robot directly and the 

19
00:01:33,404 --> 00:01:36,619
angler velocity meaning how quickly 
you're turning. 

20
00:01:36,619 --> 00:01:40,292
If you're doing that you instead get a 
unicycle model. 

21
00:01:40,292 --> 00:01:45,776
The differencial drive mobile robot, 
dynamics is not the unicycle dynamics but 

22
00:01:45,776 --> 00:01:51,154
it's close, and infact module 2 part of 
the the things we did in that module was 

23
00:01:51,154 --> 00:01:56,407
connection these 2 and we actually 
derived, derived this expression where 

24
00:01:56,407 --> 00:02:01,737
the right and the left wheel volocities 
could be related to VE anomia directly 

25
00:02:01,737 --> 00:02:07,623
meaning, the control signals we produce 
under the unicycle assumption can be 

26
00:02:07,623 --> 00:02:11,586
directly mapped onto v sub r and v sub l. 
And that's nice. 

27
00:02:11,586 --> 00:02:17,184
Because v and [INAUDIBLE] are intuitively 
clear about v sub r and v sub l are not. 

28
00:02:17,184 --> 00:02:23,368
So, the way we think about differential 
drive mobile robots is really in terms of 

29
00:02:23,368 --> 00:02:26,332
unicycles. 
And then, we make this final 

30
00:02:26,332 --> 00:02:32,409
transformation onto the actual real 
velocities before resending the, the com 

31
00:02:32,409 --> 00:02:37,241
the actuation commands. 
So that's the model we have to deal with. 

32
00:02:37,241 --> 00:02:42,646
Well, if we now buy that we can use 
unicycles then, we really have already 

33
00:02:42,646 --> 00:02:47,637
seen how to make the unicycle go in a 
desired direction. 

34
00:02:47,637 --> 00:02:54,497
So here is the unicycle model again. 
Well I would like it to go in the 

35
00:02:54,497 --> 00:03:02,201
direction phi sub d or phi desired. 
Well, we actually saw early on that, why 

36
00:03:02,201 --> 00:03:10,557
not use a PID regulator? Well, if I let 
the error Between the desired angle and 

37
00:03:10,557 --> 00:03:19,402
the actual angle, be given by E, and in 
particular, if you don't do E but you use 

38
00:03:19,402 --> 00:03:26,282
arc tan 2 of sine phi [UNKNOWN] minus phi 
comma Cosine, the same thing. 

39
00:03:26,282 --> 00:03:29,484
Then you get something that's between -pi 
and pi, 

40
00:03:29,484 --> 00:03:34,132
then you don't have to worry about the 
angles being, poorly behaved. 

41
00:03:34,132 --> 00:03:38,996
Well, if you use a PID regulator. 
Then we've seen that this actually allows 

42
00:03:38,996 --> 00:03:44,295
us to track this, reference direction, 
theta or phi sub d, rather elegantly. 

43
00:03:44,295 --> 00:03:46,747
And, 
as a recap, this is what the PID 

44
00:03:46,747 --> 00:03:50,871
regulator looks like. 
It looks rather hairy, but, we also saw 

45
00:03:50,871 --> 00:03:53,711
how to implement it in a rather direct 
way. 

46
00:03:53,711 --> 00:03:58,923
So we know, already, how to track angles. 
Well, all we need to do then is add in 

47
00:03:58,923 --> 00:04:02,701
the speed component. 
So, let's assume that the low level 

48
00:04:02,701 --> 00:04:09,240
planner has given us a desired velocity, 
u, where we have assumed then, that x 

49
00:04:09,240 --> 00:04:13,237
does equal to u. 
Well, we have, actually, the unicycle, 

50
00:04:13,237 --> 00:04:20,598
right? And now, this vector, is actually 
the desired direction and magnitude, we 

51
00:04:20,598 --> 00:04:26,853
want to move in, and, why not simply set 
that equal to u? U is the desired 

52
00:04:26,853 --> 00:04:30,181
velocity. 
Well, if we do that, then we can start 

53
00:04:30,181 --> 00:04:35,072
seeing, okay, how do we get, desired 
headings out, and what should our 

54
00:04:35,072 --> 00:04:40,450
velocity be? Well, it's very simple. 
If we simply take arc tangents of u2 over 

55
00:04:40,450 --> 00:04:45,851
u1, where u2 is the y component of u, and 
u1 is the x component, then that is the 

56
00:04:45,851 --> 00:04:49,191
angle. 
So phi desired, we get for free. 

57
00:04:49,191 --> 00:04:56,481
All that remains to be designed, then, is 
the velocity component, but hey check 

58
00:04:56,481 --> 00:05:01,046
this out. 
If I take the unicycle model and I take X 

59
00:05:01,046 --> 00:05:08,497
dot squared plus Y dot squared and then I 
take the square root of this, I get This 

60
00:05:08,497 --> 00:05:13,932
square root here. 
Well, that is the square root of v^2 

61
00:05:13,932 --> 00:05:20,107
cosine squared phi plus sin^2 phi. 
Well, this is one of the well-known 

62
00:05:20,107 --> 00:05:26,782
trigonometric identities. 
This is exactly equal to 1, so all I get 

63
00:05:26,782 --> 00:05:30,552
is square root of v ^ 2. 
Which is v itself. 

64
00:05:30,552 --> 00:05:35,352
So what I noticed is that, if I'm moving 
the unicycle around. 

65
00:05:35,352 --> 00:05:40,191
The magnitude of this vector in the 
direction I'm going with. 

66
00:05:40,191 --> 00:05:44,660
Well, that's v. 
Well, but I know what the magnitude is of 

67
00:05:44,660 --> 00:05:49,015
the u vector. 
It's just the absolute value, or the, the 

68
00:05:49,015 --> 00:05:52,422
norm of u. 
So what this simply means, is. 

69
00:05:52,422 --> 00:05:55,642
You know what? V should be equal to the 
norm of u. 

70
00:05:55,642 --> 00:05:59,461
Well, the norm of u is the square root of 
v1^2+u2^2. 

71
00:05:59,461 --> 00:06:05,184
So, I immediately know, not only which 
direction I would like to go in but how 

72
00:06:05,184 --> 00:06:10,718
quickly I should go in that direction. 
So, the way to build a tracker for the 

73
00:06:10,718 --> 00:06:17,315
unicycle robot is simply to take arc 
tangents of u2 over u1 as the desired 

74
00:06:17,315 --> 00:06:24,286
heading, and then let omega be equal to 
PID of e, where e is phi desired minus 

75
00:06:24,286 --> 00:06:29,342
phi, and v be the magnitude of the u 
vector itself. 

76
00:06:29,342 --> 00:06:33,383
That's good news, because this gives us 
all we need. 

77
00:06:33,383 --> 00:06:38,033
Before, as before, we plan using our 
navigation algorithm. 

78
00:06:38,033 --> 00:06:44,175
Out of the navigation algorithm comes u1 
and u2, the direction in which we would 

79
00:06:44,175 --> 00:06:48,235
like to move. 
Well, at the end of the day, the tracker 

80
00:06:48,235 --> 00:06:53,582
needs to spit out V sub R and V sub L, 
which is derived from the left wheel 

81
00:06:53,582 --> 00:06:59,501
velocities for the differential drive 
mobile robot, and now we know what to put 

82
00:06:59,501 --> 00:07:04,219
inside a tracker block. 
If I desire, the desired heading is the 

83
00:07:04,219 --> 00:07:09,732
arc tangents of U2 over U1 Then we use a 
PID regulator, for instance, or some 

84
00:07:09,732 --> 00:07:12,892
other regulator, for regulating the 
angle. 

85
00:07:12,892 --> 00:07:18,197
So omega = PID of phi desired - phi. 
The velocity is simply the magnitude of 

86
00:07:18,197 --> 00:07:21,537
the u vector, which we know how to 
compute now. 

87
00:07:21,537 --> 00:07:24,892
So, this gives us omega and v for the 
unicycle. 

88
00:07:24,892 --> 00:07:30,437
And then we take this and map it onto the 
left and right wheel velocities of the 

89
00:07:30,437 --> 00:07:33,887
actual robot. 
So this means that we can actually 

90
00:07:33,887 --> 00:07:40,027
successfully use this layered arcitecture 
for our differential drive mobile robots, 

91
00:07:40,027 --> 00:07:45,665
and this is the way we did it in the 
experiments that we saw In the previous 

92
00:07:45,665 --> 00:07:48,621
module. 
Now, for the unicycle. 

93
00:07:48,621 --> 00:07:55,967
There is an even more clever trick that 
is not involving layered architecture, 

94
00:07:55,967 --> 00:08:00,749
but it's letting the unicycle really Act 
like x dot = u. 

95
00:08:00,749 --> 00:08:06,269
And in the next lecture, we will not use 
this PID based tracker, but this clever 

96
00:08:06,269 --> 00:08:11,611
trick as a way of being eeven more 
elegant when handling differential drive 

97
00:08:11,611 --> 00:08:12,585
mobile robots. 