so now we have seen that controls deals
with dynamical systems in generality. and
robotics is one facet of this. now what we
haven't done is actually try to make any
sense of what this means in any precise or
mathematical was. and one thing that we're
going to need in order to do this is. come
up with, with models. and models are gong
to be an approximation, and an abstraction
of what the actual system is doing. and
the control design is going to be made,
rather done, relative to that model and
then deployed on the real system. but,
without models we can't really do much in
terms of control design. we would just be
stabbing in the dark without knowing
really what, what's going on. so, models
are actually key when it comes to
designing controllers, because if you
remember that the question is really how
in control theory, is how do we pick the
input signal u. so u again, takes the
reference, compares it to the output, the
measurement and comes up with a
corresponding course correction to what
the system is doing. and the objectives
when you pick this kind of control input,
well, there are a number of different
kinds of, of objectives. the first one is
always stability. stability, loosely
speaking, means that the system doesn't
blow up. so, if you decide a controller
that makes the system go unstable, then no
other objectives matter cause you have
failed. if your robots drive into walls or
your aerial robots fall to the ground,
basically control stability is always
control objective number one. now, once
you have that, the system doesn't blow up.
you may want it to do something more than
not blow up, and something that we're
going to deal with is tracking a lot.
which means, here is a reference either of
value. 14, how do we make our system do 14
or here is a path how do i make my robot
follow this path or how do i make my
autonomous self driving car follow a road.
so tracking reference signals is another
kind of objective. assert important type
of objective is robustness in the sense
that. ,, . since we are dealing with
models when we're doing our design. and
models are never going to be perfect. we
can't overcommit to a particular model.
and we can't have our controller be too
highly dependent on what the particular
parameters in the model. r, model r. so,
what we need to do is to design
controllers that are somewhat immune to
variations across parameters in the model,
for instance. so this is very important.
i'm calling it robustness. a companion to
robustness, in fact one can ague that it's
an aspect of robustness. it's disturbance
rejection, because, at the end of the day.
we are going to be acting on measurements.
and sensors have measurement noise. things
always happen if you're flying a in the
air, all of a sudden you get a wind gust.
now that's a disturbance. if you're
driving a robot, all of a sudden you're
going from linoleum floored carpet, now
the friction changed. so all of a sudden
you have these disturbances that enter
into the system and your controllers have
to be able to overcome them. at least,
reasonable disturbances for the, the
controllers to be to be effective. now
once you have that we can wrap other
questions around it like optimality, which
is not only how do we do something but how
do we do it in the best possible way. and
best can mean many different things, it
could mean how do i drive from point a to
point b as quickly as possible, possible
or as using as little fuel as possible or
while staying as centered into the middle
of the road as possible. so optimality can
mean different things and this is
typically something we can do on top of
all these other things and in other to do
any of this we really need a model to, to
be a. effective.
so effective controlled strategies rely on
predictive models. because without them,
we have no way of knowing what our control
actions are, are actually going to do. so,
what do these models look like? let's
start in discrete time. this means that,
what's happening is that, that distinct
time instances, thi ngs happen.
in discrete time, what we have typically,
is that the state of the system, remember
that x is the state. so this is at time
instance, k plus 1. well, it's some
function of what the state was like,
yesterday, the time, k, and, what they did
yesterday. so, the position of the robot,
position of the robot tomorrow, is a
function of where the robot is today, and
what i did today. and then, f, somehow
tells me how to go from today's state and
controlling to tomorrow's state. this is
known as a difference equation because it
tells you the difference between different
values across, different time instances.
so, that's in, in discrete time. and
here's an example of this. this is the
world's simplest discrete time system.
it's a clock, or a calendar. this is the
time today. now i'm adding one second. and
this is the time one second later. so the
time right now plus 1 second is the time 1
second later. this is clearly a completely
trivial discreet time system, but it is a
difference equation. it's a clock, so if
you plot this we see that here is, this is
the 8, which is what time it is as a
function of time. so it's silly. but at 1
o' clock, the state is one. at 2 o' clock,
the state is two, and so forth. and you
get this thing with slope one. so, this
would be the world's simplest model. there
are no control signals or anything in
there. but it least it is a dynamic
discrete time model that describes. how a
clock would work. now the problem we have
with this though is that the laws of
physics are all in continuous time. and
when we're controlling robots we are going
to have to deal with the laws of physics.
newton is going to tell us that the force
is equal to the mass times acceleration.
or, if we're doing circuits, kirchoff's
laws is going to relate various properties
to capacitances and resistances in the, in
the, in the circuit. so, we're going to
have to deal with things in continuous
time, and in continuous time, there is no
notion of next. but we have something
almost be tter, and that's the notion of a
derivative, which is, it's not next, but
it tells us how is the time change? the
change with respect to time. so in
continuous time, we don't have difference
equations. what we have are these things
called differential equations. and right
here you see that the derivative of the
state with respect to time. is some
function of x and u. so this not telling
me what the next value it is. it's telling
me, what's the change? instantaneous
change. and here, it's the same thing. but
now i'm written, i've written x. instead
of dx, dt. and time derivatives, a lot of
times, is written with a dot. and i'm
going to use that in this. class and this
actually traces back to the, the slight
controversy between newton and leibniz.
leibniz, so in 1684, newton said, oh i
have this idea that i call it
differential, and leibniz at the same time
had the same idea. well, this is leibniz's
notation and this is newton's notation,
and we're going to use the dot for time
derivatives here. the point is that these
are both the same equations and they are
differential equations, because they are
relating changes to the values of the
states. so if you go back to our clock,
what would the differential equation of a
clock look like? well, it would be very,
very simple it would say that the, the
change, the rate of change of the time is
one. which basically means the clock
changes a second every second. that's what
it means. so when i drew this picture of
the discrete time clock. or, i drew this
line diagonally across it. what i was
really doing was describing this. so this
is the continuous time clock. x dot is
equal to 1 and.
we are going to need, almost always,
continuous time. models for, for our
systems. and next couple of lectures,
we're going to start developing models of
particular systems. but, before we do
this, i want to say a few words about how
to go from continuous time to discrete
time. because our models are going to be
continuous time differential equations.
but th en, when we're putting this on a
robot, we're going to put it on a
computer. the computer runs in discrete
time, so somehow we need to map continuous
time models onto discrete time models. so
now if i say that x at time k, well it's x
at time k times delta t, where delta t is
some sample time. so we've sampled k
measurements. well if i, use this. what is
x at time k plus 1 which is at the x.k
plus first sample time. well, i need to
relate this thing somehow to the
differential equation. so how do i do
this? well, this is not always easy to do
exactly but what you can note is that.
this is known as a tailor approximation.
so x at time k times delta t plus a little
delta t which is exactly the next state.
well it's roughly what it was last time
times the length of the time interval,
delta t times the derivative. so this is a
an approximation but the cool thing here
is that this x at time k plus delta t,
well that's, xk. so these things are the
same. x dot at time k equals delta t, well
that's f. so this are the same things, and
then i just have to multiply my delta t
there. so this is a way of getting a
discrete time model from the continuous
time model. and, this is how we're going
to have to take the things we do in
continuous time, and map it onto the
actual implementations of computers that
ultimately run in discrete time.
