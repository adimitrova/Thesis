now
we
have
a
rather
useful
seemingly
general
purpose
controller
,
that
we
call
the
pid
regulator
.
and
,
we
saw
that
we
could
use
it
to
design
a
cruise
controller
for
a
car
to
make
the
car
reach
the
,
the
desired
velocity
.
what
i
have
n't
said
though
is
how
do
we
actually
take
something
that
looks
,
looks
,
to
be
completely
honest
,
rather
awkward
.
you
know
?
integrals
and
derivatives
and
stuff
.
and
actually
turn
it
into
executable
code
.
meaning
,
how
do
we
go
from
this
mathematical
expression
to
something
that
's
running
on
a
platform
?
well
,
the
first
thing
to
note
is
that
,
we
always
have
a
sample
time
.
we
're
sampling
at
a
certain
rate
.
there
's
a
certain
clock
frequency
on
the
,
on
the
computer
.
well
,
what
we
need
to
do
is
we
need
to
take
these
continuous
time
objects
that
we
have
here
in
the
,
in
the
pad
regulator
and
have
them
be
defined
in
this
discreet
time
.
first
of
all
here
is
an
arrow
,
it
does
n't
matter
if
this
is
running
in
continuous
time
and
discrete
time
,
the
proportional
part
we
just
read
in
the
current
's
velocity
.
and
compare
it
to
the
reference
velocity
,
and
then
we
get
the
error
at
time
,
k
times
delta
t.
so
that
's
trivial
.
now
,
but
what
do
we
do
with
derivatives
and
integrals
?
well
,
let
's
start
with
the
derivatives
,
because
they
are
not
so
hard
.
we
know
that
,
roughly
,
a
derivative
is
the
new
value
.
minus
the
old
value
divided
delta
t.
in
fact
,
as
delta
t
goes
to
0
,
this
becomes
the
definition
of
a
derivative
limit
.
so
,
we
actually
know
that
if
i
can
store
my
old
error
,
compute
a
new
error
,
take
the
difference
and
divide
it
by
delta
t
,
i
have
a
pretty
good
approximation
of
edot
,
which
is
this
thing
de
(
t
)
/dt
,
so
i
actually
can
approximate
the
,
the
derivative
part
in
a
rather
direct
way
.
compared
the
latest
value
to
the
previous
value
divided
by
delta
two
,
and
we
're
good
.
now
the
integral
.
that
's
where
we
're
going
to
have
to
do
a
little
bit
of
work
.
so
,
what
is
the
integral
?
well
the
integral
is
the
sum
under
the
curve
right
.
that
's
the
integral
.
well
is
there
some
way
of
approximating
this
?
well
,
clearly
it
is
.
we
can
sum
up
all
these
little
blocks
.
this
is
a
rim
approximation
of
the
integral
.
so
what
this
means
is
well
we
're
not
going
to
get
the
integral
exactly
,
but
if
you
can
sum
up
these
blocks
somehow
and
the
width
here
is
going
to
be
.
what
did
we
call
it
?
delta
t.
so
the
width
of
each
base
of
the
rectangle
is
delta
t.
so
if
you
can
do
that
.
then
we
're
getting
a
,
a
reasonably
good
approximation
.
and
,
in
fact
,
then
the
integral
is
simply
a
sum
of
the
values
at
the
sample
time
.
so
the
value
up
there
.
the
value
at
that
time
.
and
then
we
multiply
it
by
delta
t
to
get
the
rectangle
,
and
then
we
sum
up
all
the
rectangles
.
that
's
a
reasonable
approximation
and
in
fact
what
i
'm
going
to
do
is
i
'm
going
to
take
this
sum
and
call
the
sum
e.
so
this
is
the
same
thing
.
so
then
the
integral
is
roughly
equal
to
delta
t
times
e.
well
,
that
turns
out
to
be
useful
because
,
let
's
get
rid
of
that
stuff
again
.
my
next
value
,
delta
,
or
e
delta
t
times
e
new
.
well
,
it
's
delta
t
times
the
sum
,
but
now
i
'm
summing
to
n
plus
1
,
well
,
let
's
pull
out
the
last
term
.
so
,
the
error
at
time
,
n
plus
1
times
delta
t.
that
's
the
last
value
that
we
called
little
e
new
up
here
.
let
's
pull
that
out
,
multiply
it
by
delta
t
,
and
what
's
left
is
the
sum
from
1
or
0
to
n
,
which
is
e
old
,
times
delta
t.
so
,
delta
t.
e
new
is
equal
to
delta
t
,
e
old
+
this
guy
here
.
or
if
i
want
to
put
it
in
a
slightly
more
compact
way
,
e
new
where
e
is
the
sum
of
the
errors
is
e
old
+
the
latest
error
.
which
is
a
little
bit
dah
.
the
new
sum
is
the
old
sum
plus
the
latest
entry
.
so
,
that
gives
me
enew
and
now
,
since
i
kne
know
that
the
integral
is
delta
t
x
e
,
i
know
that
,
well
,
the
integral
term
that
i
get
here
is
simply
delta
t
times
enew
which
gives
me
an
approximation
of
.
the
interval
.
so
,
now
,
having
said
it
,
let
's
put
this
into
,
into
pseudo-code
here
.
so
,
every
time
the
controller
is
called
,
well
,
i
'm
going
to
read
in
the
latest
error
,
which
is
the
reference
minus
the
measurement
.
and
then
,
i
'm
going
to
say
e
_dot
.
e_dot
is
really
.
e
minus
,
now
we
call
it
,
let
's
call
it
e
old
,
here
.
it
's
really
divided
by
delta
t
,
right
?
but
the
d
part
of
the
controller
is
kd
times
this
thing
.
well
,
what
if
i
just
called
this
thing
my
new
,
let
's
call
it
kd
prime
.
i
just
divided
by
delta
t
because
i
do
n't
actually
need
to
typically
know
delta
t.
let
's
call
this
kd
prime
.
well
,
then
i
just
got
rid
of
delta
t
,
and
i
do
n't
have
to
worry
about
.
delta
t.
i
do
the
same
thing
for
the
integral
.
so
e
new
is
e
old
plus
the
latest
error
.
again
,
i
really
have
that
this
thing
,
this
integral
,
is
roughly
equal
to
delta
t.
times
e.
so
if
i
have
ki
times
that
,
i
have
this
times
ki
,
well
let
's
take
these
guys
and
call
this
,
this
is
my
new
ki
.
then
again
i
get
rid
of
the
t
,
so
then
if
i
do
that
,
my
actual
controller
is
kp
times
e
times
kp
times
e
dot
.
which
i
just
computed
and
ki
times
e.
this
is
my
control
structure
,
this
is
how
we
actually
implement
it
.
and
then
i
just
need
to
at
the
end
,
remember
to
store
the
light
,
the
latest
e
as
the
old
e
so
the
next
time
i
call
the
controller
,
i
have
the
previous
value
.
this
is
the
implementation
of
a.
pid
regulator
.
so
let
's
do
it
.
ok.
i
'm
going
to
point
out
again
.
the
coefficients
include
the
sample
times
.
i
pointed
that
out
already
.
but
let
's
do
it
.
before
we
do
it
though
i
actually
want
to
say
that
that
's
the
end
.
almost
of
module
1.
and
in
module
2
,
we
're
going
to
go
robotics
.
in
the
sense
that
we
're
going
to
see
,
now
,
how
to
relate
some
of
these
initial
concepts
to
robotics
.
but
,
in
the
interest
of
full
disclosure
,
we
actually
do
n't
know
why
anything
we
did
in
module
.
1
actually
worked
.
so
module
3
is
we
're
going
to
revisit
what
we
did
here
.
but
,
revisit
it
in
a
much
more
systematic
way
.
okay
,
that
's
enough
chitchat
.
now
,
let
's
do
it
.
we
're
going
to
do
altitude
control
.
which
means
we
're
going
to
control
the
height
,
how
high
up
in
the
air
a
quadrotor
is
.
and
the
model
we
're
going
to
use
is
,
well
,
x
is
going
to
be
,
so
here
's
the
height
,
here
's
the
ground
,
so
x
is
going
to
be
how
high
up
this
thing
is
.
and
x..
,
which
is
the
acceleration
of
the
quadrotor
,
well
g
,
the
gravity
,
is
pulling
it
down
,
so
there
has
to
be
a
-g
somewhere
.
gravity
is
pulling
it
down
,
and
then
what
we
're
doing
is
we
're
really
controlling
the
velocity
of
the
rotor
collectives
.
so
these
are
all
the
rotors
of
the
quadrotor
,
all
the
four
rotors
,
the
angular
velocity
of
this
thing
we
're
controlling
.
and
that
's
translating
into
thrust
and
upthrust
through
this
coefficient
,
c
,
that
we
do
n't
know
.
and
we
actually
really
do
n't
know
what
the
gravitational
constant
is
either
,
but
this
is
the
model
we
're
going
to
use
.
and
this
is
the
controller
we
're
going
to
use
.
and
instead
of
me
showing
plots
and
simulations
,
why
do
n't
we
get
away
from
the
power
point
presentation
right
here
,
and
move
over
to
an
actual
quadrotor
running
a
pid
.
regulator
.
so
,
now
that
we
have
a
way
of
designing
reasonably
good
controllers
.
in
this
case
,
pid
regulators
.
we
have
some
understanding
of
the
basic
performance
objectives
we
're
trying
to
hit
.
in
this
case
,
stability
,
tracking
,
and
robustness
.
we
even
have
a
model
,
or
at
least
a
rudimentary
model
of
a.
quadrotor
aerial
vehicle
.
what
we
did
in
the
model
is
we
tried
to
somehow
connect
the
rotor
collective
speed
to
an
up-thrust
and
the
model
included
some
parameters
that
we
do
n't
know
.
it
even
included
the
gravitational
constant
.
the
idea
,
of
course
,
with
robustness
now
is
,
we
should
not
have
to
know
these
parameters
.
exactly
.
because
that
would
actually
be
a
rather
poor
and
fragile
control
assign
.
so
i
have
jp
delacroix
with
me
here
who
is
a
graduate
student
at
georgia
tech
.
and
without
any
further
ado
,
jp
,
let
's
see
what
thee
pid
regulator
actually
looks
like
in
action
.
,
so
what
we
're
doing
now
is
altitude
control
only
.
so
we
're
trying
to
make
this
thing
stay
at
the
fixed
altitude
.
it
's
going
to
drift
a
little
bit
sideways
because
we
're
not
controlling
sideways
drift
at
all
.
one
thing
we
can
see
right
off
the
bat
is
that
the
system
is
indeed
stabilized
.
because
if
it
was
n't
,
the
quadrotor
would
actually
fall
down
to
the
ground
.
the
other
thing
we
see
is
,
when
i
'm
pushing
it
a
little
bit
like
this
,
it
's
able
to
overcome
it
.
i
can
even
push
it
down
a
little
bit
.
and
the
controller
fights
these
disturbance
,
so
robustness
is
,
certainly
achieved
.
in
terms
of
tracking
,
it
's
not
so
clear
what
's
actually
going
on
because
we
do
n't
exactly
see
what
the
reference
height
is
,
however
we
are
measuring
altitude
with
a
downward
facing
ultrasonic
sensor
and
,
let
's
get
this
thing
out
of
the
way
of
jp
.
and
the
integral
part
or
the
integral
term
in
the
pid
regulator
is
ensuring
that
modulatiries
these
extra
errors
in
the
height
measurements
,
we
are
actually
achieving
the
.
the
altitude
we
were
,
looking
for
.
so
with
this
rather
simple
initial
experiment
,
we
're
going
to
declare
success
when
it
comes
to
pid
regulation
.
and
we
now
are
going
to
move
on
to
bigger
and
better
problems
.
thank
you
.
,
,
.
