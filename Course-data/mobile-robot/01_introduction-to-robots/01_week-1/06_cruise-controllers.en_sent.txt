so now that we have a way of describing dynamical systems with differential equations in continuous time.
or difference equations in, discrete time.
let's, see if we can actually use this, to do something interesting with, with robots.
and, let's start with.
building a cruise controller for a, for a car.
and the, the cruise controller.
i mean it's job is to make the car drive at the desired reference speed.
and if you recall, we're going to use r to describe the reference.
so someone you, in the car, have set the reference speed to, to 65 miles per hour, or whatever you desire.
now, we want to somehow understand how we should model the car so that we can make it go the reference speed.
well, like i said last time, the laws of physics ultimately will dictate how objects in the world, like robots or cars, behave.
and newton's second law says that the force is = to the mass * the acceleration.
now, this is what we're going to have to start with.
there's nothing we can do about this.
it is what it is.
now, what is the state of the system?
because we need to somehow relate newton's second law to the state.
well, in this case, since what we're going to do is try to make the velocity do the right thing, we can say that, let's say that the velocity of this, the car is the state.
so x is going to be the speed at which the carrist is driving.
now acceleration a appear, this, a is simply dv dt and its the time derivative of the velocity or the change in velocity as a function of time.
so what we get from that of course is that we can relate the velocity to the acceleration.
now we're also going to have to have an input, and when you're driving a car, the input, if you're dealing with, with speeds rather than which direction the car is going is, you press the gas pedal or the brake.
and we are going to be rather cruder and say, you know what?
somehow we're mapping stepping on the gas or the brake onto a force that's applied to the car.
and this is done through some linear relationship, where we h as some coefficient c, which is an electric mechanical transmission coefficient, and i'm going to go out on a limb and say, we don't know what this is.
and, i control this sign cannot rely on us knowing c, because we're not going to know exactly what it is.
but, let's at least for now, go with this, and hope that that's good enough to give us the design we want.
so now we know that the force is c times u, but it's the mass time the acceleration.
right.
so x dot, which is the same as dv, dt, which we had up there.
well, that's a which means that mass times the acceleration which is mx dot is equal to the force, but the force is c times u. so, that tells me directly that x dot is c over m times u. so, this, this sweet heart equation here is an equation that describes how my input maps on to.
the state of the system.
it's a differential equation.
but it's an equation that tells us something about how my choice of input affects the system.
okay.
this is, in fact, a rather good model.
and i want to show a little video.
i was involved in one of the, the darpa.
grand challenges.
this was an urban challenge.
where we were supposed to build self-driving cars and we use almost exactly this model for, for our car.
so i want to talk a little bit about how one would do this.
so here is the front, a spinning thing, that's a laser scanner.
on the side here, is another laser scanner sitting on top of a radar.
these were what we used to get measurements.
now what we see on the inside is our instrumented car, which translated ultimately input voltages onto mechanically things that push down the gas pedal.
so this is how we actually affected it with the same coefficient.
and now, look at this video.
the car gets around obstacles, and then it gets out of bounds, and it starts oscillating.
so, i'm showing this.
a, because i think the car is awesome.
but, b, because there are, even though we didn't crash into things, we were oscillating a little bit.
so there is something not perfect about this control design.
see how we get out of the lane, we're oscillating too much.
if you look at the steering wheel, see that this is a little skittish.
and that's another indication that maybe the control design here wasn't perfect, but the velocity controller was based on a model that's very similar to, to what we just wrote down.
here's another example of obstacle avoidance where.
we're actually trying to avoid another car, but the point being is that, this very, very, very simple model that we wrote down is actually applicable to real systems.
and this is part of the miracle of abstractions, that you're that you're able to get simple things that you then can apply for real.
now, i want to point out that we did real well in this competition up to a point, these were actually the semifinals before the finals.
so let me show you what happened at the end.
this breaks my heart to show you but i'm going to show it to you anyway.
here comes our car.
sting racing.
it's slowing down, it's slowing down and then ow.
it drives straight into a k rail, which is this concrete railing.
what happened was that we got some measurement errors, a lot of measurement errors actually from the gps.
but i wanted to show you this because it was the outcome of it.
regardless of which, this was still.
a very complicated system.
a very complicated robot, a car, and the model we came up with was very simple, and the point is that simple models a lot of times get you very far.
so, let's see how we should actually do, do the control design here.
let's assume that we can measure directly the velocity, and record, recall that the state.
x is the velocity the measurement or the output is what we called y, so y is actually directly equal to x in this case, so we have a some way of measuring velocities which you know typically have a, you have a speedometer in your car so we know roughly what the velocity is and now their control signals should be a function of r-y, where r is the desired velocity and y is the actual velocity.
and, i'm going to call this e, which stands for error.
and our job, as control designers, is to make the error disappear, drive the error down to zero.
so let's, before we do the actual design discuss a little bit about what are the properties that a useful controller could have.
well 1 property is that the controller should not overreact.
if the error is tiny, we're almost perfect in terms of the velocity of the car, we should not have a large control signal.
the control signal should not be aggressive when we're close to being done, it's like.
lets say that you're trying to thread a, a thread through a needle.
well, when you're really, really close you shouldn't just jam the thread in there.
you should take it nice and slow when you're close.
so, no overreactions.
that's important, because when you start overreacting, you start responding very quickly and aggressively to measurement of noise, for instance.
so, a small error should give a small control input.
u should not be jerky.
and jerky, here.
all i mean with that is that, it shouldn't vary too rapidly all the time.
because if it does, then we're going to be sitting in this car.
with our cruise controller, we're going be having a cup of coffee with us.
and, now the cruise controller is smacking us around all over, because it's jerking, we're going to spill our coffee.
and, in fact for auto pilot's on airplanes, there are limits on their accep, acceptable accelerations that are directly related to cups of coffees standing on the, the tray tables in the aircraft.
so you should be, not overreacting.
it should not be jerky.
and the, it should not depend on us knowing c and m. so, m is the mass of the car.
c is this semi-magical transmission coefficient.
the mass of the car is changing depending on what luggage we have.
it's changing depending on how many passengers we have.
we should not have to redesign our controller just because a new person entered the car.
we shouldn't have to weigh everyone and enter how much we weigh to, for it to work.
and in fact elevators have bounds on how many people can be in the elevators.
this is import, related to the fact that they design controllers that are robust to variations in mass across a certain spectrum.
same thing for cars.
the cruise controller should work no matter how many people are in the car and we don't want to know c. what this means is that controller can not be allowed to depend exactly on the values of c and m. so these are the 3 properties, high level properties that we have to insist on our control signal to have.
so having said that, in the next lecture we're going to see how we can actually take these high level objectives and turn em into actual controllers and see what constitutes a good control design and.
conversely, it would constitute a bad control design.
