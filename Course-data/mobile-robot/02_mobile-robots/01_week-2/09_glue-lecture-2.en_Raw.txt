hi, i'm smirti chopra again, and i'm your
instructor
for the glue lectures for the duration of
this course.
this is glue lecture two, and let's get
into it.
this lecture is titled robot models,
because this week you
guys focused a lot on different models for
the robots specifically.
and as usual pay attention because this
lecture will
help you guys with quiz two okay, with
that.
so, we saw at this week in dr. [unknown]
lectures that he introduced two models for
the robots.
that's your robot, and then one model was
with respect to, you know, the angular
velocities of the wheels of the robot,
which is the differential right model.
and then another model that we saw was
with respect to the sine of v and omega
inputs.
so why these two different models are,
why, why is it that you know, we have a
one model that's actually your angular as
and
the other model that's your b and they go.
well, he went over it, and he explained to
you guys that,
you know, this differential drive model,
which is actually the one that is
used with the robot, or actually the model
for
the robot, it's a two-wheel differential
drive thing is
very important because when your
implementing your controller onto
the robot you have to use the correct
model.
it has to two wheels, so obviously you
need
to give it inputs with, for both the
wheels.
but when we are designing our controller
and we are designing our controls, in
that time we don't want to, you know,
think in terms of wheel velocities etc.,
we'd rather just
think in terms of, you know, okay, me
walking
and i'm walking with a linear velocity and
an angular
velocity, and it's kind of much easier
than, you know,
thinking about each wheel and how it
turns, et cetera.
so we have these two models here, the
differential
drive and the simpler model, which is used
for design.
okay, so i just want to show you guys this
model in action, or
you know, this whole thing of how you
design controllers based on the
different model and then you use something
else for implementation.
and that's.
watch this video, it's a really
interesting video.
it's my work.
and it's robots playing music.
and they're playing beethoven's fur elise,
actually.
the point here that i want to make is that
[music]
all the control that is designed for this
visual box is done using the
model, the simplified model that we saw,
the v omega model, but then when you
are implementing it onto these robots and
actually converting my v omega into, you
know, angular velocities for each robot
and
that is the input that they are getting.
[sound] here.
so in [inaudible] it's a differential
drive robot,
and that's what, how we are doing it.
okay, so, how do you do that?
if you really simplify and see, this was
my robot, and basically what i'm saying
is, you know, you go from point a to point
b in time ten seconds.
this is a simple thing you'll, here, this
at this point
it's playing note a on the piano and here
it's playing
some g sharp or something, let's say, on
the floor piano
and it needs to go from here to here in
ten seconds.
that is the basic problem for one robot if
you really simplify it.
okay.
this is the model i'm using, like i said,
to
calculate my v and omega to make them
actually do this.
that's how or however whatever trajectory
they
take, straight line, move like this,
whatever they
are doing this input that i am giving them
is based of the model shown here.
choose the high level task and then
control design is done here.
but then the cmd that i am going to be
sending to the
robots are going to be found using this
model which is the differential model.
you guys have seen all this before.
okay, what happens is when you use this
guy and this guy together,
you can actually derive these solutions.
so all i'm saying is that,
i'm going to find v comma omega based on
this guy.
and then i'm going to convert it and put
it
into this equation here to get v r and v
l.
which is what then i'm going to send to
the robots.
and that is exactly what you saw in that,
music playing robots thing as well.
so okay that is one more we'll do another.
and an intuitive example, let's go really
quick over it.
let's say my
velocity input that i'm giving to my robot
is zero and my omega
or my angular velocity is constant,
what are the corresponding angular wheel
velocities?
so again, v and omega is what i have found
out but when i send the commands
to the robots, i'm going to find vr and vl
using these equations right here.
right?
so, when you plug this stuff in, you see
that vr is going to be this value here.
vl is going
to be this value here.
where c is just some constant which is
actually the omega.
okay, now intuitively, do you understand
what's happening here?
let's see that my robot let's its units
point and i'm saying that
you know it's not going straight at all
it's just going to keep moving you
know on its' own like i'm saying my
velocity is zero but my
omega is constant so i have a constant
angular velocity, okay that means that
my robot is not moving forward, it's just
spinning in place.
and that makes sense because now what
we've found out,
in terms of, you know, right and left
wheel angular velocities.
one, is simply the negative of the other.
so one wheel is getting, let's say, plus
five and the other is getting negative
five.
so they're just going to, going to make
the robot spin in place.
it's not going to make it go forward at
all.
so that was the whole intuitive example.
but basically you guys should be pretty
comfortable
going between this,you know, mapping or
transformation, from v [unknown] to v r u.
okay, with that, i'm back to our musical
bot.
so you guys remember this?
of course you do, it happened two slides
ago.
this musical bot example my rova having to
go from a to b in, let's see, ten seconds.
now i want to go a little deeper into the
control.
so earlier we, when we showed the mapping
between, you know, v and omega
and vr vlv, assume that somehow magically
i really had v and omega, right.
now i want to go a little deeper and say
okay.
this whole finding the control v and
omega.
based on the model that i said.
how, what does it actually mean?
this is the model i have.
now i'm asking you guys this.
that [sound] let's make it really simple.
my robot is here and it's looking also in
this direction.
okay?
it needs to go from here to here.
let's say even my theta is perfect.
it's already looking here.
it wakes up at a.
it needs to reach it, at 10 seconds.
so why can't i just say?
guess what?
omega can be zero.
and v can be, b minus a over 10.
right?
and we know all of us know from physics,
geometry from
the model et cetera, that if i was to give
my robot
this velocity, and this omega, and at
every time instant for
10 seconds, i can, i'll in fact reach this
point, over here.
it's simple maths, right?
so why don't we do that?
why do we make such a big deal about, oh,
we have to design the control v, omega et
cetera, like.
is this what the robot is doing actually
in that music video that we just saw
etcetera?
well the answer is no.
why?
because we don't live in a perfect world.
so in our world of simulation this would
be perfect,
yeah sure, in my computer and in my, you
know.
mind, it works perfectly, but actually
when i put it
onto the robots, what's going to happen is
there will be friction.
there will be other problems.
maybe my wheels don't move at the same
rate that they
should or maybe the encoders are slightly
off, or maybe
i come and kick the robot off while it's
moving.
whatever.
i need - to know that let's say while i'm
moving here i wear off slightly
by v and omega at this point needs to know
that i have gone off the path.
in other words we need to have feedback,
if there is no feedback of where
i am in the world then, then it's so easy
for me to just veer of
because of, you know, problems like
friction, etc.
when i'm actually moving the robot and
then my
v and omega has no idea that i want to.
so let's say while walking i come here,
i'll just keep going straight instead.
i'm not doing any kind, kind of you know,
feedback on, on how i should be moving.
so this, i think this a very key concept
in
controls that and kind of motivates why it
is that
we need state information or we need
feedback or even all
the stuff that you studied about you know,
pid regulators, pi everything.
when you are minimizing the error you need
feedback,
you need output, you need to know where
you
are in order to find even the error, how
far you are from, what you need to be
doing.
for all this feedback is a very important
thing that you need.
so hopefully with all this, i have kind
of explained to you guys, the motivation
behind why
you need to know where you are in the
world.
and as you saw in the lectures dr.
edgarson
goes over this whole thing of wheel
encoders, right.
because if you have wheel encoders you
will be to measure where you are.
okay, for that again real quick.
this is how the wheel encoder works.
each encoder has n ticks, and a total of n
ticks that
means if you over haul n ticks you would
have moved one revolution
on the wheel which is two pi r on, you
know, your distance, and then you have dl,
dr, dc.
what is dl, dr, dc is basically how much
your wheel is moving how
much distance the distance of this arc,
for example, based on the number of ticks.
so that i have got 5 ticks how much i
move?
what is this distance?
that is given by dl, dr, dc.
dc is this.
you see all this before and then okay
once we had this of this is what you know,
the wheel encoders
give us now what, how do we find where we
are in space?
okay, i know where i am in the beginning
let's say i this is where i wake up.
now i use dl, dr, dc in this form, in this
update equation
and now i get my new position x prime, y
prime, and v prime.
and remember, x, y, and v is my state, or
where i am in place,
like x, y, and looking there.
that kind of a thing.
okay, cool.
so this whole thing is the wheel encoders.
this is how they work.
so just for your general you know,
knowledge or curiosity
if you are wondering where did this model
come from,
well we could go back to our, you know
concepts
in physics really quick and we could be
like, all right.
if this is a circle, if this is me walking
on the circle with radius small r here.
and i have a speed of lets say, you know,
some v, linear speed.
well, i must have some angular velocity,
right?
for b to be walking on this circle.
otherwise, i would just keep walking
straight.
so how do these 3 variables, kind of you
know, match up?
so, there is this very famous formula we
use, omega r, that kind of
relates the fact that if somebody is
walking or if you are tracking this point
on a circle of radius r, how does the
linear velocity, which
is v, and the angular velocity, which is
omega relate to one another?
and now if i wanted to see how much
distance
i moved in let's say time delta t, well,
what i'm
simply going to do is i'm going to say,
multiply this with
my speed, and my distance then becomes
omega r delta t.
that's the distance.
and i
want you guys to like, kind of understand
that the same concept
can be thought of in terms of the, each
wheel of the robot.
so if my angular velocity for each wheel
is vr and my radius is r, i can actually
calculate the distance moved as r times vr
times dt.
and from here, i'm going to let you guys
figure
out how it is that we'll reach this model.
and as hence, i'm going to say, okay, we
already found out how we got this.
we know this as our model for the robot.
and now can we do something to you know,
kind
of get this equation using the update law
that we
know that if we ever want to find the
position
of the next time is when we simply say
position
of previous plus x dot time.
so it's a nice exercise find out how we
get this model and then, all is good.
with that let's go to the next example.
so this is an odometry example.
just to kind of you know make it again
really clear the concept of wheel-encoders
again very important for the quiz.
so let's
say my robot starts at the origin.
when i say origin, i mean my position and
orientation both are zero.
and it is located after the 0.1 seconds
what you have to find.
now, where is it?
and now it is given that your left wheel
or your right wheel
of the car, then takes your left wheel of
the car six ticks, blablabla.
all the stuff is given.
how will you do it?
okay.
these are the set of equations that you
are going to use.
first, because you know the numbers of
ticks, you're going to
find out how much each wheel has moved.
based on these equations right here,
right.
and then you're going to use them in this
update law
to find out finally where your x, y, and
pi land up.
and a real quick note just for my
satisfaction here is that
it's nice to wonder if i'm the robot, or
if i have the robot, i
know the input i'm giving it, i know the
angular velocities i'm giving it, right?
so why can't i myself find out through my
model, which is
this, right, this guy here, why don't i
find out by
updating using this where my next position
is going to be based on just my vr and vl?
why is that
that i'm using the encoder in the first
place like why don't
i just simulate based on my inputs where
i'm going to be in the
time insteasd.
well, that's exactly the point that we're
trying to make here that even though i'm
giving it a certain input, i don't know
that it's actually going to be doing that.
so when i update my equation, i don't want
to do it based solely on the model.
i actually want to get feedback, physical
feedback from the
robot, and that's how i want to update my
equation.
that's why we do this whole in quarter
thing instead of
just simply saying, you know what?
i'm going to find it myself through my
update equation because i know [inaudible]
and i'm going to find out where my x, y,
and z line up.
no, that's why we don't want to do this.
we want feedback.
we want to see if it actually translated
into that much motion or not.
that's why we use the [inaudible].
and with that, we will in this lecture and
good luck with quiz two.
keep checking the forums.
bye bye.
