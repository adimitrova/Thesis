1
00:00:00,370 --> 00:00:02,970
Welcome back to the second Programming &
Simulation lecture.

2
00:00:02,970 --> 00:00:07,000
This week I will talk about Differential
Drive, Odometry and Infrared Sensors.

3
00:00:08,160 --> 00:00:10,240
In fact, this week's programming
assignment is

4
00:00:10,240 --> 00:00:13,470
focused on implementing the robot's
sensors and actuators.

5
00:00:13,470 --> 00:00:16,720
Therefore, you will need to transform from
the unicycle dynamics in

6
00:00:16,720 --> 00:00:21,600
the controllers to the differential drive
dynamics and the mobile robot.

7
00:00:21,600 --> 00:00:23,080
You also need to use the wheel encoder

8
00:00:23,080 --> 00:00:25,420
to keep track of the robot's position and
orientation.

9
00:00:25,420 --> 00:00:27,790
This is called odometry.

10
00:00:27,790 --> 00:00:30,330
And third, you'll need to use the infared
sensors to

11
00:00:30,330 --> 00:00:33,300
measure distance to any obstacles that
might be around teh robot.

12
00:00:35,960 --> 00:00:38,480
The simulator emulates the QuickBot, and
the

13
00:00:38,480 --> 00:00:40,860
QuickBot is defined in the quickbot.m
file.

14
00:00:40,860 --> 00:00:44,030
This is a class and it's located in the
robot package.

15
00:00:44,030 --> 00:00:47,589
Packages in MatLab are denoted by a plus
in front of the folder name.

16
00:00:48,810 --> 00:00:52,100
This robot has a two-wheel differential
drive, meaning that

17
00:00:52,100 --> 00:00:55,640
each wheel is independently, controlled by
a single motor.

18
00:00:57,210 --> 00:01:00,860
And, it also has a wheel encoder for each
one of the wheels.

19
00:01:00,860 --> 00:01:02,710
And these wheel encoders are responsible
for

20
00:01:02,710 --> 00:01:05,320
measuring the distance that each wheel
travels.

21
00:01:05,320 --> 00:01:08,400
And they have a resolution of 32 ticks per
revolution.

22
00:01:10,040 --> 00:01:12,550
And the robot also has five infrared

23
00:01:12,550 --> 00:01:14,890
sensors and these infrared sensors can
detect any

24
00:01:14,890 --> 00:01:17,630
obstacles, that are within a range of four

25
00:01:17,630 --> 00:01:19,520
to thirty centimeters in their field of
view.

26
00:01:23,190 --> 00:01:27,650
Following is a little diagram to explain
to you how the simulation actually works.

27
00:01:28,800 --> 00:01:32,230
First of all, there is the simulator and
it has a timer object.

28
00:01:32,230 --> 00:01:34,160
And this timer object calls at every

29
00:01:34,160 --> 00:01:37,730
time step the execute function inside the
supervisor.

30
00:01:37,730 --> 00:01:41,220
The supervisor is really the decision
maker and it's responsible

31
00:01:41,220 --> 00:01:45,440
for, first of all, gathering the sensor
information from the robot.

32
00:01:45,440 --> 00:01:46,990
It then selects a controller.

33
00:01:48,130 --> 00:01:50,870
And passes the censor information along
with an estimate of the

34
00:01:50,870 --> 00:01:54,640
robot's position and orientation to the
execute function in the controller.

35
00:01:55,720 --> 00:01:59,140
This execute function in the controller,
then computes the

36
00:01:59,140 --> 00:02:02,320
appropriate linear and angular velocity of
the robot which

37
00:02:02,320 --> 00:02:04,270
is then, converted to the left and right
real

38
00:02:04,270 --> 00:02:06,200
speeds of the robot and passed back to the
robot.

39
00:02:07,520 --> 00:02:10,590
Supervisors also responsible for updating
the estimate

40
00:02:10,590 --> 00:02:13,480
of the robots position in orientation and

41
00:02:13,480 --> 00:02:16,660
this whole process is repeated at every
time step.

42
00:02:16,660 --> 00:02:21,200
The supervisor itself was defined in the
QB supervisors.Mfile where

43
00:02:21,200 --> 00:02:24,920
as all of the controllers are found in the
controller package.

44
00:02:27,910 --> 00:02:32,420
The first part of this assignment is, to
convert the linear angle of velocity

45
00:02:32,420 --> 00:02:34,410
in the controllers to the left and

46
00:02:34,410 --> 00:02:37,390
right angular wheel velocities on the
mobile robot.

47
00:02:38,420 --> 00:02:39,940
You'll do this in the unit diff

48
00:02:39,940 --> 00:02:43,390
function which is defined in the
differentialdrive.m file.

49
00:02:44,720 --> 00:02:48,140
This function takes in the linear and
angular velocity of

50
00:02:48,140 --> 00:02:51,540
the robot and returns the left and right
wheel speeds.

51
00:02:51,540 --> 00:02:52,990
The skeleton code show you how

52
00:02:52,990 --> 00:02:57,630
to retrieve the radius of the reel r and
the distance between the two reels, l.

53
00:02:58,980 --> 00:03:01,610
What you need to use to calculate the left
and right wheel speeds.

54
00:03:04,360 --> 00:03:07,280
The second part of this assignment is
odometry.

55
00:03:07,280 --> 00:03:10,800
What you need to do is to measure the
distance traveled by each

56
00:03:10,800 --> 00:03:13,790
wheel and estimate the position and
orientation

57
00:03:13,790 --> 00:03:16,940
of the robot using those measured
distances.

58
00:03:16,940 --> 00:03:18,390
You will implement this in the update

59
00:03:18,390 --> 00:03:22,580
odometry function, which is inside the
QBSupervisor.m file.

60
00:03:22,580 --> 00:03:24,890
Let's take a look at the skeleton code for
this function.

61
00:03:27,820 --> 00:03:30,970
Here you have the ske, skeleton code for
this function.

62
00:03:30,970 --> 00:03:34,330
First you will retrieve wheel encoder
takes from the robot,

63
00:03:34,330 --> 00:03:38,860
then you will recall the previous wheel
encoder takes; which is

64
00:03:38,860 --> 00:03:43,540
used Which is achieved by retrieving the
previous text stored in

65
00:03:43,540 --> 00:03:45,770
the pre, from the, in the previous
iteration of the code.

66
00:03:47,920 --> 00:03:52,520
Then, you will use, then you will retrieve
the current state estimate,

67
00:03:52,520 --> 00:03:56,750
meaning, what is the current estimated
position and orientation of the robot.

68
00:03:57,840 --> 00:04:03,120
Then, you will retrieve the, the useful
constants such as

69
00:04:03,120 --> 00:04:06,000
the radius of the wheel, the distance
between the wheel, and.

70
00:04:07,130 --> 00:04:10,950
How many readers are there for each tic
of, each tic of the encoder.

71
00:04:12,810 --> 00:04:16,030
Then your part comes, which is to
implement odometry

72
00:04:16,030 --> 00:04:21,070
by computing the difference in the X
position, the difference

73
00:04:21,070 --> 00:04:24,270
in the Y position, and the difference in
the orientation

74
00:04:24,270 --> 00:04:28,730
between now and the last time the odometry
was updated.

75
00:04:28,730 --> 00:04:33,670
You will then add these deltas to the
current estimate of

76
00:04:33,670 --> 00:04:38,600
the pos, current estimate of the
orientation and position, and save, and

77
00:04:38,600 --> 00:04:43,570
save that as the new estimate.
You will also need to save the

78
00:04:43,570 --> 00:04:48,530
current number of ticks in the right and
left wheels for the next iteration.

79
00:04:48,530 --> 00:04:54,150
[INAUDIBLE]

80
00:04:54,150 --> 00:04:57,570
Part of these assignments is to make sense
of the IR distance sensors.

81
00:04:58,790 --> 00:05:02,090
In particular, these sensors will return
votages in

82
00:05:02,090 --> 00:05:03,790
the range from 0.4 to 2.75 and those

83
00:05:03,790 --> 00:05:09,700
correspond to distances between four and
30 centimeters.

84
00:05:09,700 --> 00:05:12,290
The relationship between distance and
voltage, is

85
00:05:12,290 --> 00:05:13,700
shown in the graph on the left.

86
00:05:15,300 --> 00:05:18,790
Now what, to make matters a little bit
more complicated, is that the

87
00:05:18,790 --> 00:05:22,770
robot actually returns a integer value in
the range of 200 and 1,375.

88
00:05:22,770 --> 00:05:28,910
What these values simply correspond to the
voltage divided by two then multiplied

89
00:05:28,910 --> 00:05:29,635
by 1,000.

90
00:05:31,540 --> 00:05:35,970
Since the graph on the, in the previous
slide is not linked is not linear.

91
00:05:35,970 --> 00:05:38,750
We need to use the [UNKNOWN] polyfit to

92
00:05:38,750 --> 00:05:42,680
find a fifth-order polynomial that will
fit the data.

93
00:05:42,680 --> 00:05:46,240
We will then use the coefficients from
that function and the polyval

94
00:05:46,240 --> 00:05:49,910
function to convert from the integers to
an actual distance in mirrors.

95
00:05:51,180 --> 00:05:53,440
You will do this in the get IR Distances
function.

96
00:05:54,790 --> 00:05:57,080
This function is defined in Quickbot.m.

97
00:05:57,080 --> 00:06:00,010
And you need to implement two specific
parts.

98
00:06:00,010 --> 00:06:04,100
First you need to properly convert from
the integers to the voltage, and then

99
00:06:04,100 --> 00:06:07,710
you need to hard code the coefficients
that were output by the polyfit function.

100
00:06:11,200 --> 00:06:15,200
To help you test the assignment, we've
included a go to angle controller.

101
00:06:15,200 --> 00:06:19,350
This is a P regulator, which will simply
steer the robot to a specified angle.

102
00:06:20,590 --> 00:06:23,540
If you wish to change the angle to which
this robot steers, you

103
00:06:23,540 --> 00:06:26,585
need to go into the constructur and

104
00:06:26,585 --> 00:06:28,920
QBSupervisor.m and change this variable,
right here.

105
00:06:29,970 --> 00:06:31,950
Object.theta_d.

106
00:06:32,990 --> 00:06:36,300
I have it set to pi divided by four, so
we'd expect that the robot

107
00:06:36,300 --> 00:06:40,630
would drive off at a 45 degree angle with
respect to the x axis.

108
00:06:42,560 --> 00:06:44,130
So let's see this in action.

109
00:06:44,130 --> 00:06:44,630
I'm

110
00:06:51,450 --> 00:06:54,730
going to hit play and what we should see
is the robot.

111
00:06:54,730 --> 00:06:57,640
Drived at a 45 de, de, degree angle.

112
00:06:57,640 --> 00:06:58,140
I'm

113
00:07:00,790 --> 00:07:04,420
going to move the graph out of the way and
we're going to follow this robot.

114
00:07:05,460 --> 00:07:09,310
And as you can see it's driving at 45
degrees with respect to the x axis.

115
00:07:09,310 --> 00:07:14,070
It's going to just continue driving at
this angle all

116
00:07:14,070 --> 00:07:17,290
the way until it's going to crash into the
thread wall.

117
00:07:27,410 --> 00:07:28,680
There you go, we found a crash.

118
00:07:30,900 --> 00:07:36,060
You'll see in the, in the command window,
that I've actually been spitting out the

119
00:07:36,060 --> 00:07:41,070
estimated posts from the odometry at every
time step, and you can see that the values

120
00:07:41,070 --> 00:07:45,810
that I'm getting for the angle are close
to pi divided by four.

121
00:07:45,810 --> 00:07:51,080
So this controller successfully steers the
robot toward that angle.

122
00:07:52,950 --> 00:07:56,060
My tips for this week are to, first of
all, make sure you read

123
00:07:56,060 --> 00:07:59,810
the section on week two in the manual for
more

124
00:07:59,810 --> 00:08:02,450
details than you find in the slide, in
these slides.

125
00:08:03,490 --> 00:08:08,750
And also, to use the commented out fprintf
statements

126
00:08:08,750 --> 00:08:11,650
that I've included in the comments in the
code.

127
00:08:11,650 --> 00:08:15,590
Or into, maybe add some more, more of your
own and this is really

128
00:08:15,590 --> 00:08:18,130
useful for debugging because for example,
when

129
00:08:18,130 --> 00:08:21,250
you're dealing with implement in the
odometry,

130
00:08:21,250 --> 00:08:24,030
you want to print out what you're
currently

131
00:08:24,030 --> 00:08:26,130
estimating the position of the robot to
be.

132
00:08:26,130 --> 00:08:30,890
You know for example you can easily see
that my robot drove at 45 degrees, but I

133
00:08:30,890 --> 00:08:32,670
also needed to print that out to the
command

134
00:08:32,670 --> 00:08:35,130
line to make sure that those values not
jump.

135
00:08:36,150 --> 00:08:37,420
And that's it for this week.