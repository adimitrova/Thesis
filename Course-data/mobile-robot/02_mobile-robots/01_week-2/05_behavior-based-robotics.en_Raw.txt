as i've already said, the world is
fundementally dynamic and changing and
unknown to the robot, so it does not make
sense to overplan and think very hardly
about how do you act optimally given these
assumptions about what the world looks
like. that may make sense if your
designing controllers for an industrial
robot at a manufacturing plant where the
robot is going to repeat the same. motion
over and over and over again. you're going
to do spot welding, and you're going to
produce the same motion 10,000 times in a
single day. then you'll overplan. then
you'll make sure that you're optimal. but
if a robot is out exploring an area where
it doesn't know exactly what's going on,
you don't want to spend all your
computational money on finding the best
possible way to move. because, it's not
actually going to be best. because the
world is not what you thought it was. so
the key idea to overcome this that's quite
standard in robotics, is to simply develop
a library of useful controllers. so these
are controllers that do different things.
like going to landmarks, avoiding
obstacles. we saw one that tried to make
robots drive through center of gravity of
their neighbors. basically, we can have a
library of these useful controllers,
behaviors if you will, and then we switch
among these behaviors in response to what
the environment throws at us. if all of a
sudden an obstacle appears, then we avoid
it. then if we see a power outlet and
we're low on battery then we go and
recharge. so we're switching to different
controllers in response to what is going
on. so what i would like to do is to start
designing some behaviors just to see how
what we learned in module one, a little
bit about control design can be used to
build some behaviors. so let's assume we
have our differential-drive mobile robot.
and to make matters a little easier up
front, we're going to assume that the
velocity. the speed is, is constant. so v
not. we're not going to change how quickly
the robot is moving. so what we can change
i s how we're steering. so you're
basically sitting in a car on cruise
control, where the velocities are
changing, and you steer it. that's your
job. and the question is, how should you
actually. >> steer the robot around. so,
this is the equation then, that's
governing how the input omega, it's the
state that we're interested in, in this
case pi, which is the heading of the
robot. so, pi dot is equal to omega. okay,
so, let's say that we have our. >> yellow
triangle robot, it's a unicycle or
differential-drive robot. it's headed in
direction five, so this is the direction
it's in. and, for some reason, we have
figured out that we want to go in this
direction, five desired or 5 sum d. maybe
there is something interesting over here,
that were interested in. so, we want to
drive in this direction. well, how should
we actually do this? well, pi dot is equal
to omega. so, our job clearly is that of
figuring out what omega is equal to, which
is the control input. alright, so, how do
we do that? well, you know what? we have a
reference, pi desired. well, in module
one. we called references r. right? we
have an error, meaning, that compares the
reference pi desired to what the system is
doing. in this case, pi. so it's comparing
the headings. so we have an error, we have
a reference. you know what? we have a
dynamics. pi dot is equal to omega. so we
have everything we had towards the end of
module one. so we even know how to design
controllers for that. how should we do
that? well, we saw pid, right? that's the
only controller we've actually seen. so,
why don't we try a pid regulator? that
seems like a perfectly useful way of
building a controller. so, you know what,
omega is kp times e, where kp was the
proportional gain. so this response to
what the error is right now. you make kp
large it responds quicker but you may
induce oscillations, then you have the
integral of the error. so you take the e
of tau, the tau times k sub i, which is
the integral gain. and this thing, this
integral, has the nice property that it's
integrating up all these tiny little
tracking errors that we may have, and
after a while this integral becomes large
enough that it pushes the system up to no
tracking errors, that's a very good
feature of the, the interval. even though
as we saw we need to be aware of the fact
that a big ki can actually also induce
oscillations and then we could have a d
terms. a kd times e dot and that where kd
is the, the gain for derivative part. this
makes the system. very responsive but can
become a little bit oversensitive to
noise. so will this work? no it won't. and
i will now tell you why. in this case
we're dealing with angles. and angles are.
rather peculiar beasts. let's say that phi
desired a 0 radiance. and my actual
heading now, phi is 100 radiance. then the
error is minus 100 radiance. which means
that this is a really, really large error.
so omega is going to be ginormous. but,
that doesn't seem right. because 100 pi
radius is the same as zero radius, right?
so, the error should actually be zero, so
we should not be niave when we're dealing
with angles. and, in fact this is
something we should be aware of. is angles
are rather peculiar beasts. and we need to
be, be dealing with them. and there are
famous robotic crashes that have been
caused by this. when the robot starts
spinning like crazy. even though it
shouldn't. but it's doing it because it
thinks it's 200 pi off instead of zero
radius off. so what do we do about it?
well the solution is to ensure that the
error is always between minus pi and pi.
so minus 100 pi, well that's the same
thing as zero. so we need to ensure that
whatever we're doing is we're staying
within minus pi and pi. and there is a
really easy way of doing that. we can use
a function, arc tangents two. any language
there is a library with and it operates in
the same way. it's a way of producing
angles between minus pi and pi. c plus,
plus has it, java has it, matlab has it,
whatever you, python has it. so you c an
always do this and how do you do that?
well you take the angle that's now
1,000,000 pi right and you take sine of it
comma cosine of it. so this is the same as
saying that we're really doing arc tan. so
i'm going to write this as tan inverse
sine e over cosine e. but arc tan or tan
inverse. doesn't, it's not clear what that
always returns but arc tan 2, where you
have a coma in it, you always get
something that's within minus pi and pi.
so here's what you need to do, whenever
you're dealing with angles and you're
acting on them, it's not a bad idea to
wrap one of these arc tan two lines around
it to ensure that you are indeed having
values that aren't crazy. so, with a
little caveate that we're going to use e
prime instead of e, the pid regulator will
work like a charm. okay, so here is an
example problem. we've already seen this
picture. this is the problem of driving
the robot, which is the little blue ball,
to. the goal, which is the sun,
apparently, and lets see if we can use
this pid control design on omega to design
controllers that take us to the sun, or to
the goal. and since we're dealing with
obstacles and we're dealing with goal
locations, and we're also talking about
behaviors. at the minmum we really need
two behaviors. goal to goal, and avoid
obstacles. so what we're going to do over
the next couple of lectures, is develop
these behaviors, and then deploy them on a
robot and see if there any good or not.
