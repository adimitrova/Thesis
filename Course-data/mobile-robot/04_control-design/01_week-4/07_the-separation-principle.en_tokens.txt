now
we
have
lots
of
really
good
building
blocks
.
we
have
n't
yet
put
them
together
.
cause
we
do
n't
fully
know
how
they
fit
together
,
but
we
have
lot
's
of
cool
things
.
we
have
controllability
,
that
tells
us
whether
or
not
it
's
possible
to
control
the
system
,
if
we
have
access
to
the
state
.
and
the
way
we
do
that
is
using
state
feedback
.
we
have
this
notion
of
observability
,
which
tells
us
whether
or
not
it
is
possible
to
,
to
figure
out
the
state
from
the
output
,
and
the
way
we
do
that
is
.
by
building
observers
and
we
have
this
tool
that
seems
remarkably
strong
which
is
pole-placement
which
basically
allows
us
to
place
the
closed
loop
eigen
values
where
ever
we
want
.
so
make
them
equal
to
the
desired
eigen
values
and
the
big
question
now
is
how
do
we
put
everything
together
.
and
the
answer
is
known
as
the
separation
principle
.
and
in
a
nut
shell
,
the
separation
principle
,
which
by
the
way
,
is
quite
wonderful
tells
us
that
we
can
actually
decouple
observer
design
and
control
design
from
each
other
meaning
we
can
actually
control
the
system
as
if
we
have
x
,
even
though
we
do
n't
.
and
then
we
can
get
their
estimate
from
x
using
an
observer
structure
.
so
this
is
the
topic
of
today
's
lecture
and
it
really
is
the
reason
why
we
're
able
to
effectively
control
linear
systems
.
so
,
here
's
the
game
plan
.
now
,
i
have
x
dot
is
ax
+
bu
.
y
is
cx
.
so
this
is
a
standard
linear
time
and
variance
system
.
now
i
'm
going
to
assume
that
this
system
is
both
completely
controllable
and
completely
observable
.
if
it
's
not
then
,
to
be
completely
frank
,
we
're
toast
.
what
that
means
,
we
need
to
go
and
buy
new
sensors
,
which
is
fancy
speak
for
get
a
new
c
matrix
.
or
we
need
to
buy
more
actuators
which
means
get
a
better
b
matrix
.
so
let
's
assume
that
we
have
complete
controllability
and
complete
observability
.
well
,
the
1st
step
in
our
game
plan
is
let
's
ignore
the
fact
that
we
do
n't
have
x.
so
i
'm
going
to
design
the
state
feedback
controller
as
if
i
had
x
,
meaning
i
'm
going
to
pick
u=-kx
,
which
means
that
i
get
my
closed
loop
,
my
closed
loop
dynamics
to
be
this
.
now
,
this
is
what
i
designed
for
and
i
have
my
favorite
pole
placement
tool
to
do
this
.
now
,
in
reality
,
i
do
n't
have
that
.
reality
is
i
have
u
is
-kx
hat
,
where
the
hat
is
my
estimated
state
.
so
that
's
what
i
actually
have
even
though
that
's
not
what
i
designed
for
.
now
step
two
,
of
course
,
is
i
'm
going
to
estimate
x
using
,
using
an
in
order
to
get
this
x
hat
and
to
make
it
be
as
pleasant
as
it
can
.
the
big
thing
that
we
should
note
now
is
that
previously
we
did
n't
have
a
u
term
in
the
observer
dynamics
.
now
we
do
have
a
u
term
that
we
need
to
take
into
account
but
it
turns
out
that
it
's
very
simple
to
do
that
.
i
built
my
predicter
and
the
predicter
part
now
.
contains
both
ax
hat
and
a
bu
term
,
because
a
predictor
is
just
a
copy
of
the
dynamics
.
and
then
i
have
my
corrector
part
which
is
this
error
between
the
actual
output
and
what
the
ouput
would
have
been
if
i
had
x
hat
instead
of
x.
well
,
this
structure
again
gives
me
the
same
aerodynamics
here
.
so
what
we
do
is
i
pick
l
so
that
my
error
,
my
estimation
error
is
stabilized
.
and
that
's
before
the
error
is
the
actual
state
minus
my
estimated
state
.
so
this
is
my
game
plan
.
now
,
let
's
see
if
this
game
plan
is
any
good
.
a
fact
.
it
should
be
good
right
?
because
otherwise
i
'm
wasting
everyones
time
with
these
slides
,
but
let
's
make
sure
that
it
indeed
is
worth
while
.
what
do
we
want
,
this
system
to
do
?
we
want
to
drive
x
to
zero
,
because
we
're
stabilizing
it
,
and
we
want
to
drive
e
to
zero
,
because
we
want
the
estimate
to
be
good
.
so
,
what
i
need
to
do
,
is
analyze
the
joint
dynamics
together
.
so
x
dot
,
is
ax+bu
,
but
u
is
,
if
you
remember
,
u
=
-k
,
not
x
,
but
x-hat
,
which
is
why
i
get
my
x
dynamics
to
look
like
this
.
while
me
e
dynamics
,
that
's
the
matrenary
dynamics
,
is
what
it
has
always
been
.
okay
,
let
's
simplify
this
a
little
bit
.
so
,
i
know
that
the
error
is
x
minus
x
hat
.
so
i
can
replace
this
x
hat
with
x
minus
the
error
.
so
then
i
get
my
dynamics
after
some
pushups
to
be
a
minus
bkx
.
plus
bk
.
e.
so
now
i
have
something
that
involves
x
and
e
and
here
it
only
invovles
e.
so
now
i
can
actually
write
everything
in
a
joint
way
.
x
dot
e
dot
is
this
large
matrix
now
that
's
not
an
nxn
but
it
's
a
2nx2n*x
e.
and
mow
,
our
strategy
,
our
joint
strategy
works
if
and
only
if
this
new
joint
system
is
an
asymptotically
stable
system
.
which
means
that
we
need
to
check
the
eigenvalues
of
this
new
system
matrix
.
now
,
here
is
where
the
separation
principle
comes
into
play
.
this
is
my
dynamics
.
now
,
this
matrix
here
is
a
rather
special
matrix
.
because
it
's
triangular
.
it
has
a
block
there
,
it
has
a
block
there
and
it
has
a
block
there
.
and
triangular
matrices
,
or
block
triangular
matrices
.
may
they
be
upper
or
lower
triangular
.
they
have
a
particularly
nice
structure
.
so
this
is
an
upper
triangle
block-matrix
and
the
eigenvalues
are
given
by
the
diagonal
blocks
.
which
means
that
the
eiganvalues
to
this
whole
matrix
are
the
eiganvalues
to
this
matrix
and
the
eiganvalues
to
this
matrix
.
or
another
way
of
writing
it
is
that
the
characteristic
equation
is
the
characteristic
equation
to
the
first
block
here
.
times
the
characteristic
equation
to
the
second
block
here
.
all
that
this
means
is
that
the
eigenvalues
are
given
by
the
values
of
the
diagonal
blocks
.
and
here
is
the
wonderful
part
.
if
we
have
n't
been
stupid
in
how
we
did
the
design
,
then
this
thing
has
been
stabalized
,
because
we
did
cold
placement
to
make
sure
that
the
real
part
of
our
diagonals
is
strictly
negative
.
this
part
we
have
made
sure
is
also
well
behaved
because
we
have
designed
our
observer
in
such
a
way
that
real
part
of
the
eigenvalue
is
completely
negative
.
which
means
that
we
have
n't
messed
anything
up
.
everything
works
.
what
that
means
is
.
control
design
people
,
we
can
design
our
controllers
as
if
we
had
the
state
and
than
we
rely
on
our
clever
sensing
people
to
estimate
the
state
for
us
.
and
thanks
to
the
separation
principal
everything
works
.
now
the
ones
that
we
keep
in
mind
is
that
we
still
have
this
term
here
,
and
this
term
that
basically
tells
you
something
about
what
happens
to
transients
.
but
after
awhile
.
this
term
does
n't
really
matter
and
everything
works
,
so
now
we
are
ready
to
state
the
separation
principle
.
the
separation
principle
tells
us
that
we
can
in
fact
design
controllers
as
if
we
have
x.
and
then
,
we
can
design
the
observers
independent
of
the
control
actions
,
because
all
we
're
doing
is
,
we
're
adding
a
+
bu
in
the
observer
dynamic
,
so
the
control
actions
are
actually
just
canceled
out
.
in
other
words
,
control
and
observer
designs
can
be
completely
separated
.
so
,
if
you
put
everything
together
,
in
a
final
glorious
block
diagram
.
this
is
what
the
world
looks
like
.
we
have
our
system
.
this
is
physics
.
this
is
what
a
system
does
.
now
,
we
have
modeled
it
using
a
b
and
c
matrices
,
but
what
comes
out
of
this
thing
is
y
,
meaning
our
measurements
and
what
we
push
into
this
system
is
u
,
our
control
action
.
now
,
we
're
taking
u
,
sorry
,
we
're
taking
y
and
feeding
it
into
the
observer
.
so
the
observer
now
is
,
ax-hat
+
bu
+
l
(
y-cx-hat
)
and
,
the
one
thing
to
note
,
is
that
we
need
both
,
y
and
u
to
feed
into
the
observer
.
now
,
out
of
the
observer
comes
x-hat
,
meaning
,
our
estimate
of
what
the
system
is
actually
doing
.
and
now
,
we
use
x-hat
to
feed
back
,
to
get
are
,
are
u.
and
the
beautiful
thing
here
is
that
,
these
two
blocks
together
,
they
constitute
the
controller
.
so
these
two
blocks
are
what
's
being
done
in
software
and
this
,
is
the
physics
of
the
world
.
so
this
the
plant
,
there
's
nothing
we
can
do
about
that
and
the
controller
consists
now
of
two
pieces
.
one
piece
that
,
estimates
the
state
and
another
piece
that
computes
the
control
action/g
.
so
now
we
have
everything
we
need
to
do
effective
control
design
and
what
we
'll
do
in
the
next
lecture
,
which
is
the
final
lecture
,
lecture
of
this
module
is
that
we
'll
actually
deploy
it
.
and
in
fact
,
we
're
going
to
see
it
in
action
on
a
humanoid
robot
where
we
're
doing
simultaneous
control
and
state
estimation
.
