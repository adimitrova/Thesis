So, we now have a general procedure for 
designing controllers which is pole placement. 
And the whole idea there is, we pick our k such that the desired eigenvalues line 
up. We also, in the last lecture, learned 
when it works and when it doesn't and the key characteristic there was 
controlability or complete controlability. 
We can do pole placement when we have complete controlability. 
If we don't, we can't. Simple as that. 
And in fact, it's not just pole placement. 
If we don't have complete controlability, we can't make the system do what we want 
meaning, we have to buy a new one, bigger b matrix. 
There's nothing else we can do. Today, in this lecture, I would like to 
unleash these awesome powers that we have on a complicated robotic system, namely a 
Segway robot. And in fact, this is a robot that's 
balancing on these two wheels, and in fact, here at Georgia Tech, 
we have a Segway robot, known as the golem crane in Professor Mike Stillman's 
lab. And basically, the way a Segway robot 
works is that it's a unicycle, roughly a unicycle, on top of which there is an 
inverted pendulum. And luckily for us, we know how to model 
unicycles and inverted pendulas. Now, I'm writing +... 
there because there's a little bit more going on, but basically we're going to be 
moving while balancing this thing. so, let's start with the base. 
The base is a unicycle, x1 and x2, 
that's the x and y position of the base. And it's v cosine psi, where psi is the 
heading. And psi dot is still omega. 
We've seen this repeatedly. So, this is the dynamics of the base, 
almost. And then, on top of that, we have this 
inverted pendulum. And as we've seen, we need phi, which is 
the angle by which the pendulum is deviating from upright position and we 
also need the angular velocity to describe what is going on here. 
Now, the inputs to a Segway robot are torques, wheel torques. 
So, the left wheel torque and the right wheel torque. 
And torques translates into forces, or torques and forces translate into 
accelerations, but here in the unicycle, these are, are old control inputs. 
The velocities now, since we have inputs that acts as torques, we need to actually 
add v dot and omega dot into the equation. 
So, v and omega are going to be extra states, that's where the +... 
comes from because, what I have done is I have added v and omega as states to my, 
my model. So, what I really have in terms of the 
state of the system, well, it's the position of the unicycle, the 
translational velocity, its orientation, the angular velocity, and then phi and 
phi dot associated with the upright face. And my inputs are these wheel torques, 
left and right wheel torques. And in fact, if I write down the dynamics 
of this thing. Well here, I just have the unicycle 
dynamics. That's all that I'm saying here, this is 
unicycle dynamics. And then, I have all these other 
derivatives that I need to solve and compute. 
And if you sit down and do the math very carefully or you look in a book or 
something, you got this mess here. Wooh, this looks kind of horrible. 
Well, the first thing we do, of course, when we have something like this is we 
linearize it. This looks absolutely miserable. 
But if we linearize it, what we end up with is a, an LTI system and, in fact, 
it's x dot is Ax+Bu, and I should point out that what I've done, is I've 
linearized this around (x,u)=(0,0), which means that I have zero torques and the 
position of the robot is at zero. It's looking at the x direction and the 
pendulum is looking straight up. So, I'm linearizing it around 0,0. 
And if you do that, you get the following A and B matrices. 
Obviously, I'm not going to ask anyone to [LAUGH] memorize this. 
I'm just showing you. This is where the A and B matrices came 
from. Now, before we even attempt pole 
placement, let's make sure that we can indeed do it. 
So, the first thing we have to check now for this system is controllability. 
And this is too big, right? So, I'm going to go to MatLab right away and write, 
here's the controllability matrix of my A and B, here's the rank, and out comes 6. 
Does anyone remember what n was in this case? Well, I do. 
n was equal to 7, which means that the rank of the controlability matrix was not 
equal to 7. So, this is not a completely controllable 
system. And the problem here is the unicycle. 
We've already seen that when we linearize the unicycle, the dynamics gets messed 
up, we can't move in the y direction. I don't know if you remember that but if 
you say an x and y is the position of the unicycle, then we had y dot equal to 0. 
What that means is we have no way of moving sideways basically. 
So, the unicycle is what's making life hard for us here, so what I'm going to do 
is I'm just going to ignore the unicycle. Say, that the position and orientation of 
the base, I don't care about that, but what I care about is, the velocities, how 
quickly it's moving and how quickly it's turning. 
So, I'm going to shave off x, y, or x1, y, x1, x2 and psi from the state space 
and get a smaller system that has s states, the velocity, translational 
velocity, angular velocity and these phi and phi dot associated with the pendulum. 
If I do that, I get a 4 by 4 system with the following A and B matrices, again, 
the actual numbers aren't that, that important. 
Well, I go to MatLab, I write rank controllability matrix, I get the answer 
being 4. In this case, n was equal to 4. 
So, if I shave off the unicycle base from my system, I get the completely 
controllable system. Now, I can start controlling it. 
The last twist though before I do that is, I want my system to actually move. 
So, I'm not going to stabilize it to v and omega equal to zero, because that's 
not what I want. Instead, I'm going to say, I would like 
it to go to v desired and omega desired. So, let's just subtract away v desired 
and omega desired, and then I have a 0 here because you want 
to stabilize it to phi and phi dot being zero, 
meaning, the pendulum being upright. I'm going to find a new state, 
x tilde, which is my old state minus this delta which is the thing I would like to 
stabilize it to. So, this is my delta. So, I have a new state. 
Well, what's the dynamics of the new state? Well, delta x tilde dot is x minus 
delta dot, delta is constant so this is 0 so this is just x dot. 
So, it's Ax+Bu. Well, I can write, I can add a minus 
delta and add in an A delta at the end because then I have x tilde again here. 
so, if I do that, I get a new system and here is the lucky part for us. 
A times delta turns out to be equal to zero because of the structure of A so I 
get this thing going away. I have x tilde here so my new system 
dynamics is the same as my old system dynamics. 
x tilde dot is Ax tilde plus Bu. And now, I want to stabilize this system 
down to the origin, which means that the velocities are 
actually going to end up being equal to the desired velocities. 
So, we have completely control of the system. 
We wish to stabilize it. We do pole placement. 
And again, like we talked about last time, 
it isn't entirely clear how to pick the eigenvalues. 
So, I played around with the eigenvalues and this seemed to give a good response. 
I didn't want oscillations, so there are no imaginary parts, and I picked lambda 1 
minus 19, lambda 2 minus 7.5, and so forth. 
This is the smallest eigenvalue, it's going to tell me how quickly, in general, 
the system responds. So, with this, I'm going to pick u as -K 
not x but x tilde, which is the, the new system I'm interested in. 
I get my close look dynamics like this. And, in fact, the way I compute K is to 
use the, the place command in MatLab. So, I type in my P and K is place A, B, 
and P. So, this stabilizes the Segway robot. 
So now, the last thing we have to do is to actually do it. 
And the reason why I'm okay with neglecting the unicycle base and only 
controlling v and omega is that the curvature of the path that's being traced 
by the Segway robot, actually is omega over v. 
So, what I'm really controlling now is the curvature of the path rather than 
where the actual robot is. And what I can do in the simulation that 
I'm about to show you is basically, with buttons, make v bigger or v smaller or 
omega bigger or omega smaller. And in essence, what I'm doing when I'm 
changing v and omega is I'm changing v desired and omega desired. 
So, that's the way I'm going to be giving reference signals or commands to the, the 
unicycle robot. So, with that, let's move to the actual, 
actually the simulation of an actual Segway robot. 
So now, we're ready to see our developed Segway robot controller in action. 
And I'm here with Greg Droge who is a graduate student at Georgia Tech who will 
be showing us a simulation of the, the Segway robot, so, Greg, what do you have 
to show us? Okay. Here, we have a simulation of the Segway 
robot. On the left, we have a 3D implementation 
of the graphics. So, you can see that now, I'm able to 
drive it around changing the velocities. Just as, just as Dr. 
Egerstedt mentioned with the keypad. and you notice a few interesting things. 
Right here in the top right corner you see the plot of the translational 
velocity. The red line is the desired velocity and 
the blue line is the, the actual velocity. 
And you see that it converts this very quickly to the inputs that I give it. 
And on the middle, you see the rotational velocity and you see because of the 
eigenvalues that we've chosen, that it actually converges really slowly but it 
still converges. And on the bottom you see that they're, 
the tilt angle will always keep the, the robot stable. 
So, I have a question. Are you simulating this on the 
linearization or on the full nonlinear model? 
So, the simulation is on the full nonlinear model. 
Aha, so I actually have a question. So, linearizations are only valid 
locally. do you have any sense for when this 
breaks? Meaning, can we make the robot fall over, for instance? Yeah, so if you 
give it a really big huge step input of the translational velocity you'll see 
that in the 3D simulation, it goes in a full circle and it actually hit the 
ground. Do, do that again. 
That was exciting. Okay. 
Aha, so there, we actually get a feeling for how good or reasonable the 
linearizations are. And in this case, it's fairly reasonable, 
you can drive it around, but if you give it really large desired velocities, it 
actually falls over. Correct. 
Alright. Thank you very much, 
Greg. Yup. 
You're welcome.