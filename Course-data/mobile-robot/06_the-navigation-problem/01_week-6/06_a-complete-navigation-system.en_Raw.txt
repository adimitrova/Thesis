the missing piece of the navigation 
puzzle was follow walls. 
and now we have it, in the sense that we 
know how to move along boundaries of 
obstacles. 
we also know which direction to go in and 
that was given by this sliding condition. 
the one thing we don't know though is 
when to stop, because take a look here. 
first of all, this is how follow wall, or 
go to goal is taking me. 
sliding tells me that, you know what, i 
should move up in this direction. 
let's look at this point. 
go to goal wants me to go there. 
avoid obstacle wants me to go there. 
and if i draw this again a little better, 
they are pointing in completely opposite 
directions. 
and if i'm just sliding, i no longer have 
anywhere to go. 
if i'm, instead using, in this case, r 
negative pi over 2 times u avoid 
obstacle, 
then that's just going to keep me going 
in a counterclockwise, 
sorry, in a clockwise manner. 
so that's why this is the better behavior 
to use, even though sliding is useful to 
go, to know which direction to start in. 
now, if i do that, then i'm happily going 
like this, 
but check out at this point. 
go to goal wants to go there. 
avoid obstacle wants to go there. 
we are no longer in conflict when it 
comes to the switching conditions so any 
kind of sliding condition is going to 
fail because here. 
i'm simply going to return to go to goal 
and then i'm going to just keep doing 
this over and over again and i'm going to 
get stuck in this corner. 
so, sliding is not answering when to stop 
sliding or when to stop following walls. 
instead, we need some other condition for 
this. 
and here is what needs to happen. 
first of all, we need to [cough] excuse 
me, have made enough progress. 
what does that means? 
it means that if i'm switching here i'm 
kind of, i don't want to stop here, here, 
here because in fact, 
i should stop when i'm closer to the goal 
than where i was when i started sliding. 
because otherwise, you can indeed end up 
in a situation where you're moving 
successively further and further way from 
the goal and basically you're switching 
your way away from where you want to be. 
so, you want to insure that you're closer 
to the goal at the end of the maneuver 
than you were when you began it. 
the other is that you have a clear shot 
to the goal in some sense. 
meaning that you can actually move 
towards it. 
[cough] excuse me. 
clear shot doesn't necessarily mean that 
there are no obstacles. 
becuase, let's say that the goal is there 
and here's a giant obstacle that i 
haven't seen yet. 
i don't know about that, but from any 
practical purpose, i somehow have a clear 
shot to, to the goal. 
so, what we need to do is understand what 
these conditions mean. 
okay, let's say, that i started following 
walls at time tau. 
so, let's say that i'm here, x at time 
tau, that's where i am. 
well, then progress, sufficient progress 
can simply say that the current position, 
this is the current position x current, 
it needs to be closer to the goal than 
where i was when i started my follow 
wall. 
so, if i draw a circle here, at this 
distance around the, the goal, 
let's pretend that this was a perfect 
circle, then, any point here is going to 
be closer to the goal than where i 
started. 
so, here are positions where i'm allowed 
to stop following walls. 
but that's not enough. 
we needed this notion of clear shot also. 
and the clear shot simply is this 
condition here, 
where if i'm sitting here, then follow 
wall, sorry, go to goal wants to take me 
in that direction. 
avoid obstacle wants to take me in this 
direction. 
and we already know how to check whether 
or not they are somehow in agreement. 
what that means simply is that this 
angle, the absolute value of this angle 
should be less than pi/2, 
which we can simply encode by this inner 
product condition, which simply take and 
compute u avoid obstacle transpose u go 
to goal and check if that's positive, 
then we have a clear shot. 
we don't really know about other 
obstacles but at least we have some 
notion of a, a clear shot. 
so, these are the two pieces we need to 
determine when its time to no longer move 
along the boundary. 
okay. 
now, we have everything. 
here's my robot. 
it's very happily going towards a goal, 
right, that's, that's all it's doing. 
and then, you know what, it encounters an 
obstacle. 
so now, xo sorry, x-xo is equal to delta. 
so, i'm delta apart from it. 
and i have this directionality condition, 
right? 
so, i'm going to check if this inner 
product is positive. 
if it is, i should go clockwise. 
similarly i have a counterclockwise 
check. 
so, if this condition is satisfied, i 
should go counterclockwise. 
so now, i know when it's time for me to 
move either in a clockwise or 
counterclockwise direction. 
well, it's conceivable because the real 
world isn't the same as the theoretical 
world that, as i'm sliding, i end up 
closer to the obstacle that i wanted to 
be. 
let's say that the distance of the 
obstacle is now strictly less than delta, 
then i shouldn't slide anymore. 
i should let my dedicated, custom-built 
avoid obstacle behavior just make sure we 
don't slam, we don't slam into things. 
so, you always wrap a pure avoid obstacle 
behavouir in there for safety reasons, in 
order to guarantee that you don't hit 
things. 
remember that we're actually looking for 
both guarantees and a smooth ride. 
and this is our way of having the cake 
and eating it, which very rarely works, 
but in this case, you actually can do it. 
okay, the one thing we need to remember 
though is, we needed to know how close we 
were to the wall, or the obstacle at the 
time we started following it. 
so, we had this thing that we said, let 
tau be the time of the next switch. well, 
i'm going to have something that i call d 
sub tau, which is just the distance when 
i switch. 
and i'm going to reset, remember we 
talked about resets, i'm going to reset d 
sub tau to be the distance to the goal at 
the time i started to follow walls. 
so, here are resets, right? now, i'm 
going to stop sliding or stop following 
walls, well i wrote it as one guard, 
because it's the same condition no matter 
where we're coming from. 
and this condition says, we should have 
had or made enough progress. 
so, this needs to happen and we need to 
have a clear shot, which is this 
condition, okay? 
is it beginning to look a little a little 
messy to be honest, but regardless of 
which, we are able to write it down and 
we know what all of these things are. 
now, this isn't quite work yet because 
right now, it's possible to avoid 
obstacles forever so we need some way of 
stopping this thing and the way to stop 
is, you know what, now this looks like a 
huge mess, right? 
but this simply is the sliding condition 
for following walls in a clockwise 
direction so it's the same condition as 
up here. 
but now, since i'm running out of space, 
i have to write it right on top of the 
arrow. 
i also need the same resets that i had 
here so it's the same condition. 
and similarly, if, well, first of all, 
this condition is satisfied, i do 
counterclockwise and i need to reset this 
distance again. 
so, it's the same condition and the same 
reset as before. 
so now, i basically have everything. 
i just want to add one more thing and 
that's this. 
if the distance to the actual goal is 
less than or equal to some epsilon, then 
i'm done and then i'm going to stop. 
so, here is a rather messy looking hybrid 
automaton, but it is quite glorious in 
its mess because it allows us to get 
smooth performance, or guarantee the 
performance out while running in the 
smooth way. and even though it looks 
hard, all of the things are inherently 
computable and it's actually not that 
complicated. 
so, what i'm going to do is i'm going to 
take this thing that looks messy, shrink 
it down, and make it look even more 
messy, and say, this is our complete 
navigation system. 
i think it is quite elegant, to be 
completely honest. 
and now, its time to ask you know what, 
its elegant, we've done some math, we 
know that it works, so this we think so, 
does it really? and here is the 
unfortunate answer to the question, does 
this work? 
nope, it doesn't, 
which is why you're now getting a little 
annoyed with me because i've spent all 
this time developing this framework and 
now i'm claiming it doesn't work. 
the reason it doesn't work as is is there 
are all these practical considerations to 
take into account. 
and what i'm going to do in the next 
lecture is actually, make it work so that 
it was worthwhile and we can take this 
little messy-looking hybrid automaton and 
print it out and turn it into a badge 
that we can put it on our clothes or 
wherever so we can be really proud of the 
fact that it does work. 
but that is the topic of next lecture. 
