So, in the last lecture, we saw that, 
even for rather un-, scary looking environments. 
Let's say that we had, slight non convexities, or even extended convex 
obstacles. the dynamic duo of behaviors, go to goal 
and avoid obstacle, no longer was enough to negotioate these 
environments. And we saw that we really needed some way 
of flowing a long the boundary of an obstacle in order to be able to get 
around in the world. And today, I want to talk about this 
missing piece. The missinig behavior which is a wall 
following behavior. And what I want to do now is really just 
introduce it and then in the next lecture introduce it in a more systematic way as 
to induce mode when you're trying to avoid sliding or avoid type 1 Zeno. 
So, here is the question. How do you actually follow walls? Or when 
I say walls what I really mean are boundaries of. 
boundaries around obstacles. So let's, let's start simple. 
Here is, as always, an obstacle and I have a disk around it where, this is my 
safety disk. Well, avoid obstacle is going to tell me, 
you know what, I want to move straight away from this From this obstacle. 
Well, how do I , which direction do i go in, in order to maintain a constant 
distance from this obstacle? Well what I need to do is, I need to flow, right, 
along the boundary of this, this region. Well, what this means is that here, I 
need to go in this direction. And what I really need to do then is take 
The direction, given to me by my avoid obstacle behavior, and flip it down, like 
this. And this is a negative pi over 2, or a 
negative 90 degree flip. So, that's what I need to do. 
I need to flip it down by 90 degrees, like this. 
And now, I'm going to call this FW, for Follow-wall, and follow-wall is now, 
simply, like I said, a flip down of 90 degrees, which this curious looking 
matrix here is actually achieving. And I may want to scale it, so I may have 
some scaling that's making this Longer or shorter, depending on, I don't know. 
Whatever concerns you may have. Now, I should point out that, this matrix 
here, I can write as a rotation matrix, that corresponds to a pi over 2. 
Sorry, negative pi over 2 flip. so I can actually write this as alpha, 
which is the scale, times the rotation matrix, that is, the flip, times u, avoid 
obstacle, because that is ultimately the behavior that I'm, that I'm flipping. 
So, this tells me that the way to move around this obstacle, is to simply take 
my avoid obstacle behavior, and flip it. That's as simple as that. 
So, there is a problem though. I can actually flip in 2 different 
directions. Not only can I go like this, I can also 
go like that. So 1 question 1 should ask of course is 
which direction should I go in, but the other question is how do I even 
mathematically describe these 2 options? Well, what I have, what we saw before 
was, we called it U clockwise follow wall, and the clockwise follow wall 
corresponds to a negative pi over 2 flip to avoid the obstacle. 
A counter clockwise follow wall, which means follow it in the other direction, 
well that is simply a pi over 2 flip of the void obstacle behavior. 
So if I introduce this thing that I've already called the rotation matrix, this 
is simply an operation that does this flip over vector. 
If I have a vector here. V, and I want to flip it by phi. 
This new thing here, is simply r of, it's not phi, it's theta. 
R of theta times v. This is how I get this new, this new 
rotated vector. So the rotation matrix is cosine theta 
negative sine cosine. That's the form of this linear operator 
that's flipping vectors at certain angle. Well what we've already seen is that the 
clockwise follow-wall it's a negative pi over 2 flip so this behavior is simply 
equal to alpha times, this matrix times, uAO. 
Now the counterclockwise, while I can write that in the same way, it's just a 
pi over 2 flip instead of a negative pi over 2 flip, which gives me the following 
expression. So, I actually have very, very clean 
expressions for how I should make my flip, 
meaning how I should proceed along the boundary of the obstacle. 
And this works even if their obstacle is not just a point, because all I really 
did was I took a void obstacle, a void obstacle behavior and, and flipped it. 
Now we don't know which direction to go with them. 
So lets say that we have this situation, right. 
[SOUND] I'm going towards the goal, and then let's say when I'm here, I now 
want to switch to a follow-wall behavior. Which direction to choose? it's not 
entirely clear. Right? I, if the robot only sees what's 
going on around here, for instance, how does the robot know what the world looks 
like? We haven't built a map of anything. So, you could either go clockwise, 
which in this case turned out to be the long way around, or you can go 
counter-clockwise, but it's really not clear how we should make this choice. 
But here's one thing one can observe, is that go to goal here is wants to move you 
kind of upwards a little bit. So maybe we can let go to goal make the 
choice for us. Go to goal once the drive was a little 
bit in this direction, not at all in that direction. 
So that's the idea we have here at, that there is no obvious answer, there is not 
then obvious right choice given what local information the robot has. 
The robot doesn't know globally what the world looks like. 
So given that we only know locally what's going on may be we can lack this goal to 
goal behavior. Decide which direction we should go in. 
So let's, let's try to make this a little bit more mathematically precise, what it 
means to let the goal to goal behavior decide. 
Here, goal to goal, the angle was wrong here. 
Goal to goal wants to go in this direction. 
Right? So here, goal to goal wants to drive us up. 
Limit up, so may be we should take follow-wall up. 
So this would be u clockwise. Well, u counter clockwise or u 
follow-wall counter clockwise wants to go down. 
And note, that this angle is less than pi over 2, but this angle, the absolute 
value of it, is greater than pi over 2. So we should be able to look at this 
angle to determine. Where we should go, but lucky for us 
there's a very simple way of checking these angles. 
If I have two rectors v and w I can take what is called the inner product of those 
t which is simple v transposed to w. Well that's equal to the absolute values 
of, or the, the length of vectors times cosine of this angle in between them. 
And if this angle is less than pi over 2, then cosine is going to be positive. 
If it's greater than pi over 2, then cosine is going to be negative. 
So all we need to do. It's to look at the sine of this thing, 
to figure out whether or not we're kind of pointing in the right direction. 
So, here is a test. Check go to goal inner product with 
follow wall clockwise. If that's positive, we should go 
clockwise. So, in this scenario, again. 
Again, we're pointing in this direction, here is the follow wall, so this, go to 
go. Here is u clockwise. 
This angle, is less than pi over 2, which means that, this situation is satisfied. 
Here is u counter-clockwise, so this angle is greater than pi over 2. 
So, that means that the other condition is not satisfied. 
So what we actually have is a local check. 
We compute the direction that two different follow-wall behaviors would 
take us in. Then we just take this inner product with 
go-to-goal behavior, and we check the sign. 
And whoever comes up with a positive sign is the winner. 
and that's the direction we choose to go in. 
Now, there is a problem with this of course. 
And that's that if you remember our labyrinth, or our little maze here, 
right. If I'm following wall, you know what, I'm 
going to follow it all the way around. And I don't want to keep going 
indefinitely around and around, right. So then I'm just spiraling. 
At some point, if here's the goal. I want to release and go towards the 
goal. So one thing that we don't know yet is. 
When do we actually release the follow-wall behavior? When do we stop 
following walls and start approaching goals again? The other question is, you 
know what, we had avoid obstacle we had the rotation matrix, that flips either up 
or down, depending when we're going clockwise or counterclockwise. 
And then I have this little alpha there Is there some natural or systematic way 
on which we can think about the alpha? And that is going to one One of the 
things we will discuss in the next, the next lecture.