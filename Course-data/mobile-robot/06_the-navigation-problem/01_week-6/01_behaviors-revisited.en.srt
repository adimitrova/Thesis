1
00:00:00,012 --> 00:00:04,655
So, congratulations, all that hard work 
paid off. 

2
00:00:04,655 --> 00:00:11,062
Or at least, congratulations if you 
managed to hang in there this far. 

3
00:00:11,062 --> 00:00:18,763
and claiming all that hard work paid off. 
My job now in this module is to show that 

4
00:00:18,763 --> 00:00:25,466
it indeed did pay, Because we're going to 
unleash our Newfound powers on mobile 

5
00:00:25,466 --> 00:00:29,399
robots. 
And this entire module is, dedicated to, 

6
00:00:29,399 --> 00:00:35,293
what's known as the Navigation Problem, 
which means how do you make a robot drive 

7
00:00:35,293 --> 00:00:41,383
around in a world populated by obstacles 
without slamming into things, and getting 

8
00:00:41,383 --> 00:00:47,108
safely to landmarks or goal positions. 
So, in the first lecture, we're going to 

9
00:00:47,108 --> 00:00:51,866
return to this idea of behaviors. 
And we're going to use control theory, 

10
00:00:51,866 --> 00:00:54,827
now, to describe what's actually going 
on. 

11
00:00:54,827 --> 00:00:59,838
And I don't know if you remember. 
But, we actually talked about behaviors 

12
00:00:59,838 --> 00:01:03,230
before. 
These were these atomic primitive things 

13
00:01:03,230 --> 00:01:09,040
that the robots should be doing. 
And then, by connecting them all together 

14
00:01:09,040 --> 00:01:14,808
we get the overall navigation system. 
Now we probably know that behavior is 

15
00:01:14,808 --> 00:01:19,974
just code for a sub-system or a 
controller, and connecting them up 

16
00:01:19,974 --> 00:01:26,044
together is code for a hybrid system. 
So this is really what we need to do, we 

17
00:01:26,044 --> 00:01:30,807
need to revisit behaviors in the context 
of control failure. 

18
00:01:30,807 --> 00:01:36,688
So first we need a model and in fact 
almost always it pays off to start simple 

19
00:01:36,688 --> 00:01:41,037
so we're going to start with old friend 
this point. 

20
00:01:41,037 --> 00:01:46,400
So the position of the robot is X, so X 
is in R2, and I mean its a plain 

21
00:01:46,400 --> 00:01:50,262
[INAUDIBLE]. 
And I'm saying that I can control that 

22
00:01:50,262 --> 00:01:55,362
velocity, of this robots direction. 
Now to compare us, as we've seen are 

23
00:01:55,362 --> 00:01:58,537
differential drive robots. 
You can't really do this. 

24
00:01:58,537 --> 00:02:03,192
Instead, you have to control 
translational velocities and rotational 

25
00:02:03,192 --> 00:02:06,427
velocities. 
So, we can think of this really as for 

26
00:02:06,427 --> 00:02:09,457
the purpose of planning how we want the 
robot to go. 

27
00:02:09,457 --> 00:02:12,682
And then we have to couple this to the 
actual dynamics. 

28
00:02:12,682 --> 00:02:15,192
But, to start with, let's just say that 
x. 

29
00:02:15,192 --> 00:02:20,607
is equal to U, well first of all what 
does that look like in the ax plus bu 

30
00:02:20,607 --> 00:02:23,720
paradigm. 
Well A is equal to zero so this is my A 

31
00:02:23,720 --> 00:02:29,771
matrix simply go to zero and my B matrix 
is simply the identity matrix. 

32
00:02:29,771 --> 00:02:36,185
Well before we do anything else we need 
to see whether or not we can actually 

33
00:02:36,185 --> 00:02:41,274
control this system and we formed a 
controllability matrix B AB. 

34
00:02:41,274 --> 00:02:46,114
Well, A is zero, so this term is zero. 
B is the identity matrix, so this is the 

35
00:02:46,114 --> 00:02:49,977
identity matrix. 
The identity matrix is as full rank as 

36
00:02:49,977 --> 00:02:53,918
any matrix anywhere come. 
So, clearly the rank of gamma is equal to 

37
00:02:53,918 --> 00:02:57,441
2, which by the way is the dimension of 
the system. 

38
00:02:57,441 --> 00:03:00,708
So, we have a completely controllable 
system. 

39
00:03:00,708 --> 00:03:05,620
We should be able to make the system do 
What we would like it to do. 

40
00:03:05,620 --> 00:03:10,056
So we're going to start with what I call 
the dynamic duo. 

41
00:03:10,056 --> 00:03:14,160
These are the key behaviors that you 
always need. 

42
00:03:14,160 --> 00:03:20,181
No matter what your robot is going to do, 
you always need to be able to go to a 

43
00:03:20,181 --> 00:03:23,598
goal location. 
Or a landmark, or a waypoint. 

44
00:03:23,598 --> 00:03:28,734
You always need to be able to go to 
somewhere, and you need to be able to do 

45
00:03:28,734 --> 00:03:33,745
it without slamming into things. 
Without either one of those two, your 

46
00:03:33,745 --> 00:03:37,833
robot just ain't going to be able to do 
what you want it to do. 

47
00:03:37,833 --> 00:03:42,615
So our job now is to design these two 
behaviors using What we've already 

48
00:03:42,615 --> 00:03:45,284
learned. 
So, we're going to do it rather simply. 

49
00:03:45,284 --> 00:03:49,514
We're going to actually simply say, you 
know what, if my robot is here, and I 

50
00:03:49,514 --> 00:03:53,933
want to go in this direction, well, why 
don't I simply say that this is equal to 

51
00:03:53,933 --> 00:03:58,062
my u, because that's equal to x dot. 
So that's going to tell me, this is the 

52
00:03:58,062 --> 00:04:01,450
direction in which The robot is actually 
going to do. 

53
00:04:01,450 --> 00:04:06,131
It's going to be moving or using my 
handwriting but some pretty graphics. 

54
00:04:06,131 --> 00:04:10,649
This is what we are going to do. 
We're going to figure out the direction 

55
00:04:10,649 --> 00:04:14,858
in which we want to move and then set u 
equal to that desired direction. 

56
00:04:14,858 --> 00:04:17,192
Okay, 
let's start with Go-To-Goal. 

57
00:04:17,192 --> 00:04:21,991
This is where the robot is. 
Let's say their goal is located at x of 

58
00:04:21,991 --> 00:04:24,997
g. 
Well, I want to go to the goal, so it's 

59
00:04:24,997 --> 00:04:30,510
really clear where I would like to go. 
I would like to go in this direction, 

60
00:04:30,510 --> 00:04:34,039
xg-x is this vector, and I'm going to 
call it e. 

61
00:04:34,039 --> 00:04:39,276
So, why don't I just put u=e, or u equal 
to some constant k? Times Z, 

62
00:04:39,276 --> 00:04:46,202
well let's see what E dot in this case, 
actually becomes. 

63
00:04:46,202 --> 00:04:52,107
Well, E dots is X gold dot, which is 0, 
minus X dot. 

64
00:04:52,107 --> 00:05:00,468
And X dot, well, that's equal to U which 
is equal to KE so E-dot becomes -ke. 

65
00:05:00,468 --> 00:05:07,961
Well, that's kind of good so if I have E 
dot is -ke, does this work, does it drive 

66
00:05:07,961 --> 00:05:13,084
error down to zero. 
Well, we know we have to check the 

67
00:05:13,084 --> 00:05:17,874
eigenvalues. 
So, if k is just a scalar, as long as 

68
00:05:17,874 --> 00:05:24,514
this scalar is positive, we're fine. 
If we want, for some reason, the matrix 

69
00:05:24,514 --> 00:05:27,487
k. 
We just have to pick a matrix k that has 

70
00:05:27,487 --> 00:05:31,806
positive eigenvalues. 
So, if k is a scaler and positive, we 

71
00:05:31,806 --> 00:05:36,162
know that the system is asymptotically 
[INAUDIBLE] stable. 

72
00:05:36,162 --> 00:05:40,531
If we pick k as a matrix. 
For instance, it could be a diagonal 

73
00:05:40,531 --> 00:05:44,907
matrix, you know? 10, and A 1000, say 
seems silly, but why not. 

74
00:05:44,907 --> 00:05:50,067
This is a positive, definite matrix means 
that the eigen values are all positive. 

75
00:05:50,067 --> 00:05:54,577
I have a minus sign here so I need to 
worry about the negative of K in this 

76
00:05:54,577 --> 00:05:57,392
case the eigen values would be all 
negative. 

77
00:05:57,392 --> 00:06:02,345
So, if you have that I would go with K 
constant but if you have this you will 

78
00:06:02,345 --> 00:06:07,475
indeed drive the error to 0 which means 
that we have solved the go to go problem. 

79
00:06:07,475 --> 00:06:11,231
There are some concerns, though in fact 
there's just one. 

80
00:06:11,231 --> 00:06:16,455
A linear controller means that you have a 
bigger vector the further away you are, 

81
00:06:16,455 --> 00:06:20,612
which means that you're going to go 
faster towards the goal. 

82
00:06:20,612 --> 00:06:24,196
The further away you are. 
Which doesn't, to be honest, make 

83
00:06:24,196 --> 00:06:27,450
complete sense. 
So what we should do, is we should, in 

84
00:06:27,450 --> 00:06:31,298
practice, moderate this. 
To make, maybe the game smaller, when 

85
00:06:31,298 --> 00:06:34,345
we're far away. 
Or make the game constant somehow. 

86
00:06:34,345 --> 00:06:37,615
Because we don't want to go faster when 
we're far away. 

87
00:06:37,615 --> 00:06:41,934
That doesn't quite make sense. 
And you can play around with this. 

88
00:06:41,934 --> 00:06:44,922
As long as K is positive we're actually 
fine. 

89
00:06:44,922 --> 00:06:49,120
And what we're going to implement on the 
robot is this choice of K. 

90
00:06:49,120 --> 00:06:54,109
It's a K that makes the norm of U reach 
some Vnot, so here is Vnot when you're 

91
00:06:54,109 --> 00:06:59,147
kind of far away, and then it's going to 
not go faster when you further way, and 

92
00:06:59,147 --> 00:07:04,279
then when you get closer to the goal, 
meaning when the arrow goes down You 

93
00:07:04,279 --> 00:07:09,342
start slowing down, and in fact, if you 
try to be a little creative in how you 

94
00:07:09,342 --> 00:07:13,837
pick your K, this K here is the K that 
corresponds to this plot then. 

95
00:07:13,837 --> 00:07:18,480
That's the K that we're going to be 
looking at, but you don't have to do 

96
00:07:18,480 --> 00:07:21,419
that. 
in fact, a lot of robotics involves 

97
00:07:21,419 --> 00:07:24,949
clever parameter tuning and Tuning of 
these weights. 

98
00:07:24,949 --> 00:07:29,206
But the whole thing, point here, I want 
to make is that you want to make sure 

99
00:07:29,206 --> 00:07:33,226
that you don't go faster when you're 
further away because that actually 

100
00:07:33,226 --> 00:07:36,937
doesn't make entirely sense. 
Okay, we know how to go, you to go to 

101
00:07:36,937 --> 00:07:38,637
goal. 
Let's avoid obstacles. 

102
00:07:38,637 --> 00:07:43,463
Well, if I wanted to go towards the 
obstacle, I would simply pick xo-x=u, or 

103
00:07:43,463 --> 00:07:48,458
some scaled version of that. 
Well, now I want to avoid the obstacle. 

104
00:07:48,458 --> 00:07:54,552
Why don't I just flip it? And that's now 
x-xo, instead, so flipping it means, I'm 

105
00:07:54,552 --> 00:07:59,908
just going to avoid the obstacle. 
And in fact, that's what we're going to 

106
00:07:59,908 --> 00:08:02,887
do. 
Let's just pick u=K*e, where K is a 

107
00:08:02,887 --> 00:08:07,342
positive constant, 
and e, now, is x obstacle minus x. 

108
00:08:07,342 --> 00:08:11,985
Well, if I do that, I get E dot is ke, 
which is actually an unstable system. 

109
00:08:11,985 --> 00:08:16,073
And it's unstable in the sense that the 
error is not stabilized. 

110
00:08:16,073 --> 00:08:19,614
'Cuz the error is the distance to the 
obstacle instead. 

111
00:08:19,614 --> 00:08:22,285
We're avoiding the obstacle. 
Obstacle. 

112
00:08:22,285 --> 00:08:27,561
Now it's a little scary to have on 
purpose an unstable system in there but 

113
00:08:27,561 --> 00:08:32,964
as you will see we don't worry too much 
about it because we need to make sure 

114
00:08:32,964 --> 00:08:38,471
that the robot actually does not drive 
off to infinity which it would if we were 

115
00:08:38,471 --> 00:08:42,867
was unstable. 
the other thing that a little weird, so 

116
00:08:42,867 --> 00:08:47,850
this is if I use u=k(x-x0). 
The other is, that it's, it's a rather 

117
00:08:47,850 --> 00:08:54,012
cautious system in that we seem to be 
avoiding obstacles that are also behind 

118
00:08:54,012 --> 00:09:00,543
us even that doesn't entirely make sense 
and we also cared less about the obstacle 

119
00:09:00,543 --> 00:09:04,557
the closer we get which. 
Absolutely makes no sense, because we 

120
00:09:04,557 --> 00:09:09,042
should care more the closer we get. 
Well, the solution is again, make k 

121
00:09:09,042 --> 00:09:12,822
dependent on e, or actually the 
distances, so the normal e. 

122
00:09:12,822 --> 00:09:17,887
And to aviod this being overly cautious, 
we are actually going to switch between 

123
00:09:17,887 --> 00:09:22,932
behaviors, and in fact, what we're going 
to do is using something like a induced 

124
00:09:22,932 --> 00:09:28,561
mode, the sliding mode to very gracefully 
Combine goal to goal and avoid obstacles 

125
00:09:28,561 --> 00:09:32,987
but for now let me just point out that 
one clever thing for instances is say 

126
00:09:32,987 --> 00:09:37,306
that you want to care more about to 
obstacle u closer you get, so you want u 

127
00:09:37,306 --> 00:09:40,469
to be bigger the closer to the, the 
obstacle you get. 

128
00:09:40,469 --> 00:09:44,863
So in this case this was the K that we 
used, then in fact this is that K that 

129
00:09:44,863 --> 00:09:49,603
I'm going to use to implement things but, 
again I want to point out that you want 

130
00:09:49,603 --> 00:09:53,292
something that you don't care so much 
when you far away. 

131
00:09:53,292 --> 00:09:58,201
And you care a lot when you close. 
The reason I have an Epsilon here which 

132
00:09:58,201 --> 00:10:03,490
is a small number is just to make sure 
that this thing doesn't go up to infinity 

133
00:10:03,490 --> 00:10:07,995
when they normally is 0. 
Things going off to infinity is typically 

134
00:10:07,995 --> 00:10:11,790
not that good of an idea. 
Okay so we know how to build the 

135
00:10:11,790 --> 00:10:16,194
individual control modes. 
Now we also saw that choice of weights 

136
00:10:16,194 --> 00:10:19,439
matter. 
you should be aware, again, that there 

137
00:10:19,439 --> 00:10:23,642
isn't a right answer in how to pick these 
weights, and depending on the 

138
00:10:23,642 --> 00:10:28,266
application, you may have to tweak the 
weights to make your robot more or less 

139
00:10:28,266 --> 00:10:31,643
skittish or cautious. 
But the structure still is there. 

140
00:10:31,643 --> 00:10:36,711
What's missing, though first of all, is 
to couple this X dot is equal to U model 

141
00:10:36,711 --> 00:10:41,154
to the actual robot dynamics. 
And we're going to ignore that question 

142
00:10:41,154 --> 00:10:45,313
all through this module. 
And devote the last module of the course 

143
00:10:45,313 --> 00:10:48,478
to that question. 
But what we do need to do is make 

144
00:10:48,478 --> 00:10:51,969
transitions between goal to goal and 
avoid obstacles. 

145
00:10:51,969 --> 00:10:56,842
And that's the topic of the next lecture. 
Before we conclude, though, let's 

146
00:10:56,842 --> 00:11:00,935
actually deploy. 
This dynamic duo on our old friend, tho 

147
00:11:00,935 --> 00:11:05,015
compare robots, to see what would happen 
in real life. 

148
00:11:05,015 --> 00:11:10,639
So, now we've seen, in theory, how to 
design this dynamic duo of, robot 

149
00:11:10,639 --> 00:11:14,778
controllers. 
In par-, in particular, we've seen these 

150
00:11:14,778 --> 00:11:18,581
2 key behaviors, goal to goal and avoid 
obstacles. 

151
00:11:18,581 --> 00:11:23,742
And, now, let's actually deploy them. 
For real on our old friend, the [UNKNOWN] 

152
00:11:23,742 --> 00:11:27,077
mobile robot. 
As always, I'm joined by with Sean Pierre 

153
00:11:27,077 --> 00:11:30,047
Delacroix here, who will conduct the 
affairs. 

154
00:11:30,047 --> 00:11:33,797
And, first we're going to see the go to 
gold behavior in action. 

155
00:11:33,797 --> 00:11:36,177
And. 
What we now know is that what this 

156
00:11:36,177 --> 00:11:40,647
behavior really is doing is looking at 
the error between where the robot is, 

157
00:11:40,647 --> 00:11:45,452
right there, and where the robot wants to 
be, in this case this turquoise piece of 

158
00:11:45,452 --> 00:11:47,812
tape. 
And then globally asymptotically 

159
00:11:47,812 --> 00:11:52,412
stabilizing this error in the sense that 
it's driving the error down to zeros. 

160
00:11:52,412 --> 00:11:56,478
So, JP why don't we see the [INAUDIBLE] 
make the error go away. 

161
00:11:56,478 --> 00:12:02,186
So, as you can see, the robot is going 
straight for the goal, and the error is 

162
00:12:02,186 --> 00:12:07,349
indeed, decaying down to zero. 
And this is how you encode things like 

163
00:12:07,349 --> 00:12:10,816
getting to a point. 
You make the error vanish. 

164
00:12:10,816 --> 00:12:12,512
Very nice. 
Thank you. 

165
00:12:12,512 --> 00:12:15,661
So now, we're going to run act two of 
this drama. 

166
00:12:15,661 --> 00:12:21,449
now the robot's sole ambition in life is 
not driving into things, and things, in 

167
00:12:21,449 --> 00:12:25,930
this case, is going to be me. 
one thing that's going to be slightly 

168
00:12:25,930 --> 00:12:30,914
different from what I did in the lecture, 
is that I am not a point, meaning it's 

169
00:12:30,914 --> 00:12:35,109
not just a point but in fact an obstacle 
with some spread that the robot is going 

170
00:12:35,109 --> 00:12:37,754
to avoid. 
In fact, what we're going to do is we're 

171
00:12:37,754 --> 00:12:41,675
going to first of all ignore everything 
that's behind the robot because it 

172
00:12:41,675 --> 00:12:44,593
doesn't care about avoiding things that 
are behind it. 

173
00:12:44,593 --> 00:12:48,871
And the things in front of it, it's going 
to sum up the contributions from all the 

174
00:12:48,871 --> 00:12:52,925
sensors and it's going to care a little 
bit more about things ahead of it than 

175
00:12:52,925 --> 00:12:57,815
on. 
Its sight, so J.P., let's take it away. 

176
00:12:57,815 --> 00:13:04,511
Let's see what can happen here. 
So, here I am. 

177
00:13:04,511 --> 00:13:09,289
Oh, no. All right. 
Very nice. 

178
00:13:11,053 --> 00:13:16,672
Don't hit me. Thank you. 
[SOUND] Perfect. 

179
00:13:16,672 --> 00:13:27,966
We have a perfectly safe robot that is 
not driving into professors at all. 

180
00:13:27,966 --> 00:13:35,056
and with that I think we compute. 
Thank you. 