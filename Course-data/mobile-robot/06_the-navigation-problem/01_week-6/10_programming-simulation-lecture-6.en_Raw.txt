welcome to week six.
this week i'm going to be talking about
following walls.
why do we need to follow walls?
well, last week we solved the navi,
we somehow seemed to solve the navigation
problem.
we had our robot drive from point a to
point b without colliding with any of the
obstacles.
but, the obstacles were fairly easy, and.
the reason for this is that they're
convex.
but we can have these obstacles that are
concave in shape.
so, for example,
take this u-shaped obstacle, and if a
robot starts here
and it's goal location is on the other
side of
the obstacle, what will happen with the
controllers that we
designed last week is that the robot will
drive from here.
into the obstacle, and then start avoiding
the
obstacle, and then drive back into the
obstacle.
because it's always trying to get to this
side, but also avoiding this obstacle.
but it's trapped in here.
because the shape of the obstacle is
concave.
so what we need is an additional
controller, the follow-all
controller, that will, so that when we
make a decision
that we're inside of our concave obstacle,
then we're going to
follow the contour of the, the boundary of
this object, and.
we're going to follow it all the way
around until we've
cleared it and then we can proceed onto
the goal location.
and that's, that's the objective for this
week.
and the way that we'll do this is
we're going to use the infrared sensors to
approximate
a section of the wall, alright?
it's really an obstacle but we're going to
call it a wall.
and.
and once we've, once we've estimated a
section, we're basically
going to figure out a vector that's
tangential to the wall.
and also one that's perpendicular to the
wall.
and the point is to combine these two
vectors into a single
vector that will not only steer the robot
into,into one direction along.
the the, the, the contour of the, the
boundary of the wall.
but also a vector that will make sure that
the robot
neither steers into, into the wall or away
from the wall.
so we're going to maintain some distance
from the wall as we follow it.
now.
how is the robot going to estimate the
wall?
well, first of all, one of the two inputs
into the
controller is going, is going to be either
left or right.
so we are either going to follow a wall
thats to our left or to our right.
so we have to make that decision before we
do anything else.
if we decide that we are going to use.
the left the left direction.
what we're going to
do, is we're going to use sensors one,
two, and three on the robot.
so we're going to use these three sensors.
to, to estimate a wall that's the left, or
an obstacle that's to the left of of the
robot.
and.
what we'll do is we'll pick of these three
we're
going to pick the two, that have the
shortest infrared sensor readings.
and, we already know how to get a point,
on these in the world frame.
so, what we end up is we end up with a
point so.
we have, this point right here which i'm
going to denote as, point 1.
and, this is going to be point 2.
so, we've picked these two, and since
we've picked two points
in the world, we can come up with a vector
right?
so, we're going to come up with this green
vector right here.
and, this green vector is going to be our
vector
that's tangential to the wall.
so i'm going to call this u, the vector u
fw denotes that, this is for the follow
wall, and.
comma t denotes that this is tangential to
the wall.
and really, the way that you define it is,
it's p2 minus p1.
that's the definition of this, of this
vector.
now, i also said that we want to maintain
some spacing from the wall.
so we're going to have to calculate
a vector that's perpendicular.
and the way that we're going to calculate
it is,
again, we have the vector from the
previous slide.
we have u_fw_tp, and this time it has a
prime
mark, and that's because i'm going to
normali, normalize it, and.
thus, and again, i think last week i
talked about this is, what we're
going to do is we're going to just take
the vector, and divide it by its
magnitude.
so that's the,
that's the normalized version of the of
that vector.
and what we'll do is we'll first take a
point on this vector, which is going to be
ua, and.
this point, i'm just going to pick for, to
make it easy, i'm going to pick the first
i'm going to pick the point detected by
this first infrared infrared sensor.
so, this one right here.
because i know this one i could also
picked.
this one right here but i picked the first
one.
now i'm also going to pick another point
which is
going to be the location of the robot in
the world.
so that's going to be my point or vector
up, u sub p.
and since i again have but i have so, i
have this point so i have.
let me indicate that on the slide.
i have
this point right here, this point right
here, and this vector, and what i can do
is i can compute the, a vector that points
from the robot, so from the robot.
to this closest point on the wall.
and the, and the equation that describes
this vector is as follows.
it's this, so this vector, this
perpendicular
vector i'm denoting by u sub fw, p.
and it's this subtraction of these points
dotted.
with a dot product of, of the tangential
vector
and then multiply it again by the
tangential vector.
so this is just some linear algebra that
gives me a vector from the
robot to the closest point on the
wall, that's, that lies on the tangential
vector.
and, this is not sufficient for us to
maintain spacing yet.
what we really want to do, is we want to
find another vector that's goes in
the opposite direction, and, and again
from
the previous slide i have this
perpendicular vector,
so all i'm going to do is i'm going
to normalize it and multiply it by some
distance fw.
so d sub fw.
and.
this distance right here is the distance
that
we want to maintain between the robot and
the walls.
so we want the robot to end up in such a
way that this is equal to dfw.
so the reason that i define this vector
like, like so is that when we can combine.
the two together.
if we combine these two vectors together,
we're
going to get a vector that either points
us
toward the wall if the robot is farther
than
d fw from the obstacle, or from the wall.
and we're going to get a vector that
points us.
away from
the, from the wall if we're closer than d
sub fw.
so, that's the, that's the purpose of
going through, through these equations.
and really, what ends up happening is if
we div if we.
somehow linearly combine the, tangential
vector to the, to the wall.
and the perpendicular vector
the, to the wall, that you know either
points us towards or away depending on the
distance.
if we combine those in some way, we're
going to get a, vector,
u sub fw, which will both.
point us in the direction in which the
wall is going to, that allows
us to follow the wall, and it also has the
component that either pushes us towards or
away from the wall depending on how close
or far we
are away from the obstacle, and this is
exactly what we wanted.
and then the last thing that we have to do
is we just have to use our good
old pid controller to steer the robot in
the
direction of this vector, and we're good
to go.
so how all does this work?
well, you saw in the previous slides that
i got a really good
estimate of, of, of the, of the, of a
section of the wall.
but that's not always the case.
so, for example here on the inside corner,
what i have here is
this is the robot's estimate of, of the,
of the wall.
and you can see that this is an
overestimate.
so, we're actually okay with that, because
if
we're overestimating the wall, that's, you
know, that's
not really problematic because we're not
going to.
we're going to avoid this, this virtual
piece of
the wall and we're not going to slam into
it.
there's no danger of, real danger of that.
but that is on, these inside corners.
on the outside corners we are
underestimating the wall.
so you can see here that the robot thinks
that this represents.
is it
a good representation of the wall?
and if we cut this corner too closely the
robot collide with this
part of the obstacle that it doesn't
really sense because there's a little
bit of spread between the sensors because
we don't have, you know, 20,
20 sensors on the robot that cover every
single inch outside the robot.
we only have five sensors, so we got to
make,
deal with what we have, so here we have to
be a little careful, and that's where the
design of this distance, d
sub fw comes into play.
so, you want to make sure that this, this,
value is large enough to allow us to not
cut corners and collide with the wall.
but also not too large so, so that we
don't lose track
of the wall, because we don't want to end
up too far away
from the wall and then the robot doesn't
sense
the wall anymore and we can no longer
follow it.
so, we want to kind of stick to the wall
as
close as possible, but not too close to
collide.
now the implementation is going to happen
in a new controller, followwall.m.
and you're going to have to implement some
missing logic and,
and, and math that was covered in the
previous slides.
and ag, also again covered in
the, in the manual in much greater detail.
and.
as i said before the, what's, what's
really unique about
this controller its going to accept either
left or right
denoting which side of, which side of the
robot the
wall is going to be in which its going to
follow.
so we're going to tell it you're going to
have to
follow a wall that's going be on your left
or we're going to tell you you're going to
have to
follow an op a wall that's on your right.
and that those are going to be inputs and
those [inaudible], really come into play.
and next week when we have our full
navigation
algorithm and state machine going on.
so, let's see what this looks like in, in
matlab and in the simulator.
i'll launch the simulator and hit play.
and here, we have the robot, following the
wall on it's left.
and as you can see here i got really,
really close, to this corner.
so that was a little dangerous.
maybe i should have picked a better,
better distance to maintain from, from the
wall.
and here we are overestimating so we're
okay.
and here we're going to cut it fairly
close again.
so this is pretty, pretty much a little
too close for comfort.
but, you know, we're not crashing into
the, into the obstacles.
so we're, we're, we're gon, we're okay
with that.
alright.
great.
so, the robot's going to follow this wall
on and on and on until i close this.
now, again, make sure re-read the manual
for weeks, that's been updated for week
six.
it has a lot more details especially, you
know, for
the math and, and has diagrams that will
help you.
implement the logic in all the math in in
the, in the controller.
and
i encourage you to experiment with
different values
of the distance to maintain from the wall.
so you'll see different results for
different distances that you pick.
and also you can decide how to combine the
two vectors that
are tangential and, and perpendicular, to
the, to the wall, and, and, and.
in different ways, so.
and it depends on where you want to put
the emphasis.
you might want to put the emphasis
strictly
on following the law, on following the
law, and not worry about maintaining a
distance
too much, or you could do the converse of
that, it's really up to you.
and with that i wish you good luck.
