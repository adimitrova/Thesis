so
the
outcome
of
the
last
handful
of
lectures
,
was
that
we
needed
something
more
rich
to
solve
complex
navigation
problems
,
and
that
something
was
wall
following
.
in
fact
was
saw
that
we
really
had
2
barriers
,
wall
following
clockwise
and
wall
following
counter
clockwise
.
and
,
the
way
we
could
encode
that
was
to
take
our
avoid
obstacle
behavior
and
simply
flip
,
either
flip
it
-pi/2
for
a
clockwise
negotiation
of
the
obstacle
or
+pi/2
for
a
counterclockwise
negotiation
of
the
obstacle
.
what
i
want
to
do
today
is
relate
this
wall-following
behavior
to
the
induced
mode
when
we
looked
at
type
1
zeno
in
hybrid
systems
.
and
the
point
with
this
is
really
for
us
to
first
of
all
,
trust
that
this
is
the
right
thing
to
do
.
trust
that
we
understand
alpha
.
and
trust
that
we
understand
plus
or
minus
there
.
we
use
some
kind
of
inner
product
rule
to
determine
whether
or
not
we
should
go
plus
and
minus
.
now
we
're
going
to
see
that
that
's
,
indeed
.
the
correct
rule
from
a
sliding
mode
vantage
point
.
however
we
're
going
to
do
little
bit
of
maths
today
and
at
the
end
of
it
we
're
just
going
to
return
back
to
this
and
say
,
this
is
how
,
still
how
we
going
to
implement
it
because
it
is
much
simpler
but
we
need
in
the
math
to
get
there
and
trust
a
that
's
correct
.
so
here
's
the
general
set
,
set
up
.
as
before
we
have
an
obstacle
x
sub
o.
we
have
a
goal
,
x
of
g
,
and
we
have
x
,
which
is
the
position
of
the
robot
.
we
also
have
a
distance
from
the
obstacle
,
when
we
're
going
to
switch
to
avoid
obstacle
as
opposed
to
go
to
goal
,
and
even
though
i
'm
doing
everything
with
points
now
this
works
for
non-convex
obstacles
,
for
pretty
much
anything
.
we
can
write
that
down
at
least
in
this
way
.
and
the
distance
then
being
constant
,
let
's
say
it
's
delta
from
the
obstacle
,
when
i
can
simply
say
that
that
means
that
the
distance
between
the
x
and
xo
is
equal
to
now
,
what
do
i
have
?
i
have
2
different
behaviors
.
i
have
one
behavior
that
wants
to
take
me
towards
the
goal
and
i
have
another
behavior
that
wants
to
push
me
away
from
the
obstacle
.
and
now
i
also
have
a
switching
surface
and
i
'm
going
to
write
this
as
the
distance
between
x
and
the
obstacle
minus
delta
,
should
be
equal
to
0.
but
,
i
'm
going
to
put
squares
in
there
because
i
'm
going
to
start
taking
derivative
and
taking
the
derivative
of
the
square
of
a
norm
is
easy
taking
the
derivative
of
a
norm
is
not
so
easy
,
and
then
i
'm
going
to
put
the
half
here
just
for
the
reason
of
getting
rid
of
some
coefficient
but
this
half
does
n't
change
anything
.
so
now
what
do
i
have
?
i
have
g.
on
one
side
i
have
g
positive
,
which
means
that
you
're
further
away
from
the
obstacle
than
delta
,
which
means
you
're
out
here
where
you
're
going
to
use
this
behavior
.
so
we
have
f1
coming
in
here
,
so
this
is
going
to
be
my
f1
.
and
then
i
have
g
negative
on
this
other
side
,
which
is
inside
here
,
where
i
'm
going
to
use
this
behavior
.
so
that
's
going
to
be
equal
to
f2
.
so
i
have
everything
i
need
to
be
able
to
unleash
our
induced
mode
piece
of
mathematics
.
so
,
f1
is
goal
to
goal
.
f2
is
avoid
obstacle
.
now
,
we
need
to
connect
these
somehow
with
the
induced
mode
.
well
,
here
is
the
connection
.
we
actually
computed
the
induced
mode
.
it
was
this
convex
combination
of
the
two
modes
,
or
the
two
behaviors
.
and
this
convex
combination
was
given
by
this
,
mouthful
of
of
an
expression
.
but
let
's
actually
try
to
compute
this
,
in
this
case
,
to
see
what
,
what
the
induced
mode
should
be
.
well
,
first
of
all
,
we
need
the
lee
derivatives
.
so
,
lf2g
,
if
you
remember
.
that
was
dg
,
dx*f2
.
we
need
the
same
thing
for
f1
and
then
this
lead
derivative
show
,
show
up
repeatedly
.
well
,
first
of
all
the
derivative
of
g
with
respect
to
x
is
simply
x-x
obstacle
transpose
and
this
is
the
reason
why
i
put
squares
here
because
that
made
everything
easy
and
i
put
the
half
there
because
that
hills
an
extra
2
that
would
show
up
.
this
really
does
n't
but
it
just
makes
the
math
a
little
bit
easier
.
this
is
again
one
of
these
things
that
i
encourage
you
to
try
to
compute
yourselves
,
just
to
make
sure
that
you
actually
trust
that
this
is
indeed
the
correct
answer
.
well
,
now
i
can
compute
the
[
unknown
]
derivatives
,
right
?
i
have
lf2g
,
well
it
's
dg/dx
times
f2
well
the
gdx
which
is
computed
it
was
that
.
f2
is
c
avoid
obstacle
,
x-xo
.
in
previous
lecture
,
i
used
k
,
with
the
prime
index
[
inaudible
]
was
c
here
.
well
,
this
is
x-xo
transposed
times
x-x0
.
but
that
's
just
x-x0
squared
,
the
norm
squared
.
so
this
lead
derivative
has
a
rather
simple
expression
.
similarly
,
i
can
compute
the
other
lead
derivative
.
and
its
'
c
,
goal
to
goal
times
this
thing
,
that
we
now
know
is
an
inner
product
of
x-x
obstacle
,
transposed
times
x
goal
minus
x.
so
i
have
the
2
lead
derivatives
that
i
actually
need
.
so
,
with
that
,
i
could
go
ahead
and
compute
the
induced
mode
.
for
instance
.
you
know
,
this
little
thing
here
.
what
is
that
?
it
is
let
's
see
,
it
's
(
x-xo
)
transpose
times
(
cao*
(
x-xo
)
)
,
that
's
the
first
term
,
minus
c
goal
to
goal
times
(
xg-x
)
.
so
,
that
's
that
term
.
we
have
an
explicit
expression
for
it
.
we
can
also
go
ahead
,
and
compute
this
,
right
,
for
instance
.
it
's
cao
,
x-x0
transposed
times
f1
.
which
is
,
what
was
f1
again
?
it
was
goal
to
goal
times
xg
-
x..
so
i
can
compute
this
.
similarly
,
i
can
compute
that
.
the
point
is
first
of
all
that
everything
is
entirely
computable
here
.
the
other
point
is
,
you
know
what
,
this
is
a
little
bit
of
a
mess
.
it
's
a
mess
to
write
it
down
,
but
what
we
've
actually
done
is
[
sound
]
we
have
recovered
the
same
controller
because
what
we
're
doing
is
again
we
're
sliding
.
the
only
difference
is
if
you
write
it
in
this
form
,
you
automatically
get
alpha
to
pop
out
because
you
get
the
certain
scaling
,
and
you
get
plus
or
.
minus
flip
.
so
you
actually
get
the
flip
for
free
,
your
told
which
direction
to
go
and
which
alpha
to
go
in
and
the
nice
thing
is
that
the
flip
direction
you
get
from
computing
the
induced
mode
is
actually
the
same
as
taking
the
inner
products
with
u
follow
ball
counter-clockwise
with
u
avoid
obstacle
,
if
this
inner
.
u
avoid
obstacle
.
if
this
inner
product
is
positive
,
we
go
,
counter
clockwise
,
and
otherwise
we
go
clockwise
.
so
,
the
nice
thing
is
,
we
have
actually
,
in
a
mathematically
rather
involved
way
arrive
at
same
expression
.
and
with
the
difference
being
that
we
can
have
the
plus
or
the
minus
automatically
determined
for
us
,
and
these
scaling
factors
automatically
determined
for
us
.
in
practice
though
,
we
're
not
going
to
do
this
,
because
this
is
too
messy
.
instead
,
we
're
just
going
to
pick
some
alpha
that
we
feel
good
about
.
i
always
pick
alpha=1
because
i
'm
lazy
and
then
use
the
inner
product
tasks
to
figure
out
whether
we
should
go
clockwise
or
counter-clockwise
.
so
,
that
's
practically
what
we
're
going
to
do
.
now
,
that
's
not
enough
,
so
let
's
say
that
i
''
m
going
towards
the
goal
here
.
here
i
want
to
go
in
this
direction
,
and
avoid
obstacle
once
to
take
me
there
,
so
sliding
is
immediately
going
to
tell
me
that
i
'm
going
to
start
moving
up
like
this
.
well
you
know
what
?
this
was
all
good
and
dandy
,
but
if
i
'm
simply
looking
at
the
sliding
rule
.
then
here
,
all
of
a
sudden
i
'm
pointing
in
both
direction
,
and
sliding
is
going
to
tell
me
to
stop
,
so
what
i
need
to
do
is
to
just
keep
following
the
ball
,
verify
then
i
'm
going
to
follow
the
ball
for
a
long
time
way
and
way
and
way
,
around
and
around
and
around
and
may
be
here
the
right
time
to
stop
following
the
ball
.
the
question
that
really
need
to
answer
now
.
when
we
know
that
follow
wall
is
the
right
thing
to
do
,
we
know
which
direction
to
go
in
,
and
we
know
,
really
how
to
scale
it
even
though
we
're
just
going
to
scale
it
by
one
because
it
really
does
n't
matter
is
when
do
we
actually
stop
this
sliding
or
follow
wall
.
well
,
that
turns
out
not
to
be
so
easy
and
in
fact
there
are
multiple
ways
of
answering
that
and
this
is
precisely
the
topic
of
the
next
lecture
.
