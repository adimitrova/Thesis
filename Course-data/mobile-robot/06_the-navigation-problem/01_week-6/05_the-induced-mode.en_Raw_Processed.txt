so outcome last handful 
lectures, that we needed something 
rich to solve complex navigation 
problems, that something wall 
following 
in fact saw that we really 
barriers, wall following clockwise 
wall following counter clockwise 
and, way we could encode that to 
take avoid obstacle behavior 
simply flip, either flip pi a 
clockwise negotiation obstacle 
pi a counterclockwise negotiation 
obstacle 
i want to today is relate this 
wallfollowing behavior to induced 
mode we looked type zeno in 
hybrid systems 
point this is really us 
to first all, trust that this is 
right thing to 
trust that we understand alpha 
trust that we understand plus 
minus there 
we use kind inner product rule to 
determine whether we go 
plus minus 
going to see that thats, 
indeed 
correct rule a sliding mode 
vantage point 
however going to little bit 
maths today end 
going to return back to this 
say, this is how, still we going to 
implement is much simpler 
we need in math to get there 
trust a thats correct 
so heres general set, set 
we an obstacle x sub o 
we a goal, x g, we x, 
is position robot 
we also a distance 
obstacle, going to switch to 
avoid obstacle opposed to go to goal, 
even though im everything 
points this works nonconvex 
obstacles, pretty much anything 
we write that least in this 
way 
distance constant, 
lets say delta obstacle, 
i simply say that that means 
that distance between x xo is 
equal to now, i i 
different behaviors 
i one behavior that wants to take 
towards goal i another 
behavior that wants to push away 
obstacle 
i also a switching surface 
im going to write this 
distance between x obstacle minus 
delta, equal to 
but, im going to put squares in there 
im going to start taking 
derivative taking derivative 
square a norm is easy taking 
derivative a norm is so easy, 
im going to put half here 
reason getting rid 
coefficient this half doesnt change 
anything 
so i i g 
one side i g positive, 
means that youre away 
obstacle delta, means youre 
here youre going to use this 
behavior 
so we f coming in here, so this is 
going to f 
i g negative this 
side, is inside here, im 
going to use this behavior 
so thats going to equal to f 
so i everything i need to able to 
unleash induced mode piece 
mathematics 
so, f is goal to goal 
f is avoid obstacle 
now, we need to connect somehow 
induced mode 
well, here is connection 
we actually computed induced mode 
this convex combination two 
modes, two behaviors 
this convex combination given 
this, mouthful an expression 
lets actually try to compute this, 
in this case, to see what, 
induced mode 
well, first all, we need lee 
derivatives 
so, lfg, if you remember 
that dg, dxf 
we need thing f 
this lead derivative show, show 
repeatedly 
well, first derivative g 
respect to x is simply xx obstacle 
transpose this is reason i 
put squares here that made 
everything easy i put half there 
that hills an extra that would 
show 
this really doesnt makes 
math a little bit easier 
this is one things that i 
encourage you to try to compute 
yourselves, to make sure that you 
actually trust that this is indeed 
correct answer 
well, i compute unknown 
derivatives, right i lfg, well 
dgdx times f well gdx is 
computed that 
f is c avoid obstacle, xxo 
in previous lecture, i used k, 
prime index inaudible c here 
well, this is xxo transposed times xx 
thats xx squared, 
norm squared 
so this lead derivative a rather 
simple expression 
similarly, i compute lead 
derivative 
c, goal to goal times this 
thing, that we know is an inner 
product xx obstacle, transposed times 
x goal minus x 
so i lead derivatives that i 
actually need 
so, that, i could go ahead 
compute induced mode 
instance 
you know, this little thing here 
is that is lets see, 
xxo transpose times caoxxo, 
thats first term, minus c goal to 
goal times xgx 
so, thats that term 
we an explicit expression 
we also go ahead, compute this, 
right, instance 
cao, xx transposed times f 
is, f goal 
to goal times xg 
x 
so i compute this 
similarly, i compute that 
point is first that everything 
is entirely computable here 
point is, you know what, this 
is a little bit a mess 
a mess to write down, 
weve actually done is sound we 
recovered controller 
is sliding 
difference is if you write in 
this form, you automatically get alpha to 
pop you get certain 
scaling, you get plus 
minus flip 
so you actually get flip free, 
told direction to go 
alpha to go in nice thing is that 
flip direction you get computing 
induced mode is actually 
taking inner products u follow 
ball counterclockwise u avoid 
obstacle, if this inner 
u avoid obstacle 
if this inner product is positive, we go, 
counter clockwise, otherwise we go 
clockwise 
so, 
nice thing is, we actually ,in a 
mathematically rather involved way arrive 
expression 
difference that we 
plus minus automatically 
determined us, scaling 
factors automatically determined us 
in practice though, going to 
this, this is messy 
instead, going to pick 
alpha that we feel good 
i always pick alpha im lazy 
use inner product tasks to 
figure whether we go clockwise 
counterclockwise 
so, thats practically going 
to 
now, thats enough, so lets say that 
im going towards goal here 
here i want to go in this direction, 
avoid obstacle to take there, so 
sliding is immediately going to tell 
that im going to start moving like 
this 
well you know this good 
dandy, if im simply looking 
sliding rule 
here, a sudden im pointing 
in direction, sliding is going 
to tell to stop, so i need to 
is to keep following ball, 
verify im going to follow ball 
a long time way way way, 
around around around may 
here right time to stop following 
ball 
question that really need to answer 

we know that follow wall is 
right thing to do, we know 
direction to go in, we know, really 
to scale even though 
going to scale one 
really doesnt matter is we 
actually stop this sliding follow 
wall 
well, that turns to so easy 
in fact there multiple ways 
answering that this is precisely 
topic next lecture 
