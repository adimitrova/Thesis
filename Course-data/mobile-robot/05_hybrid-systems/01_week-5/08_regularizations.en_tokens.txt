so
last
time
we
saw
that
we
could
actually
test
for
type1
zeno
and
the
way
we
could
test
this
was
to
see
whether
or
not
the
gradient
dg
,
dx
transpose
points
in
the
same
direction
as
f2
,
in
the
opposite
direction
of
f1
.
so
if
i
have
that
,
then
i
do
have
type
1
zeno
.
and
we
came
up
with
a
little
probe
here
to
check
whether
or
not
,
this
is
indeed
happening
.
so
,
the
first
thing
we
do
is
we
check
lf1g
negative
,
and
lf
.
2
g
positive
.
where
lfg
was
this
thing
we
called
the
lead
derivative
.
which
was
simply
just
fancy
speak
for
dg
,
dx
times
,
in
this
case
,
f1
of
x.
that
's
all
it
means
.
so
this
is
the
probe
that
checks
whether
or
not
sliding
occurs
.
today
,
i
want
to
talk
about
what
's
called
regularizations
,
which
is
.
code
for
okay
,
let
's
say
we
have
that
,
we
have
sliding
,
how
do
we
compute
how
we
slide
?
and
it
turns
out
that
this
is
going
to
be
very
important
when
we
move
on
to
robotics
because
this
occurs
quite
a
bit
when
you
actually
start
running
robotic
navigation
systems
.
so
today
's
lecture
is
all
about
how
to
be
actually
slide
along
this
surface.well
,
lets
actually
try
to
be
a
little
careful
in
[
unknown
]
.
so
if
i
'm
sliding
here
,
what
is
characterizing
that
motion
well
,
i
know
that
g
(
x
)
=0
which
means
that
if
i
take
the
time
,
the
relative
of
g
,
we
respect
to
t
then
it
should
be
0
because
g
is
not
going
to
change
when
i
'm
sliding
because
i
'm
staying
at
g=0
.
so
one
thing
we
need
to
do
is
say
that
dg/dt=0
.
well
,
let
's
see
where
that
takes
us
,
dg/dt
it
is
equal
to
dgdx*xdot
.
so
now
what
is
x
dot
along
here
.
well
,
what
i
am
going
to
postulate
is
that
it
's
a
combination
of
f2
and
f1
.
in
fact
let
's
say
that
is
equal
to
sigma1*f1+sigma2+f2
.
so
it
's
a
convex
combination
of
,
of
these
two
vector
fields
.
so
if
i
do
that
,
i
get
instead
of
x
dots
,
i
get
this
thing
here
sigma
1
f1
plus
sigma
2
f2
.
well
,
since
these
are
scalars
,
i
can
actually
pull
them
out
here
,
which
means
that
i
can
write
this
expression
that
's
is
a
little
bit
messy
looking
like
sigma
1
times
the
lead
derivative
of
g
along
f1
plus
sigma
2
times
the
lead
derivative
of
g
along
f2
.
so
that
's
what
the
time
derivative
of
g
actually
is
.
but
i
want
that
to
be
equal
to
0.
this
needs
to
be
equal
to
0
because
that
was
our
condition
.
so
if
i
put
this
thing
equal
0
then
i
can
solve
for
instance
for
sigma
2
and
i
get
.
this
expression
right
here
.
so
i
know
how
Ã¯Â2
is
going
to
depend
on
Ã¯Â1
.
well
that
's
a
good
start
.
we
also
know
that
both
Ã¯Â
need
to
be
positive
because
i
'm
not
allowed
to
always
start
flowing
backwards
and
they
also
should
sum
up
to
1
because
otherwise
they
can
go
super
fast
along
this
direction
which
i
typically
do
n't
want
.
i
want
it
to
respect
the
dynamics
.
so
.
i
have
additional
constraint
too
.
so
the
sigma
needs
to
be
positive
and
they
need
to
sum
up
to
1.
well
.
let
's
see
how
we
can
actually
solve
it
.
so
,
let
's
go
back
to
our
old
friend
,
the
example
.
and
again
this
example
.
looks
like
this
,
where
,
you
know
what
?
i
'm
sliding
down
with
slope
-1.
here
's
x
and
here
's
time
.
and
when
i
hit
the
switching
surface
,
i
stay
with
x=0
for
the
duration
.
okay
,
what
is
the
switching
surface
,
first
of
all
?
well
,
it
's
x=0
,
so
g
(
x
)
is
simply
x=0
.
okay
,
let
's
compute
some
of
these
lee
derivatives
.
so
,
lf1g
.
it
's
,
it
's
the
derivative
of
g
,
with
respect
to
x.
so
,
the
derivative
of
that
with
respect
to
x
,
is
simply
1.
f1
is
simply
negative
1.
so
,
the
lee
derivative
is
negative
1.
which
is
1
of
the
things
we
needed
for
zeno
.
we
needed
,
or
for
sliding
.
we
needed
this
to
be
negative
for
,
type
1
zeno
to
occur
.
that
's
the
first
.
well
let
's
do
the
same
for
f
2.
sorry
this
is
an
f
2
right
here
,
apologize
about
that
.
l
f
2
g
well
it
's
a
dgdx
which
equals
the
derivative
of
that
with
respect
to
x
which
is
1
,
and
f
2
which
is
plus
1.
right
,
so
i
get
1*1
,
which
is
equal
to
1
,
which
is
positive
,
which
was
the
other
condition
for
having
type
1
zeno
.
so
we
know
that
we
actually
have
type
1
zeno
,
or
sliding
,
here
.
okay
.
so
now
,
let
's
try
figuring
out
what
what
the
the
sigmas
should
actually
be
.
well
,
we
had
a
formula
for
sigma
2..
it
is
equal
to
-sigma1
and
these
two
lee
derivatives
divided
by
eachother
.
well
,
this
was
-1
and
this
was
+1
so
sigma
2
is
simple
equal
to
sigma
1.
rather
simple
.
[
inaudible
]
.
but
what
,
what
are
they
?
well
,
recall
that
the
need
to
sum
up
to
1.
which
means
that
they
both
have
to
be
a
half
.
what
this
actually
means
,
then
,
is
that
we
can
compute
what
the
induced
mode
,
sliding
mode
,
actually
is
.
well
,
i
take
sigma
1
*
f1
,
which
is
half
of
f1
.
and
then
i
take
sigma2
times
f2
which
is
half
of
f2
,
well
f1
is
negative
one
and
f2
is
plus
one
so
i
get
-0.5
+
0.5
and
that
's
equal
to
0.
so
i
know
that
my
induced
mode
,
in
this
case
,
is
x
dot
=
0
,
which
is
exactly
what
we
wanted
.
because
remember
this
picture
that
we
've
drawn
over
and
over
again
.
we
want
to
start
here
,
get
down
there
,
and
then
keep
staying
at
0.
and
the
math
turns
out
to
work
out
,
in
this
case
.
now
,
let
's
find
the
induced
mode
in
general
.
i
know
that
the
general
formula
for
sigma2
and
i
,
i
want
to
point
out
that
this
is
not
a
formula
any
one
in
their
right
mind
should
memorize
,
but
we
should
know
where
it
comes
from
and
be
able
to
use
it
when
we
need
to
.
but
,
here
is
the
general
formula
for
the
,
for
the
induced
mode
.
well
,
we
also
have
that
sigma
1
plus
sigma
2
,
is
equals
to
1
,
which
means
that
i
can
take
sigma
2
here
,
and
plug
it
in
,
because
this
is
what
sigma
2
is
.
so
now
i
have
an
expression
on
sigma
1
so
if
i
solve
that
,
i
acutally
know
what
sigma
1
is
.
i
encourage
you
to
go
through
the
math
yourself
,
it
's
a
little
bit
of
a
mouth
full
,
but
what
its
,
what
it
tells
me
is
that
i
compute
sigma
1
,
and
i
can
compute
sigma
2
,
just
as
well
.
and
,
if
i
now
sum
all
of
this
up
together
,
i
get
this
expression
inside
the
pink
box
there
.
and
i
recognize
again
,
this
is
a
little
bit
of
a
mouthful
,
but
what
this
tells
me
is
exactly
what
the
induced
mode
is
.
so
i
am
going
to
put
a
sweet
heart
around
this
thing
,
not
because
it
's
particularly
pretty
but
because
it
's
systematic
and
it
tell
us
how
to
actually
find
the
sliding
mode
controller
or
the
induced
mode
which
means
that
we
know
exactly
,
not
only
when
type
1
zeno
occurs
.
but
how
to
progress
beyond
it
.
so
,
let
's
figure
it
out
.
if
i
have
,
this
is
my
hybrid
system
.
and
,
if
this
is
a
type
1
zeno
hybrid
automaton
.
how
do
i
regularize
it
?
what
do
i
do
to
add
this
extra
sliding
mode
?
well
,
this
is
what
i
do
.
now
,
let
's
parse
this
,
even
though
it
looks
a
little
bit
like
a
mouthful
,
let
's
figure
out
what
it
means
.
so
let
's
say
i
'm
here
,
g
is
positive
.
g
is
positive
and
all
is
,
all
is
well
.
then
,
if
g
becomes
0
and
the
sliding
condition
is
satisfied
.
then
i
move
in
to
what
we
just
computed
here
which
is
the
induce
mode
.
and
again
it
's
a
little
bit
of
a
mouth
full
but
we
will
see
later
on
that
in
robotics
we
have
no
choice
but
to
actually
use
this
.
so
then
i
'm
going
to
use
this
mode
until
if
g
becomes
positive
i
jump
back
to
f1
.
if
g
becomes
negative
i
jump
to
f2
.
and
of
course
we
do
n't
always
have
type
1
zeno
some
switches
are
nice
if
i
simply
end
up
g
negative
,
i
jump
directly
from
mode
1
to
mode
2
and
vice
versa
.
so
,
this
is
how
you
take
a
hybrid
system
and
make
it
immune
to
the
nauseous
and
bad
effects
of
type
1
zeno
.
and
the
nice
thing
is
that
this
is
completely
general
,
and
we
do
n't
ever
again
have
to
worry
about
zeno
.
type
1
zeno
,
type
2
zeno
we
already
said
them
about
.
having
said
that
this
actually
brings
me
to
the
summary
of
this
entire
model
and
hybrid
systems
.
so
,
what
do
we
have
,
we
have
models
,
we
have
very
rich
models
which
are
the
hybrid
[
unknown
]
models
.
we
have
something
what
we
call
stability
awareness
or
just
we
're
aware
of
the
fact
that
,
just
because
the
submodules
,
or
the
submodes
are
stable
themselves
does
n't
mean
that
the
hybrid
system
is
stable
.
and
we
need
to
be
aware
of
it
,
test
for
it
.
we
also
have
seen
zeno
as
another
awkward
hybridization
that
occurs
.
or
an
awkward
phenomenon
that
can
occur
when
you
go
hybrid
.
we
have
2
classes
of
zeno
.
1
,
which
is
type
2
,
which
is
the
bouncing
ball
.
infinitely
many
switch
,
many
switches
in
finite
,
but
not
,
not
zero
time
.
that
's
bad
and
scary
,
and
we
ca
n't
do
anything
about
it
except
,
look
out
for
it
.
but
then
,
we
have
type
1.
and
we
now
know
,
not
only
how
to
check
for
it
.
but
how
to
get
around
it
using
these
things
that
i
call
regularizations
or
the
induced
sliding
mode
and
with
that
if
i
had
,
you
know
a
confetti
,
i
would
toss
it
up
into
the
air
because
this
ends
the
massive
part
and
the
pre-robotics
part
really
of
this
course
.
so
what
we
're
going
to
do
in
the
next
module
is
go
back
to
robotics
.
apply
,
all
of
our
new
and
awesome
tools
,
and
see
,
how
we
can
unleash
them
to
actually
make
mobile
ro
,
robots
do
cool
things
in
the
real
world
.
well
done
.
