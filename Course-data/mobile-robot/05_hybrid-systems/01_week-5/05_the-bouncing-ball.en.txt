So welcome back. 
today, I would like to investigate a particular hybrid system that has to do 
with a bouncing ball. So, that is, I take a ball and I drop it 
on a surface and I would first of all, like to model it. 
And secondly, like to figure out how the ball behaves. 
And the reason why I want to do this is not necessarily because I really like 
balls but because this bouncing ball example holds the key to another little 
peculiarity of hybrid systems that we should be aware of. 
So, here is the set up. I have a ball. 
It's h above the ground. Now, what happens in between the bounces? 
Well, Newton tells me that force is mass times acceleration and, and the 
acceleration is, in fact, -g, where g is the gravitational constant. 
So, if I let x1=h and x2 be equal to h dot, which is what we always do, 
then what I get is that x dot is this thing, 0100 x, which is just the point 
mass, plus this gravitational force that's pulling it down. 
Now, let's say that the thing that I'm interested in also is, where the ball 
actually is, how high, how high up it is, so y is going to be 01 x. 
So, that is my model of the ball. What happens at the bounces? Well, you 
could try to model ball deformations and whatnot, but that seems rather 
complicated so what we're simply going to say is that these are what's called 
inelastic bouncers which mean, which means that a little bit of energies 
sucked out of the ball every time it bounces. 
And in fact, what we're going to say is that velocity, this is the velocity, so 
if the ball is coming down here [SOUND] hits the ground then the velocity 
instantaneously flips, it means, that's why we have a minus sign there because 
the ball instantaneously flips but we're also scaling it with this gamma constant, 
so we're making the velocity change direction from downwards to upwards, but 
a little bit less, which means we lost some energy in the bounce. 
Well, the position doesn't change in the bounce, so this means that my reset 
condition is going to be this. This is just encoding this fact that I'm 
flipping a little bit, I'm flipping my velocity, and I'm loosing a little bit of 
energy at the time of the bounce. Alright, so lets see what this bouncing 
ball hybrid automaton might look like. Well, x dot is Ax+b, in this case, not Bu 
and b is 0-g so this is this forcing term that is gravity, no big deal. 
Now, what's going to happen is I'm going to switch from that mode to itself when 
I'm bouncing. And we already saw that the reset 
condition is this inelastic bounce condition that says that we're losing a 
little bit of the velocity at the time of the bounce. 
So, that's the reset condition. Now, the guard condition is what? Well, 
clearly, we're bouncing when we're hitting the ground. 
So, we would like the height to be less than or equal to 0, right? 
Well, let's see what happens. Here comes the ball [SOUND] hits the 
ground, now the height is 0, we're switching and now the first thing we do 
is we reverse the velocity but, meaning, we're switching. 
But hey, wait a second, the height is still less than or equal to 0. 
The height is still 0. So, what we're going to do is we're just 
going to end up spinning like crazy if we have this guard. 
So, this is not a good guard. Let's get rid of it. 
Instead, what we need to do is we're, we're going to switch when we come down 
to the ground and the velocity is pointing downwards. 
Meaning that h needs to be negative or less than or equal 0. 
And h dot has to be less than or equal 0, meaning, we're facing downwards. 
Or since h and h dot constitute our state, then the guard should really 
simply be that x is less than or equal to 0. 
That's the guard condition. Well, it could be it's just a, the height 
is just 0, but this is really the condition that tells us that it's time 
to, to switch. Okay, good. So now, we have that. 
Is this any good? Well, I mean clearly, it's good. 
It's pretty and we have guards and resets. 
But does it model, first of all, faithfully what balls do when they 
bounce? And secondly, are there reasons why a model like this would cause us to 
be a little bit nervous? To answer that, we need to figure out what the ball is 
actually doing if we have this model. So, first of all, we have this system 
again now. What I would like to know is what is the 
output of this system. Well, fast forward, sorry, not forward, 
reverse two weeks and we go back to linear time-invariant systems. 
We know what the solution to this system is. 
We know that the output is C times this bad boy here, that we call the state 
transition matrix, which was fancy speak for this matrix exponential times the 
initial condition plus C times this rather awkward-looking integral there. 
Now, all of these is, is, is not particularly pleasant. 
And I remember vividly how we struggled to get through this because there were so 
many integrals to keep track of here. Now, in this particular case, we're a 
little bit lucky because this A matrix is what's called nilpotent because if I take 
A to the power two, or three, or any high there, higher exponential here, then I 
get 0 out. And that turns out to be quite wonderful 
for us. Why is that? Well, remember, that e^At is 
really this infinite sum. A, there should be a parentheses here, I 
apologize. 0 At to the power of k divided by k!. 
Well, in our case, all the higher order A's are equal to 0, so I get first k=0, 
which gives me the identity matrix. Then I get k=1, which simply gives me A 
times t. And then, I have all the others which are 
equal to 0. So, e^At, in this case, is simply this 
matrix. Here is the part that comes from the 
adjacent matrix and since A is simply that times t, I get the t up here. 
So, this is my e^At or my state transition matrix. 
So now, I should be able to plug this back into the equation for y and get a 
rather nice looking expression. So, let's do that. 
Well, here is C. Here is the state transition matrix. 
Here's my initial condition. Here's this rather awkward-looking 
differential equation sorry, integral. now, we can try to solve that. 
and if we do that, instead of actually doing the math, 
I did the math, I encourage you to go home and do that. 
I'm just going to write down what the solution is. 
It's going to be h0 times the initial velocity, 
h dot 0 of t-t0 and that's then minus g/2 t-t0 squared. 
So, this is what the output looks like in between bounces. 
Good. Now, that we have that, let's figure out 
how long it takes in between bounces. So, let's say that we start at zero o 
clock, at height zero. This is when the bounce is about to start 
and then, [SOUND] we want to know how long this, this took. 
We want to know how long it took us to get back the ground. 
Well, that's simple. Let's pick a big time, big T and say, 
well, y at that time t has to be equal to 0. 
Well, then we plug that in. h0=0 not so we don't any turn there we 
just get h dot 0 times T minus this thing. 
or another way of writing it is like this. 
And you know what, this needs to be equal to 0 because h is 0 there and h is 0 
there, which is why we have two solutions. 
So, one solution corresponds to T=0, which is at the beginning of the bounce. 
And the other solution is when we return down. 
So, this is how long it took me to go from the ground, up into the air, and 
then back down to the ground. This is the time in between bounces. 
Let's compute the accumulated bounce times, 
just because we find it amusing. Well, the velocity at the beginning, so 
at the first time, let's just say that the velocity is v, 
right? So then, the time of the first bounce, instead of h dot 0, I just plug 
in v there. I get 2v/g, that's the time of the first 
bounce. Well, the velocity after the first 
bounce, well, the reset condition says that I 
have gamma times v, so okay, I have a new v here. 
That's what I'm going to plug into my h dot 0 here that immediately tells me that 
the time of the second bounce is, well, it's the time of the first bounce plus 
the time it took for the second bounce and instead of v, I have v divided by 
gamma there. So, that's how long it took me to perform 
two bounces, and so forth. This tells me that the time of the nth 
bounce is given by this 2v/g which is this term that shows up over and over 
again. And then, every bounce gets this gamma to 
the power of k accumulated. Now, this is what's called a geometric 
series. And if you look that up or you happen to 
know it, if gamma is less than one, which means that you're not adding energy at 
the bounce times, this thing will actually, okay, and we 
have gamma less than one, this will actually converge in the sense 
that when n goes to infinity, this thing becomes equal to this expression. 
Well now, maybe some of you are asking, so what? [LAUGH] Well, you shouldn't be 
asking so what. Well, what's going on there? This is the 
time it takes to perform infinitely many bounces, 
infinitely many bounces, and this is less than infinity. 
What that means is this bouncing ball is going to go [SOUND] infinitely many. 
And there is some time t infinity here where this system is just going to grind 
to a halt and our model is just going to keep computing bounce after bounce after 
bounce after bounce faster and faster and faster. 
And this is actually a serious problem that causes our system to actually crash. 
So, the ball bounces in infinite numbers of times in finite time. 
And like I said, this is not just a mathematical curiosity that shows that we 
can compute geometric series. It means that if I'm simulating it, then 
my simulation would crash. In fact, I encourage you to write this 
exact model into your favorite simulator and watch it crash. 
This also means that if I write down my hybrid system like this, then it's 
undefined beyond T infinity because it's not clear what's happening beyond there. 
Time is not allowed to go to infinity. So, stability, which says what happens 
when T goes to infinity [SOUND] you can't even ask that question because t doesn't 
go to infinity. what's worse obviously is that real balls 
don't do this, real balls bounce and after awhile they lay still, right? 
So, this is also an indication that our model is not particularly good. 
And, in fact, this type of phenomenon where you have infinitely many switches 
in finite time is known as the Zeno Phenomenon, after the philosopher Zeno, 
that had the a tortoise race, a hare. And the paradox that Zeno came up with 
was the fact that the hare never managed to overtake the tortoise. 
And in the next lecture, we will see, first of all, why the tortoise is able to 
beat the hare and what to do about it, meaning how do you make the rabbit 
overtake the turtle? Well, that, my friends, is the topic of the next 
lecture.