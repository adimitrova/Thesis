So last time we saw that we could 
actually test for type1 zeno and the way we could test this was to see whether or 
not the gradient dg, dx transpose points in the same direction as f2, in the 
opposite direction of f1. So if I have that, then I do have type 1 
zeno. And we came up with a little probe here 
to check whether or not, this is indeed happening. 
So, the first thing we do is we check LF1G negative, and LF. 
2 G positive. Where LFG was this thing we called the 
lead derivative. Which was simply just fancy speak for DG, 
DX times, in this case, F1 of X. That's all it means. 
So this is the probe that checks whether or not sliding occurs. 
Today, I want to talk about what's called regularizations, which is. 
Code for okay, let's say we have that, we have sliding, how do we compute how we 
slide? And it turns out that this is going to be very important when we move 
on to robotics because this occurs quite a bit when you actually start running 
robotic navigation systems. So today's lecture is all about How to be 
actually slide along this surface.Well, lets actually try to be a little careful 
in [UNKNOWN]. So if I'm sliding here, what is 
characterizing that motion well, i know that g(x)=0 which means that if i take 
the time, the relative of g, we respect to t Then it should be 0 because g is not 
going to change when I'm sliding because I'm staying at g=0. 
So one thing we need to do is say that dg/dt=0. 
Well, let's see where that takes us, dg/dt It is equal to dgdx*xdot. 
So now what is x dot along here. Well, what I am going to postulate is 
that it's a combination of f2 and f1. In fact let's say that is equal to 
sigma1*f1+sigma2+f2. So it's a convex combination of, of these 
two Vector fields. So if I do that, I get instead of x dots, 
I get this thing here sigma 1 f1 plus sigma 2 f2. 
Well, since these are scalars, I can actually pull them out here, which means 
that I can write this expression that's is a little bit messy looking like sigma 
1 times the lead derivative of g along f1 plus sigma 2 times the lead derivative of 
g along f2. So that's what the time derivative of g 
actually is. But I want that to be equal to 0. 
This needs to be equal to 0 because that was our condition. 
So if I put this thing equal 0 then I can solve for instance for sigma 2 and I get. 
This expression right here. So I know how σ2 is going to depend on 
σ1. Well that's a good start. 
We also know that both σ need to be positive because I'm not allowed to 
always start flowing backwards and they also should sum up to 1 because otherwise 
they can go super fast along this direction which I typically don't want. 
I want it to respect the dynamics. So. 
I have additional constraint too. So the sigma needs to be positive and 
they need to sum up to 1. Well. 
let's see how we can actually solve it. So, let's go back to our old friend, the 
example. And again this example. 
Looks like this, where, you know what? I'm sliding down with slope -1. 
Here's x and here's time. And when I hit the switching surface, I 
stay with x=0 for the duration. Okay, what is the switching surface, 
first of all? Well, it's x=0, so g(x) is simply x=0. 
Okay, let's compute some of these Lee 
derivatives. So, lf1g. 
It's, it's the derivative of g, with respect to x. 
So, the derivative of that with respect to x, is simply 1. 
F1 is simply negative 1. So, the Lee derivative is negative 1. 
Which is 1 of the things we needed for zeno. 
We needed, or for sliding. We needed this to be negative for, type 1 
zeno to occur. That's the first. 
Well let's do the same for f 2. Sorry this is an f 2 right here, 
apologize about that. l f 2 g well it's a dgdx which equals the 
derivative of that with respect to x which is 1, and f 2 which is plus 1. 
Right, so I get 1*1, which is equal to 1, which is positive, which was the other 
condition for having Type 1 Zeno. So we know that we actually have Type 1 
Zeno, or sliding, here. okay. 
So now, let's try figuring out what what the The sigmas should actually be. 
Well, we had a formula for sigma 2.. It is equal to -sigma1 and these two Lee 
derivatives divided by eachother. Well, this was -1 and this was +1 so 
sigma 2 is simple equal to sigma 1. Rather simple. 
[INAUDIBLE]. But what, what are they? Well, recall 
that the need to sum up to 1. Which means that they both have to be a 
half. What this actually means, then, is that 
we can compute what the induced mode, sliding mode, actually is. 
Well, I take sigma 1 * f1, which is half of f1. 
And then i take sigma2 times F2 which is half of F2, well F1 is negative one and 
F2 is plus one so i get -0.5 + 0.5 and that's equal to 0. 
So I know that my induced mode, in this case, is x dot = 0, which is exactly what 
we wanted. because remember this picture that we've 
drawn over and over again. We want to start here, get down there, 
and then keep staying at 0. And the math turns out to work out, in 
this case. Now, let's find the induced mode in 
general. I know that the general formula for 
sigma2 and I, I want to point out that this is not a formula any one in their 
right mind should memorize, but we should know where it comes from and be able to 
use it when we need to. But, here is the general formula for the, 
for the induced mode. Well, we also have that sigma 1 plus 
sigma 2, is equals to 1, which means that I can take sigma 2 here, and plug it in, 
because this is what sigma 2 is. So now I have an expression on sigma 1 so 
if I solve that, I acutally know what sigma 1 is. 
I encourage you to go through the math yourself, it's a little bit of a mouth 
full, but what its, what it tells me is that I compute sigma 1, and I can compute 
sigma 2, just as well. And, if I now sum all of this up 
together, I get this expression inside the pink box there. 
And I recognize again, this is a little bit of a mouthful, but what this tells me 
is Exactly what the induced mode is. So I am going to put a sweet heart around 
this thing, not because it's particularly pretty but because it's systematic and it 
tell us how to actually find the sliding mode controller or the induced mode which 
means that we know Exactly, not only when type 1 zeno occurs. 
But how to progress beyond it. So, let's figure it out. 
If I have, this is my hybrid system. And, if this is a type 1 zeno hybrid 
automaton. How do I regularize it? What do I do to 
add this extra sliding mode? Well, this is what I do. 
Now, let's parse this, even though it looks a little bit like a mouthful, let's 
figure out what it means. So let's say I'm here, g is positive. 
G is positive and all is, all is well. Then, if g becomes 0 and the sliding 
condition is satisfied. Then I move in to what we just computed 
here which is the induce mode. And again it's a little bit of a mouth 
full but we will see later on that in robotics we have no choice but to 
actually use this. So then I'm going to use this mode until 
if g becomes positive I jump back to f1. If g becomes negative I jump to f2. 
And of course we don't always have Type 1 Zeno some switches are nice if I simply 
end up g negative, I jump directly from mode 1 to mode 2 and vice versa. 
So, this is how you take a hybrid system and make it immune to the Nauseous and 
bad effects of Type 1 Zeno. And the nice thing is that this is 
completely general, and we don't ever again have to worry about Zeno. 
Type 1 Zeno, Type 2 Zeno we already said them about. 
Having said that this actually brings me to the summary of this entire model and 
hybrid systems. So, what do we have, we have models, we 
have very rich models which are the hybrid [UNKNOWN] models. 
We have something what we call Stability Awareness or just We're aware of the fact 
that, just because the submodules, or the submodes are stable themselves doesn't 
mean that the hybrid system is stable. And we need to be aware of it, test for 
it. We also have seen zeno as another awkward 
hybridization that occurs. Or an awkward phenomenon that can occur 
when you go hybrid. we have 2 classes of zeno. 
1, which is type 2, which is the bouncing ball. 
Infinitely many switch, many switches in finite, but not, not zero time. 
That's bad and scary, and we can't do anything about it except, look out for 
it. But then, we have type 1. 
And we now know, not only how to check for it. 
But how to get around it using these things that I call regularizations or the 
induced sliding mode and with that if I had, you know a confetti, I would toss it 
up into the air because this ends the massive part and the pre-robotics part 
really of this course. So what we're going to do in the next 
module is go back to robotics. Apply, all of our new and awesome tools, 
and see, how we can unleash them to actually make mobile ro, robots do cool 
things in the real world. Well done.