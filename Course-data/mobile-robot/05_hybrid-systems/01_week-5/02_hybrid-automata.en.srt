1
00:00:00,012 --> 00:00:04,133
So in the previous lecture, we saw that 
switches show up very naturally, 

2
00:00:04,133 --> 00:00:08,459
especially in robotics where we're going 
to switch between different modes of 

3
00:00:08,459 --> 00:00:11,077
operation. 
And what I want to do today is talk a 

4
00:00:11,077 --> 00:00:15,539
little bit about the models that we're 
going to use to describe these phenomena. 

5
00:00:15,539 --> 00:00:19,072
And the models that we're going to use 
are called Hybrid Automata. 

6
00:00:19,072 --> 00:00:22,812
And these are models that contain both 
the continuous dynamics. 

7
00:00:22,812 --> 00:00:27,589
Meaning to x dot part and the discrete 
switching logic that says oh, if you see 

8
00:00:27,589 --> 00:00:32,309
an obstacle you should switch to an 
obstacle avoidance behavior, or something 

9
00:00:32,309 --> 00:00:35,694
like that. 
Now, what this means is that the discrete 

10
00:00:35,694 --> 00:00:40,371
logic will be modeled as a finite state 
machine that moves between different 

11
00:00:40,371 --> 00:00:43,316
discrete states, so that's the discrete 
logic. 

12
00:00:43,316 --> 00:00:48,179
But just a finite state machine on static 
steroids in the sense that inside each 

13
00:00:48,179 --> 00:00:51,342
state we have a continuous dynamics 
loraking so. 

14
00:00:51,342 --> 00:00:56,112
Having said that, what we need first of 
all is the notion of a state. 

15
00:00:56,112 --> 00:01:00,017
So x, as before, is the continuous state 
of the system. 

16
00:01:00,017 --> 00:01:04,371
This is the physical state typically of 
what a robot is doing. 

17
00:01:04,371 --> 00:01:09,407
But then what we're going to do is we're 
going to add a discrete state that I'm 

18
00:01:09,407 --> 00:01:13,025
going to call q. 
And q is going to tell me which different 

19
00:01:13,025 --> 00:01:17,817
continuous mode I am in. 
So my dynamics now can be encoded not As 

20
00:01:17,817 --> 00:01:25,527
xdot=f(x,u) but xdot=fsubq(x,u). 
Where this q now tells me which mode am I 

21
00:01:25,527 --> 00:01:30,422
actually in. 
And what we're going to do is transition 

22
00:01:30,422 --> 00:01:37,677
between different discrete modes in a 
state machine where here I'm having mode 

23
00:01:37,677 --> 00:01:41,172
q. 
So really, xdot inside that mode. 

24
00:01:41,172 --> 00:01:46,004
Is going to, be fsubq and xdot inside 
this mode is going to be xdot is, fsubq 

25
00:01:46,004 --> 00:01:49,247
prime. 
Now, these are called transitions right, 

26
00:01:49,247 --> 00:01:54,438
so when you jump in between different 
discrete modes you're making transitions 

27
00:01:54,438 --> 00:01:58,021
between different states in the finite 
state machine. 

28
00:01:58,021 --> 00:02:03,319
Now what we need to understand is, when 
do we actually make these Jumps, well for 

29
00:02:03,319 --> 00:02:07,386
that we need something called a guard and 
the guard is something that checks 

30
00:02:07,386 --> 00:02:11,351
whether or not you should jump. 
And then we're also, [COUGH], excuse me, 

31
00:02:11,351 --> 00:02:15,443
also going to add something else which is 
called a reset which is going to tell you 

32
00:02:15,443 --> 00:02:19,242
not when you jump but where you end up 
after you made the transition. 

33
00:02:19,242 --> 00:02:25,619
So the guard condition is a condition 
that tells you when it is time to jump. 

34
00:02:25,619 --> 00:02:30,990
So let's say that I am in mode q and I 
want to jump to mode q prime. 

35
00:02:30,990 --> 00:02:35,382
Well, what I have, is I have a guard that 
says, if. 

36
00:02:35,382 --> 00:02:41,087
x belongs to this guard, let's say that 
this is, I'm going to switch from one 

37
00:02:41,087 --> 00:02:46,616
gear to another gear if my rpm is above 
3,000 then I'm going to switch. 

38
00:02:46,616 --> 00:02:51,507
This is a guard condition that encodes 
when it is time to jump. 

39
00:02:51,507 --> 00:02:55,963
Now, when I'm jumping I may actually 
reset the value of my state. 

40
00:02:55,963 --> 00:03:01,468
For instance, if I'm dropping a ball, 
whoop, onto this desk, and it bounces up, 

41
00:03:01,468 --> 00:03:07,052
it loses energy in, in the bounce so what 
we're doing is we're subtracting a piece 

42
00:03:07,052 --> 00:03:09,838
away from the state. 
At each bounce. 

43
00:03:09,838 --> 00:03:15,732
This way of messing with the state at the 
moment the transitions occur is called a 

44
00:03:15,732 --> 00:03:17,597
reset. 
So, if I am going, I'm here in mode q. 

45
00:03:19,034 --> 00:03:22,696
[SOUND]. 
And then my guard is true, so I am moving 

46
00:03:22,696 --> 00:03:26,276
to q prime. 
Well, what's happening here is that x 

47
00:03:26,276 --> 00:03:30,392
changes for instance, x is now lets say, 
the old x/5. 

48
00:03:30,392 --> 00:03:35,124
That would be a guard that says, oh I'm 
getting only a fifth of the energy 

49
00:03:35,124 --> 00:03:39,562
somehow after this jump. 
So, what we need are dynamics, individual 

50
00:03:39,562 --> 00:03:44,438
dynamics which are called modes. 
We need transitions which tell us, tells 

51
00:03:44,438 --> 00:03:48,023
us which discrete states are we moving in 
between. 

52
00:03:48,023 --> 00:03:53,571
We need guards which tell us When we're 
going to make these jumps and we're, need 

53
00:03:53,571 --> 00:03:58,133
resets to tell us how these jumps end up 
effecting the state. 

54
00:03:58,133 --> 00:04:03,822
So if we put all of this together, we get 
a rather arguably messy looking thing. 

55
00:04:03,822 --> 00:04:07,342
But it's very rich. 
This is the hybrid automaton. 

56
00:04:07,342 --> 00:04:12,656
Singular, or hybrid automata, plural 
model. And the way this works is, let's 

57
00:04:12,656 --> 00:04:18,039
see here, we start with x equal to x not, 
we end up in this mode, which is q=1, 

58
00:04:18,039 --> 00:04:22,501
where we are evolving according to this 
differential equation. 

59
00:04:22,501 --> 00:04:28,171
Right? Okay, if in this case, x belongs 
to G12, then x, we're going to move, over 

60
00:04:28,171 --> 00:04:32,718
into this mode. And on our way. 
We're going to reset the state. 

61
00:04:32,718 --> 00:04:35,933
Now the state is here. 
This is my dynamics. 

62
00:04:35,933 --> 00:04:40,113
I'm in q2 mode. 
Well if, G21 becomes true, I jump this 

63
00:04:40,113 --> 00:04:43,546
way. 
But if G23 becomes true, I jump that way. 

64
00:04:43,546 --> 00:04:46,954
So let's say G23 became true, I jump this 
way. 

65
00:04:46,954 --> 00:04:51,202
I change my state, possibly according to 
this reset map. 

66
00:04:51,202 --> 00:04:57,209
I have a third dynamics, q=3. 
And then when x enters G31 guard, it 

67
00:04:57,209 --> 00:05:00,342
jumps back into q=1, with a new possible 
reset. 

68
00:05:00,342 --> 00:05:04,123
So this is the general model that we're 
going to work with. 

69
00:05:04,123 --> 00:05:08,242
Now, it looks a little bit messy, but 
it's actually really not. 

70
00:05:08,242 --> 00:05:12,408
In most cases, these models are going to 
look rather, innocent. 

71
00:05:12,408 --> 00:05:16,171
So, here's for example, a very very 
simple Hybrid system. 

72
00:05:16,171 --> 00:05:19,131
it's a thermostat, or it's my idea of a 
thermostat. 

73
00:05:19,131 --> 00:05:23,152
Typically, the way a thermostat works, at 
least cheap ones, is you set some 

74
00:05:23,152 --> 00:05:26,833
temperature you would like. 
The thermostat is on the heater is on 

75
00:05:26,833 --> 00:05:30,771
until you reach that temperature, or 
typically, go a little bit above it. 

76
00:05:30,771 --> 00:05:35,149
And then, it turns off, and then you cool 
down, and then, when you're too low, you 

77
00:05:35,149 --> 00:05:37,582
turn it on again. 
And you've heard this all. 

78
00:05:37,582 --> 00:05:41,682
In buildings with, with heaters, or that 
turn on and off. 

79
00:05:41,682 --> 00:05:46,917
So, what we're doing is, we're heating it 
up until we're comfortable and warm. 

80
00:05:46,917 --> 00:05:51,633
And in fact, this is my desired 
temperature and you typically want to add 

81
00:05:51,633 --> 00:05:56,597
a little slack that says that I'm going 
to, shut this thing off when I'm at, 

82
00:05:56,597 --> 00:06:01,104
whatever I want to be 70 degrees. 
Plus a little slack, let's say. 

83
00:06:01,104 --> 00:06:04,049
By the way, this is 70 degrees 
Fahrenheit. 

84
00:06:04,049 --> 00:06:07,941
For you Celsius people out there, let's 
say it's 20. 

85
00:06:07,941 --> 00:06:12,882
so now, we're above 20 Celsius, and now 
we're going to cool it down. 

86
00:06:12,882 --> 00:06:17,182
And then we're cooling it down until 
we're,in this case, below, well, 20 

87
00:06:17,182 --> 00:06:20,822
degrees Celsius, or whatever it is in 
Fahrenheit, - epsilon. 

88
00:06:20,822 --> 00:06:23,347
And the reason why we need this epsilon 
is. 

89
00:06:23,347 --> 00:06:26,052
If we didn't have it, then this guard is 
true. 

90
00:06:26,052 --> 00:06:30,557
And this is guard is immediately true. 
'Cuz if t is = to t desired, we're just 

91
00:06:30,557 --> 00:06:33,397
going to start spinning around 
indefinitely here. 

92
00:06:33,397 --> 00:06:37,462
So, the little epsilons are important. 
So, this would be 1 way. 

93
00:06:37,462 --> 00:06:41,599
In which we will model a thermostat. 
There are no resets here just current 

94
00:06:41,599 --> 00:06:45,876
conditions because we're not magically 
making the temperature jump just because 

95
00:06:45,876 --> 00:06:48,471
we're changing the heaters from, from on 
to off. 

96
00:06:48,471 --> 00:06:52,271
Well, here's a gear shifter, right Well, 
we have some dynamics. 

97
00:06:52,271 --> 00:06:55,459
v is the velocity of the car. 
We're now in first gear. 

98
00:06:55,459 --> 00:06:58,977
This is our dynamics. 
u is our smashing the break of the gas 

99
00:06:58,977 --> 00:07:01,496
pedal down. 
So this is how we are driving. 

100
00:07:01,496 --> 00:07:05,253
When we have the RPM above some threshold 
then we change gears. 

101
00:07:05,253 --> 00:07:08,193
We switch up to second gear which is 
here, right. 

102
00:07:08,193 --> 00:07:12,132
So now we are having the second gear. 
If we keep pressing the gas. 

103
00:07:12,132 --> 00:07:16,699
So that the RPM goes up beyond, beyond 
some c2, then we switch to third gear. 

104
00:07:16,699 --> 00:07:21,646
Apparently this car only has three gears. 
but, we go to the third gear, and the 

105
00:07:21,646 --> 00:07:26,072
same thing here with a downshift. 
And note this here that I have c2 prime 

106
00:07:26,072 --> 00:07:28,132
and c1 prime. 
And c1 and c2 here. 

107
00:07:28,132 --> 00:07:31,818
This is again, because you want to build 
in a little bit of slack. 

108
00:07:31,818 --> 00:07:35,826
This is my way of hiding an epsilon 
inside there so we don't immediately 

109
00:07:35,826 --> 00:07:39,536
transition between, between gears. 
So this would be a hybrid atomaton gear 

110
00:07:39,536 --> 00:07:42,328
shifter. 
And I'm not writing out these dynamics. 

111
00:07:42,328 --> 00:07:45,591
Because the particulars aren't that 
important right now. 

112
00:07:45,591 --> 00:07:49,922
The important thing is, the switching 
logic and the way the guards operate. 

113
00:07:49,922 --> 00:07:53,882
Well finally, let's look at the 
behavior-based robotics system. 

114
00:07:53,882 --> 00:07:58,645
What I'm doing is I'm running the robot. 
So let's say at x is the position of the 

115
00:07:58,645 --> 00:08:01,240
robot. 
According to a go to goal behavior. 

116
00:08:01,240 --> 00:08:04,454
So f go to goal of x. 
This is me having to assign that. 

117
00:08:04,454 --> 00:08:09,385
When the distance between where I am and 
where the closest obstacle is when that's 

118
00:08:09,385 --> 00:08:13,989
less than some sum d, meaning I'm too 
close to an obstacle, then I'm going to 

119
00:08:13,989 --> 00:08:18,422
switch to another mode or another 
behavior which is Avoid obstacles. 

120
00:08:18,422 --> 00:08:22,829
So now I have decide my avoid obstacle 
behavior and it's safely taking me away 

121
00:08:22,829 --> 00:08:27,211
from the obstacle and then when the 
position of the robot is greater than 

122
00:08:27,211 --> 00:08:31,807
some other distance, the prime away from 
the obstacle then I switched to goal to 

123
00:08:31,807 --> 00:08:33,960
goal again. 
And the way this would look is, let's say 

124
00:08:33,960 --> 00:08:37,062
here's the obstacle. 
Here's the goal. 

125
00:08:37,062 --> 00:08:38,657
Here's my robot. 
[SOUND]. 

126
00:08:38,657 --> 00:08:41,922
My robot is doing fine. 
Here's the ball of radius d. 

127
00:08:41,922 --> 00:08:45,892
Once I get in here, I'm going to switch 
to a goal to goal behavior. 

128
00:08:45,892 --> 00:08:48,497
That's going to take me away from the 
robot. 

129
00:08:48,497 --> 00:08:53,052
Let's say here is a larger circle of 
radius d prime and when I'm here, I'm 

130
00:08:53,052 --> 00:08:56,807
going to be safe and I'm going to switch 
to goal to goal behavior. 

131
00:08:56,807 --> 00:09:01,547
So this is what would happen in practice 
if you ran this hybrid atomaton as a 

132
00:09:01,547 --> 00:09:06,957
behavior based robotic system. 
Now, unfortunately, things aren't all 

133
00:09:06,957 --> 00:09:11,787
rosy in the hybrid world. 
And what we'll see in the next lecture is 

134
00:09:11,787 --> 00:09:17,347
that things may actually go wrong even 
the we are meaning very well when we 

135
00:09:17,347 --> 00:09:22,457
start building our systems. 
So the next lecture is a Danger:Beware 

136
00:09:22,457 --> 00:09:27,884
sign that we need to put up whenever we 
are designing hybrid systems, as opposed 

137
00:09:27,884 --> 00:09:31,315
to standard standalone linear time and 
variant systems. 