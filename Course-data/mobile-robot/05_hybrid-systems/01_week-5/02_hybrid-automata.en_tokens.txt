so
in
the
previous
lecture
,
we
saw
that
switches
show
up
very
naturally
,
especially
in
robotics
where
we
're
going
to
switch
between
different
modes
of
operation
.
and
what
i
want
to
do
today
is
talk
a
little
bit
about
the
models
that
we
're
going
to
use
to
describe
these
phenomena
.
and
the
models
that
we
're
going
to
use
are
called
hybrid
automata
.
and
these
are
models
that
contain
both
the
continuous
dynamics
.
meaning
to
x
dot
part
and
the
discrete
switching
logic
that
says
oh
,
if
you
see
an
obstacle
you
should
switch
to
an
obstacle
avoidance
behavior
,
or
something
like
that
.
now
,
what
this
means
is
that
the
discrete
logic
will
be
modeled
as
a
finite
state
machine
that
moves
between
different
discrete
states
,
so
that
's
the
discrete
logic
.
but
just
a
finite
state
machine
on
static
steroids
in
the
sense
that
inside
each
state
we
have
a
continuous
dynamics
loraking
so
.
having
said
that
,
what
we
need
first
of
all
is
the
notion
of
a
state
.
so
x
,
as
before
,
is
the
continuous
state
of
the
system
.
this
is
the
physical
state
typically
of
what
a
robot
is
doing
.
but
then
what
we
're
going
to
do
is
we
're
going
to
add
a
discrete
state
that
i
'm
going
to
call
q.
and
q
is
going
to
tell
me
which
different
continuous
mode
i
am
in
.
so
my
dynamics
now
can
be
encoded
not
as
xdot=f
(
x
,
u
)
but
xdot=fsubq
(
x
,
u
)
.
where
this
q
now
tells
me
which
mode
am
i
actually
in
.
and
what
we
're
going
to
do
is
transition
between
different
discrete
modes
in
a
state
machine
where
here
i
'm
having
mode
q.
so
really
,
xdot
inside
that
mode
.
is
going
to
,
be
fsubq
and
xdot
inside
this
mode
is
going
to
be
xdot
is
,
fsubq
prime
.
now
,
these
are
called
transitions
right
,
so
when
you
jump
in
between
different
discrete
modes
you
're
making
transitions
between
different
states
in
the
finite
state
machine
.
now
what
we
need
to
understand
is
,
when
do
we
actually
make
these
jumps
,
well
for
that
we
need
something
called
a
guard
and
the
guard
is
something
that
checks
whether
or
not
you
should
jump
.
and
then
we
're
also
,
[
cough
]
,
excuse
me
,
also
going
to
add
something
else
which
is
called
a
reset
which
is
going
to
tell
you
not
when
you
jump
but
where
you
end
up
after
you
made
the
transition
.
so
the
guard
condition
is
a
condition
that
tells
you
when
it
is
time
to
jump
.
so
let
's
say
that
i
am
in
mode
q
and
i
want
to
jump
to
mode
q
prime
.
well
,
what
i
have
,
is
i
have
a
guard
that
says
,
if
.
x
belongs
to
this
guard
,
let
's
say
that
this
is
,
i
'm
going
to
switch
from
one
gear
to
another
gear
if
my
rpm
is
above
3,000
then
i
'm
going
to
switch
.
this
is
a
guard
condition
that
encodes
when
it
is
time
to
jump
.
now
,
when
i
'm
jumping
i
may
actually
reset
the
value
of
my
state
.
for
instance
,
if
i
'm
dropping
a
ball
,
whoop
,
onto
this
desk
,
and
it
bounces
up
,
it
loses
energy
in
,
in
the
bounce
so
what
we
're
doing
is
we
're
subtracting
a
piece
away
from
the
state
.
at
each
bounce
.
this
way
of
messing
with
the
state
at
the
moment
the
transitions
occur
is
called
a
reset
.
so
,
if
i
am
going
,
i
'm
here
in
mode
q
.
[
sound
]
.
and
then
my
guard
is
true
,
so
i
am
moving
to
q
prime
.
well
,
what
's
happening
here
is
that
x
changes
for
instance
,
x
is
now
lets
say
,
the
old
x/5
.
that
would
be
a
guard
that
says
,
oh
i
'm
getting
only
a
fifth
of
the
energy
somehow
after
this
jump
.
so
,
what
we
need
are
dynamics
,
individual
dynamics
which
are
called
modes
.
we
need
transitions
which
tell
us
,
tells
us
which
discrete
states
are
we
moving
in
between
.
we
need
guards
which
tell
us
when
we
're
going
to
make
these
jumps
and
we
're
,
need
resets
to
tell
us
how
these
jumps
end
up
effecting
the
state
.
so
if
we
put
all
of
this
together
,
we
get
a
rather
arguably
messy
looking
thing
.
but
it
's
very
rich
.
this
is
the
hybrid
automaton
.
singular
,
or
hybrid
automata
,
plural
model
.
and
the
way
this
works
is
,
let
's
see
here
,
we
start
with
x
equal
to
x
not
,
we
end
up
in
this
mode
,
which
is
q=1
,
where
we
are
evolving
according
to
this
differential
equation
.
right
?
okay
,
if
in
this
case
,
x
belongs
to
g12
,
then
x
,
we
're
going
to
move
,
over
into
this
mode
.
and
on
our
way
.
we
're
going
to
reset
the
state
.
now
the
state
is
here
.
this
is
my
dynamics
.
i
'm
in
q2
mode
.
well
if
,
g21
becomes
true
,
i
jump
this
way
.
but
if
g23
becomes
true
,
i
jump
that
way
.
so
let
's
say
g23
became
true
,
i
jump
this
way
.
i
change
my
state
,
possibly
according
to
this
reset
map
.
i
have
a
third
dynamics
,
q=3
.
and
then
when
x
enters
g31
guard
,
it
jumps
back
into
q=1
,
with
a
new
possible
reset
.
so
this
is
the
general
model
that
we
're
going
to
work
with
.
now
,
it
looks
a
little
bit
messy
,
but
it
's
actually
really
not
.
in
most
cases
,
these
models
are
going
to
look
rather
,
innocent
.
so
,
here
's
for
example
,
a
very
very
simple
hybrid
system
.
it
's
a
thermostat
,
or
it
's
my
idea
of
a
thermostat
.
typically
,
the
way
a
thermostat
works
,
at
least
cheap
ones
,
is
you
set
some
temperature
you
would
like
.
the
thermostat
is
on
the
heater
is
on
until
you
reach
that
temperature
,
or
typically
,
go
a
little
bit
above
it
.
and
then
,
it
turns
off
,
and
then
you
cool
down
,
and
then
,
when
you
're
too
low
,
you
turn
it
on
again
.
and
you
've
heard
this
all
.
in
buildings
with
,
with
heaters
,
or
that
turn
on
and
off
.
so
,
what
we
're
doing
is
,
we
're
heating
it
up
until
we
're
comfortable
and
warm
.
and
in
fact
,
this
is
my
desired
temperature
and
you
typically
want
to
add
a
little
slack
that
says
that
i
'm
going
to
,
shut
this
thing
off
when
i
'm
at
,
whatever
i
want
to
be
70
degrees
.
plus
a
little
slack
,
let
's
say
.
by
the
way
,
this
is
70
degrees
fahrenheit
.
for
you
celsius
people
out
there
,
let
's
say
it
's
20.
so
now
,
we
're
above
20
celsius
,
and
now
we
're
going
to
cool
it
down
.
and
then
we
're
cooling
it
down
until
we
're
,
in
this
case
,
below
,
well
,
20
degrees
celsius
,
or
whatever
it
is
in
fahrenheit
,
-
epsilon
.
and
the
reason
why
we
need
this
epsilon
is
.
if
we
did
n't
have
it
,
then
this
guard
is
true
.
and
this
is
guard
is
immediately
true
.
'cuz
if
t
is
=
to
t
desired
,
we
're
just
going
to
start
spinning
around
indefinitely
here
.
so
,
the
little
epsilons
are
important
.
so
,
this
would
be
1
way
.
in
which
we
will
model
a
thermostat
.
there
are
no
resets
here
just
current
conditions
because
we
're
not
magically
making
the
temperature
jump
just
because
we
're
changing
the
heaters
from
,
from
on
to
off
.
well
,
here
's
a
gear
shifter
,
right
well
,
we
have
some
dynamics
.
v
is
the
velocity
of
the
car
.
we
're
now
in
first
gear
.
this
is
our
dynamics
.
u
is
our
smashing
the
break
of
the
gas
pedal
down
.
so
this
is
how
we
are
driving
.
when
we
have
the
rpm
above
some
threshold
then
we
change
gears
.
we
switch
up
to
second
gear
which
is
here
,
right
.
so
now
we
are
having
the
second
gear
.
if
we
keep
pressing
the
gas
.
so
that
the
rpm
goes
up
beyond
,
beyond
some
c2
,
then
we
switch
to
third
gear
.
apparently
this
car
only
has
three
gears
.
but
,
we
go
to
the
third
gear
,
and
the
same
thing
here
with
a
downshift
.
and
note
this
here
that
i
have
c2
prime
and
c1
prime
.
and
c1
and
c2
here
.
this
is
again
,
because
you
want
to
build
in
a
little
bit
of
slack
.
this
is
my
way
of
hiding
an
epsilon
inside
there
so
we
do
n't
immediately
transition
between
,
between
gears
.
so
this
would
be
a
hybrid
atomaton
gear
shifter
.
and
i
'm
not
writing
out
these
dynamics
.
because
the
particulars
are
n't
that
important
right
now
.
the
important
thing
is
,
the
switching
logic
and
the
way
the
guards
operate
.
well
finally
,
let
's
look
at
the
behavior-based
robotics
system
.
what
i
'm
doing
is
i
'm
running
the
robot
.
so
let
's
say
at
x
is
the
position
of
the
robot
.
according
to
a
go
to
goal
behavior
.
so
f
go
to
goal
of
x.
this
is
me
having
to
assign
that
.
when
the
distance
between
where
i
am
and
where
the
closest
obstacle
is
when
that
's
less
than
some
sum
d
,
meaning
i
'm
too
close
to
an
obstacle
,
then
i
'm
going
to
switch
to
another
mode
or
another
behavior
which
is
avoid
obstacles
.
so
now
i
have
decide
my
avoid
obstacle
behavior
and
it
's
safely
taking
me
away
from
the
obstacle
and
then
when
the
position
of
the
robot
is
greater
than
some
other
distance
,
the
prime
away
from
the
obstacle
then
i
switched
to
goal
to
goal
again
.
and
the
way
this
would
look
is
,
let
's
say
here
's
the
obstacle
.
here
's
the
goal
.
here
's
my
robot
.
[
sound
]
.
my
robot
is
doing
fine
.
here
's
the
ball
of
radius
d.
once
i
get
in
here
,
i
'm
going
to
switch
to
a
goal
to
goal
behavior
.
that
's
going
to
take
me
away
from
the
robot
.
let
's
say
here
is
a
larger
circle
of
radius
d
prime
and
when
i
'm
here
,
i
'm
going
to
be
safe
and
i
'm
going
to
switch
to
goal
to
goal
behavior
.
so
this
is
what
would
happen
in
practice
if
you
ran
this
hybrid
atomaton
as
a
behavior
based
robotic
system
.
now
,
unfortunately
,
things
are
n't
all
rosy
in
the
hybrid
world
.
and
what
we
'll
see
in
the
next
lecture
is
that
things
may
actually
go
wrong
even
the
we
are
meaning
very
well
when
we
start
building
our
systems
.
so
the
next
lecture
is
a
danger
:
beware
sign
that
we
need
to
put
up
whenever
we
are
designing
hybrid
systems
,
as
opposed
to
standard
standalone
linear
time
and
variant
systems
.
