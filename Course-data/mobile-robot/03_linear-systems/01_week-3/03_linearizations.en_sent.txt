in this lecture, we're going to, dig a little bit deeper into the original non linear models.
and see, how do we produce linear models from them?
and in fact, i have a wonderful quote here.
that says, classifying systems as linear and non linear is like classifying objects in the universe.
as bananas and non-bananas.
what this means is that if you're walking around in the universe, let's say your'e on jupiter and you pick up something, chances are it ain't going to be a banana.
similarly, if you walk around and you pick up a system or a robot, chances are it ain't going to be linear.
what that means is that linear systems are really, really rare.
yet, here i am, two lectures ago, bragging about how useful they are.
so something's gotta give here.
and what it is, is that the non linear systems that are everywhere.
they act very much linear, at least around operating points.
so the linearization is a way of producing linear models from non linear models.
or producing bananas from non-bananas, if you want.
so what we're going to do in this lecture is.
produce linearizations or linear models from the non-linear models that we start with.
so, here is a general non-linear model .
so, x dot is now not a x plus bu with some general function f of x and u, and similarly y is not a simple plus in cx, it's a non-linear function h of x. okay.
so now, what we would like to do, is we would like to find some kind of local description of what this system is doing.
and this local description needs to be linear, and what i mean by local, is that we have to pick an operating point.
in the pendulum we said, let's assume that the pendulum is hanging very close to straight down, so straight down is the operating point and then what we do is we are going to have to define a new variable.
so, let's say that this is my operating point.
this in the pendulum case would be, the angle is zero, and i have no control input.
well then, my actual state is going to be the operating point, plus some small deviation in this state.
similarly my control input is going to be, well the nominal operating input point plus a small deviation.
and, what we would like to do somehow is describe these small variations.
and in fact, the new equations of motion that we care about well, we're going to care about how delta x. this deviation from the operating point behaves.
well, delta x is x minus x operating point.
right?
so delta x dot is x dot minus xl dot.
well, this thing is equal to zero, because it's a constant, right?
so this is just zero.
so, here's my zero.
so, delta x dot is the same.
as x dot.
well, i know what x dot is, it's this.
so, now delta x dot becomes this.
okay, let's see if we somehow can simplify this.
so this is my model, now luckily for me there's is something known as a tail or expansion that's allows me to write this on a simpler form.
so this thing can be written as f evaluated at the operating point, times this partial derivative of f with respect to x, also evaluated at the operating point, this is known as .
and then, you have the same partial derivative, but now with respect to u, evaluated at the operating points.
and, we multiply this with delta u here, and delta x here.
and then i have something that i call hot, which stands for higher order terms.
so this is where, we're saying that the higher order terms.
where, when delta x and delta u become large, these matter.
but for small delta x and delta u, they really don't matter.
well why is this useful?
well, first of all lets assume that we have picked operating points, so that f of x0, u0 is zero which that we're holding the state steady, x dot is zero at this point which means that this thing goes away.
now.
let's call these guys a and b. why is that?
well, these are just matrices because i'm plugging in some constant value here.
similarly then i'm plugging in a constant value.
so, these partial derivatives are just matrices.
well, let's call them a and b. and now let's do the same thing with y. y was the output.
we want to kn ow what it looks like around this operating point.
well, we have the same thing here, plus this term, plus high order terms.
so, let's assume that thing is zero, so let's assume that we pick an operating point that kills the output at that operating point.
so, the output is zero at that point.
well, then, let's call this thing c. right?
now i have a, b, and c. and in fact, let's summarize what we just did.
if i have this non-liner model, and i pick an operating point, so that these two assumptions are satisfied.
and then i look at small deviations from the operating point.
then i can write delta x dot.
that's a delta x plus b delta u. which is linear.
and y is c delta x, where these a, b, and c matrices are given by these partial derivatives, also known as jacobians.
so this, ladies and gentlemen, is how you obtain linear models from non linear systems.
well, let's actually do some computations here, just to know what's going on.
so let's assume that x is in rm.
u is an rm, y is an rp and we have f and a being given by these things, but really what we have is f1 over x or is actually a function of x1 to xn of u1 to up right, no sorry alright.
so when i just write f1, that's what's a really mean.
okay.
then, df, dx.
this jacobian that we talked about.
the first one we need.
well, it has this form.
first component is the derivative of f1, with respect to x1.
then it's f1 with respect to x2, and so forth.
and the reason why i'm writing this is not because i enjoy producing complicated powerpoint slides.
it's just, we need to know what the different entries are.
and it's important to do this right because otherwise your dimensions don't line up when you produce your a, b, and c matrices.
so that's df dx or, as we now know it, a. this is my a matrix.
well, similarly, b is df du, right?
and again, the first component is df1 du1.
this component is the f1, the here, we have the f and the u1.
all the way to the f and the so this is a n by m matrix, which is what we needed.
and, in fact , this is the b matrix, then.
so it has the right dimension.
and not surprisingly, we do the same thing for our c matrix.
and the reason again i wanted to show this is, this is where the jacobians come from.
so if i write dhdx, this is what i mean.
good.
let's do some examples.
so let's start with what's known as the inverted pendulum, which is a slightly more complicated pendulum where what i have is, i have a moving base, my elbow in this case.
and then i have a pendulum pointing straight up.
or with some angle, and by moving the base, the pendulum is going to swing, and in fact, it's going to fall if i don't do anything very clever.
but the dynamics of this can be written like this, where theta double dot is g over l sin theta plus u cos theta.
okay.
let's linearize this thing.
the first thing we do is we pick our stakes.
in this case it's going to be theta and theta dot.
and the reason i know that i have a 2-dimensional system is i have two dot's up here.
so, i have a 2-dimensional system, x1 is theta and x2 is theta dot.
let's say they're measuring the angles, so y is x1.
well, then i get my f to be this two vector.
and i get my h of x to be x1.
okay, fine.
let's pick the operating point where the pendulum is pointing straight up, and i'm doing nothing.
and in that case, well, what is my a matrix?
my a matrix becomes df1, dx1.
so now i have to take the derivative of this thing here, with respect to x1.
there is no x1 there, so.
the first component is zero.
then i have to take the derivative of this thing with respect to x2, which is 1. so this component is 1. similarly, i have to take the derivative of f2, with respect to x1.
so now, i have to take derivative of this guy here with respect to x1.
well, the derivative of this with respect to x1 is.
g over l times sine.
the derivative of that is going to be g over l times cosine x1.
while the derivative of this, with respect to x1 is actually going to be negative u, sine x1.
but i didn't actually write this here, even though i should have.
arguably.
because what i'm going to do is i'm going to evaluate this at the operating point.
and you know what?
u is zero.
and in fact, x1 is zero.
so this term actually goes away.
so all i'm left with is this term, evaluated at zero, zero.
and cosine zero is 1. so after all these pushups, i end up with g over l here, as the known zero term.
now, that's how you get the a matrix.
again, i would encourage you to go home, and thus your already home when you are watching this and actually perform these computations so you know where they come from.
similarly b, you have to do the same computation and in this case you have no u up here, so you don't get a u in the first component.
here you have u cosine x1.
take a derivative of that with respect to u. we get cosine x1.
we plug in the operating point, zero, zero.
and wind up with this elegant b vec-, b vector here.
c is particularly simple, right?
because h of x is x1.
which means that c is simply 1, 0. so.
that was how we would go about getting these a, b, and c matrices.
okay, lets go to the unicycle the differental drive robot that we have looked at that we saw in the previous lecture that we had a little bit of an issue with.
first of all lets figure out the state.
let's say that x1 x now i'm having in the slight abuse of n notation right because x is also the full statement.
but this is the x component, x2 is y and x3 is theta and then lets say that we're actually measuring everything.
so y is this.
okay we can control the translational velocity, or the speed and the angular velocity, right?
so my inputs would be u1 is v, and u2 is omega.
okay.
let's compute, now, the linearization around x, operating point to zero.
u, operating point is zero.
okay.
if you do that, what you actually end up with, and i'm not going to show the different steps, you should do it yourself, is first of all, an a matrix that's 0, a b matrix that looks like this, and a c matrix that's dead end to the matrix, which is not surprising since we' re measuring both the x y position and the orientation of, of the robot.
now, this is a little bit weird.
because if i write down the, the dynamics for x2.
well, x2 dot it's going to be given by the second row of everything.
well, first of all, it's zero, right?
because my a matrix is zero.
then i get zero, zero times u. so i get plus zero, zero.
i mean, times u, if you want.
but this means that x2.
is actually eqaul to zero.
well x2 was the y direction, what this means is if i'm pointing my robot straight in the x direction, then apparently i cannot actually make the car drive in the y direction.
that seems a little bit fishy actually.
what is going on here is that the linearization that we performed didn't quite capture all the nitty gritty exciting things that were going on with the non linear model.
and this is an example where the non-linearities are so severe, that the linearization as applied directly, doesn't entirely apply.
because we lost control over the y direction.
even though.
>> if i have a car, i can clearly turn it.
i can drive it and turn, and drive in the y directions.
so, here's an example where the linearization actually doesn't give us just what we wanted.
and, the punch line here is that sometimes linearizations give reasonable models, with inverted pendulum, for instance.
and, sometimes they do not, with the unicycle.
and with a unicycle we have to be a little bit more care, careful, but the fact that i want to point out though is that when they work.
when the linear stations work they are remarkably useful.
even though we're finding them around the operating points they seem to work better than what we really theoretically have reason to believe, which is why we do a lot of analysis of the linearizations rather than the non-linear models.
and then take what we learned from the linearizations and apply it to the, the non-linear models.
thank you.
