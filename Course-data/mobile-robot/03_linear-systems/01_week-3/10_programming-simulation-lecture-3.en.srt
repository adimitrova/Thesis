1
00:00:01,030 --> 00:00:02,230
Hello and welcome back.

2
00:00:02,230 --> 00:00:04,630
This is the third Programming and
Simulation lecture.

3
00:00:04,630 --> 00:00:07,120
This week I'll be talking about go-to-goal
controllers.

4
00:00:07,120 --> 00:00:12,130
These controllers are used to steer mobile
robots to, from point A to point B.

5
00:00:12,130 --> 00:00:14,314
In fact, in this week's programming
assignment

6
00:00:14,314 --> 00:00:18,020
you'll be implementing a PID based
go-to-goal controller.

7
00:00:18,020 --> 00:00:21,910
Therefore, you will need to implement the
proportional, integral, and derivative,

8
00:00:21,910 --> 00:00:26,190
derivative terms of the controller as well
as adjust the gains

9
00:00:26,190 --> 00:00:27,120
for optimal performance.

10
00:00:28,680 --> 00:00:32,310
The notation that I will use in this
week's assignment is as follows.

11
00:00:32,310 --> 00:00:35,440
First, we have the location of the robot
denoted by x and y.

12
00:00:35,440 --> 00:00:40,320
The robot also has an orientation denoted
by theta with respect to the x axis.

13
00:00:41,760 --> 00:00:47,400
The location of the goal is denoted by x_g
and y_g, and the vector between

14
00:00:47,400 --> 00:00:53,660
the goal, and the, and the position of the
robot is denoted by u_gtg.

15
00:00:53,660 --> 00:00:58,130
This vector also has an angle, theta_g,
with

16
00:00:58,130 --> 00:01:00,359
res, or with the respect to the x-axis.

17
00:01:03,260 --> 00:01:05,870
Now, this particular go-to-goal controller
that you'll

18
00:01:05,870 --> 00:01:07,742
be implementing works in the following
way.

19
00:01:07,742 --> 00:01:11,630
We're going to keep the linear velocity
constant and use

20
00:01:11,630 --> 00:01:15,170
PID to compute omega, the angle of
velocity of the

21
00:01:15,170 --> 00:01:17,830
robots, that will steer it towards the
goal, and you

22
00:01:17,830 --> 00:01:24,644
will implement this in the go-to-goal
class, defined in GoToGoal.m.

23
00:01:24,644 --> 00:01:27,730
An important part of this controller is
memory.

24
00:01:27,730 --> 00:01:28,290
We need memory

25
00:01:28,290 --> 00:01:31,320
to keep track of the previous and
accumulated error for

26
00:01:31,320 --> 00:01:35,020
the integral and the derivative terms of
the PID controller.

27
00:01:35,020 --> 00:01:38,500
The way we keep memory is through
variables in the class.

28
00:01:38,500 --> 00:01:39,480
We have two variables.

29
00:01:40,680 --> 00:01:42,450
The first is this variable right here,

30
00:01:43,840 --> 00:01:46,880
which is the total accumul, accumulated
error.

31
00:01:46,880 --> 00:01:52,380
Whereas this, whereas, whereas this
variable right here is the previous error.

32
00:01:52,380 --> 00:01:54,080
And both of these will

33
00:01:54,080 --> 00:01:57,670
be remembered at each time step so that we
can keep track and use

34
00:01:57,670 --> 00:01:59,070
them in the, when you're calculating the

35
00:01:59,070 --> 00:02:01,050
derivative and when you're calculating the
integral.

36
00:02:02,150 --> 00:02:04,370
You also should note, take note of these

37
00:02:04,370 --> 00:02:07,790
three variables up here, which correspond
to the

38
00:02:07,790 --> 00:02:11,090
proportional, integral, and derivative
gains of the controller,

39
00:02:11,090 --> 00:02:14,400
which you can adjust for the PID
controller.

40
00:02:15,830 --> 00:02:20,480
You will implement all three parts of the
PID controller in the execute function.

41
00:02:20,480 --> 00:02:24,439
This execute function is also in the
GoToGoal.m file.

42
00:02:24,439 --> 00:02:30,810
And this execute function takes in the
location of the goal,

43
00:02:32,110 --> 00:02:36,540
as well as a linear velocity and the
location and orientation of the robot.

44
00:02:37,610 --> 00:02:41,940
And computes the appropriate linear and
angular velocity, and outputs this.

45
00:02:41,940 --> 00:02:45,490
So let's take a look at the skeleton code
for this function.

46
00:02:46,780 --> 00:02:50,060
This is the skeleton code for the execute
function.

47
00:02:50,060 --> 00:02:53,390
At the top, we're retrieving the location
of the goal as well as

48
00:02:53,390 --> 00:02:54,730
the location of the robot and its

49
00:02:54,730 --> 00:02:57,390
orientation, and the design of linear
velocity.

50
00:02:58,440 --> 00:03:01,760
Then you will need to compute the heading
to the goal.

51
00:03:01,760 --> 00:03:06,370
And compute the error between the robot's
orientation and

52
00:03:06,370 --> 00:03:08,940
the orientation of the goal with respect
to the robot.

53
00:03:10,200 --> 00:03:11,930
In the last part, you need to complete the
three terms

54
00:03:11,930 --> 00:03:12,860
of PID controller.

55
00:03:12,860 --> 00:03:15,220
First, you calculate the proportional
term, then

56
00:03:15,220 --> 00:03:17,130
the integral term, and then the derivative
term.

57
00:03:17,130 --> 00:03:19,870
And then you combine all three terms along
with their

58
00:03:19,870 --> 00:03:23,225
gains to compute the appropriate angular
velocity of the robot.

59
00:03:23,225 --> 00:03:27,100
Last, the integral, the accumulated error
and the

60
00:03:27,100 --> 00:03:29,276
previous error are saved for the next time
step.

61
00:03:29,276 --> 00:03:33,840
Now, if you run this PID controller,
you're going to get something

62
00:03:33,840 --> 00:03:37,940
similar to the graph on the left, where
the red dashed line

63
00:03:37,940 --> 00:03:41,368
is the desired angle to the goal, and the
blue line,

64
00:03:41,368 --> 00:03:45,570
the blue solid line is the actual
orientation of the robot.

65
00:03:45,570 --> 00:03:47,290
And what you want to see is that the
difference

66
00:03:47,290 --> 00:03:50,164
between those two is minimized by the PID
controller.

67
00:03:50,164 --> 00:03:55,440
And the other thing you want to see is
that your gains ensure that there is very

68
00:03:55,440 --> 00:04:01,570
low overshoot and almost no osco,
oscillations in the, in the output.

69
00:04:01,570 --> 00:04:02,780
You can see there's a little bit,

70
00:04:02,780 --> 00:04:03,970
but not too much.

71
00:04:03,970 --> 00:04:09,270
And also the blue line almost perfectly
matches up the red line.

72
00:04:12,300 --> 00:04:15,380
Now, to help you test this, we've included
a stop condition

73
00:04:15,380 --> 00:04:18,300
so that the robot stops when it gets near
the goal.

74
00:04:18,300 --> 00:04:23,450
And you can adjust this goal location in
the constructor of the supervisor.

75
00:04:23,450 --> 00:04:27,640
And what you want to edit is this variable
right here, obj.goal.

76
00:04:27,640 --> 00:04:32,770
And, and, by default I have selected -1
meter in the x

77
00:04:32,770 --> 00:04:37,540
direction and 1 meter up in the y
direction, as indicated right here.

78
00:04:37,540 --> 00:04:41,690
Now, let's see this in action.
I'm going to launch the simulator.

79
00:04:43,710 --> 00:04:45,732
And this brings it up, us, to the spar
screen.

80
00:04:45,732 --> 00:04:50,330
I'm going to hit the play button and what
you should see is the graph of the

81
00:04:50,330 --> 00:04:52,480
output come up as well as the robot

82
00:04:52,480 --> 00:04:55,010
should start immediately moving towards
the goal location.

83
00:04:55,010 --> 00:04:56,240
So, let's do this.

84
00:04:58,220 --> 00:04:59,960
There's the graph.
I'm going to move it out of the way.

85
00:04:59,960 --> 00:05:09,350
And, here you can see the robot driving
towards the goal location.

86
00:05:09,350 --> 00:05:12,710
And I can click over here and look at the

87
00:05:12,710 --> 00:05:16,816
graph, and I see that the output is very
nice.

88
00:05:16,816 --> 00:05:19,516
And, if I close down the simulator, I'll

89
00:05:19,516 --> 00:05:22,366
show you that I've used fprintf statement
to

90
00:05:22,366 --> 00:05:25,066
print out the current position of the
robot

91
00:05:25,066 --> 00:05:29,040
as well as the estimated position of the
robot.

92
00:05:29,040 --> 00:05:34,410
And you should be very, very close to
stock condition stops the robot within

93
00:05:34,410 --> 00:05:39,010
5 centimeters of the goal.
So you, you should be fairly close here.

94
00:05:40,460 --> 00:05:42,970
My tips for this week are the same as last
week.

95
00:05:42,970 --> 00:05:47,760
Just make sure to read the Week 3 section
in the manual for more details.

96
00:05:47,760 --> 00:05:52,430
And, use as many fprintf statements as you
can to help

97
00:05:52,430 --> 00:05:56,060
you debug your code just like I did in the
demo.

98
00:05:56,060 --> 00:05:57,150
And, that's it for this week.