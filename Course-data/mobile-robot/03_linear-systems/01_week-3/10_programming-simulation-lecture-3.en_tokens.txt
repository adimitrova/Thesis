hello
and
welcome
back
.
this
is
the
third
programming
and
simulation
lecture
.
this
week
i
'll
be
talking
about
go-to-goal
controllers
.
these
controllers
are
used
to
steer
mobile
robots
to
,
from
point
a
to
point
b.
in
fact
,
in
this
week
's
programming
assignment
you
'll
be
implementing
a
pid
based
go-to-goal
controller
.
therefore
,
you
will
need
to
implement
the
proportional
,
integral
,
and
derivative
,
derivative
terms
of
the
controller
as
well
as
adjust
the
gains
for
optimal
performance
.
the
notation
that
i
will
use
in
this
week
's
assignment
is
as
follows
.
first
,
we
have
the
location
of
the
robot
denoted
by
x
and
y.
the
robot
also
has
an
orientation
denoted
by
theta
with
respect
to
the
x
axis
.
the
location
of
the
goal
is
denoted
by
x_g
and
y_g
,
and
the
vector
between
the
goal
,
and
the
,
and
the
position
of
the
robot
is
denoted
by
u_gtg
.
this
vector
also
has
an
angle
,
theta_g
,
with
res
,
or
with
the
respect
to
the
x-axis
.
now
,
this
particular
go-to-goal
controller
that
you
'll
be
implementing
works
in
the
following
way
.
we
're
going
to
keep
the
linear
velocity
constant
and
use
pid
to
compute
omega
,
the
angle
of
velocity
of
the
robots
,
that
will
steer
it
towards
the
goal
,
and
you
will
implement
this
in
the
go-to-goal
class
,
defined
in
gotogoal.m
.
an
important
part
of
this
controller
is
memory
.
we
need
memory
to
keep
track
of
the
previous
and
accumulated
error
for
the
integral
and
the
derivative
terms
of
the
pid
controller
.
the
way
we
keep
memory
is
through
variables
in
the
class
.
we
have
two
variables
.
the
first
is
this
variable
right
here
,
which
is
the
total
accumul
,
accumulated
error
.
whereas
this
,
whereas
,
whereas
this
variable
right
here
is
the
previous
error
.
and
both
of
these
will
be
remembered
at
each
time
step
so
that
we
can
keep
track
and
use
them
in
the
,
when
you
're
calculating
the
derivative
and
when
you
're
calculating
the
integral
.
you
also
should
note
,
take
note
of
these
three
variables
up
here
,
which
correspond
to
the
proportional
,
integral
,
and
derivative
gains
of
the
controller
,
which
you
can
adjust
for
the
pid
controller
.
you
will
implement
all
three
parts
of
the
pid
controller
in
the
execute
function
.
this
execute
function
is
also
in
the
gotogoal.m
file
.
and
this
execute
function
takes
in
the
location
of
the
goal
,
as
well
as
a
linear
velocity
and
the
location
and
orientation
of
the
robot
.
and
computes
the
appropriate
linear
and
angular
velocity
,
and
outputs
this
.
so
let
's
take
a
look
at
the
skeleton
code
for
this
function
.
this
is
the
skeleton
code
for
the
execute
function
.
at
the
top
,
we
're
retrieving
the
location
of
the
goal
as
well
as
the
location
of
the
robot
and
its
orientation
,
and
the
design
of
linear
velocity
.
then
you
will
need
to
compute
the
heading
to
the
goal
.
and
compute
the
error
between
the
robot
's
orientation
and
the
orientation
of
the
goal
with
respect
to
the
robot
.
in
the
last
part
,
you
need
to
complete
the
three
terms
of
pid
controller
.
first
,
you
calculate
the
proportional
term
,
then
the
integral
term
,
and
then
the
derivative
term
.
and
then
you
combine
all
three
terms
along
with
their
gains
to
compute
the
appropriate
angular
velocity
of
the
robot
.
last
,
the
integral
,
the
accumulated
error
and
the
previous
error
are
saved
for
the
next
time
step
.
now
,
if
you
run
this
pid
controller
,
you
're
going
to
get
something
similar
to
the
graph
on
the
left
,
where
the
red
dashed
line
is
the
desired
angle
to
the
goal
,
and
the
blue
line
,
the
blue
solid
line
is
the
actual
orientation
of
the
robot
.
and
what
you
want
to
see
is
that
the
difference
between
those
two
is
minimized
by
the
pid
controller
.
and
the
other
thing
you
want
to
see
is
that
your
gains
ensure
that
there
is
very
low
overshoot
and
almost
no
osco
,
oscillations
in
the
,
in
the
output
.
you
can
see
there
's
a
little
bit
,
but
not
too
much
.
and
also
the
blue
line
almost
perfectly
matches
up
the
red
line
.
now
,
to
help
you
test
this
,
we
've
included
a
stop
condition
so
that
the
robot
stops
when
it
gets
near
the
goal
.
and
you
can
adjust
this
goal
location
in
the
constructor
of
the
supervisor
.
and
what
you
want
to
edit
is
this
variable
right
here
,
obj.goal
.
and
,
and
,
by
default
i
have
selected
-1
meter
in
the
x
direction
and
1
meter
up
in
the
y
direction
,
as
indicated
right
here
.
now
,
let
's
see
this
in
action
.
i
'm
going
to
launch
the
simulator
.
and
this
brings
it
up
,
us
,
to
the
spar
screen
.
i
'm
going
to
hit
the
play
button
and
what
you
should
see
is
the
graph
of
the
output
come
up
as
well
as
the
robot
should
start
immediately
moving
towards
the
goal
location
.
so
,
let
's
do
this
.
there
's
the
graph
.
i
'm
going
to
move
it
out
of
the
way
.
and
,
here
you
can
see
the
robot
driving
towards
the
goal
location
.
and
i
can
click
over
here
and
look
at
the
graph
,
and
i
see
that
the
output
is
very
nice
.
and
,
if
i
close
down
the
simulator
,
i
'll
show
you
that
i
've
used
fprintf
statement
to
print
out
the
current
position
of
the
robot
as
well
as
the
estimated
position
of
the
robot
.
and
you
should
be
very
,
very
close
to
stock
condition
stops
the
robot
within
5
centimeters
of
the
goal
.
so
you
,
you
should
be
fairly
close
here
.
my
tips
for
this
week
are
the
same
as
last
week
.
just
make
sure
to
read
the
week
3
section
in
the
manual
for
more
details
.
and
,
use
as
many
fprintf
statements
as
you
can
to
help
you
debug
your
code
just
like
i
did
in
the
demo
.
and
,
that
's
it
for
this
week
.
