so
now
we
know
not
only
that
the
first
order
business
is
to
make
the
system
stable
meaning
it
should
n't
blow
up
,
it
should
behave
well
,
but
we
also
know
what
this
means
,
namely
that
the
eigen
values
of
the
system
should
have
negative
real
part
and
even
though
we
saw
some
critically
stable
cases
last
time
.
including
a
rather
awesome
,
set
of
robots
slamming
into
each
other
.
we
typically
do
n't
want
critical
stability
.
we
want
asymptotic
stability
.
which
means
that
we
need
to
have
strictly
negative
real
part
of
all
the
eigenvalues
here
.
and
today
,
we
're
going
to
actually
achieve
that
,
or
try
to
achieve
it
,
by
designing
a
controller
.
because
remember
this
picture
.
,
speaker
:
we
have
our
system
,
x
dot
is
ax
plus
bu
where
u
is
the
input
,
and
then
y
is
equal
to
cx
.
so
,
whatever
we
do
to
our
control
choice
has
to
depend
on
the
things
that
we
have
access
to
,
which
is
why
we
do
n't
know
the
state
of
the
system
.
but
,
we
certainly
know
the
output
.
so
,
today
we
're
going
to
try
something
called
'output
feedback
,
'
which
means
we
're
going
to
take
the
output
of
the
system
.
and
use
it
to
feed
directly
back
in
as
a
way
of
controlling
it
.
and
we
're
going
to
start
by
returning
to
our
old
friend
,
the
world
's
simplest
robot
,
which
is
just
a
point
on
a
line
that
we
can
control
the
acceleration
of
and
,
as
you
hopefully
recall
,
we
can
write
this
in
state
space
form
as
x
dot
is
.
this
a
matrix
,
0100x
.
plus
a
b
matrix
that
's
01.
and
then
,
the
output
is
10x
.
this
means
that
the
output
is
the
position
of
the
point
mass
.
and
x1
,
the
first
component
of
x
is
the
position
.
the
second
component
of
x
is
.
the
velocity
and
then
u
immediately
gives
us
the
,
the
acceleration
.
so
now
our
job
is
to
somehow
connect
y
to
u
meaning
pick
our
input
in
such
a
way
that
this
system
behaviors
and
in
fact
here
is
an
idea
,
we
want
to
drive
.
the
system
to
zero
,
which
means
stabilize
it
.
so
,
why
do
n't
we
move
towards
the
origin
?
meaning
,
the
position
of
the
robot
is
what
it
is
.
and
let
's
say
that
,
here
is
the
origin
.
and
our
job
is
to
drive
it
to
the
origin
.
so
if
the
position
is
negative
.
meaning
we
're
on
the
left
on
the
origin
.
we
should
probably
move
in
this
direction
.
if
the
.
robot
is
over
there
,
we
should
move
it
to
the
left
,
which
is
in
a
negative
direction
.
so
that
's
a
very
,
very
simple
idea
.
and
in
fact
if
we
turn
it
into
math
,
we
see
that
if
y
is
negative
,
so
y
negative
again
,
corresponds
if
the
origin
is
here
,
us
being
on
this
side
,
then
u
should
be
positive
,
which
means
moving
this
.
direction
,
and
similarly
if
y
is
positive
than
u
should
be
negative
.
and
here
's
some
suggestion
.
right
.
let
's
pick
the
world
's
simplest
controller
that
achieves
this
.
simply
,
the
negative
of
y.
so
y
positive
means
negative
u
,
y
negative
means
positive
u.
u.
so
let
's
try
this
,
and
see
what
it
actually
does
.
and
what
we
need
to
do
first
is
understand
.
how
does
this
change
the
system
dynamics
?
because
what
we
really
did
now
,
is
,
we
had
u
equal
to
well
,
we
had
minus
y.
so
k
,
in
our
example
,
was
just
a1
.
but
in
general
,
k
here
could
be
.
it
's
a
more
rich
structure
,
and
if
used
in
the
y
's
or
multidimensional
,
then
this
needs
to
be
a
vector
.
now
,
we
know
that
y
is
equal
to
c
times
x
,
so
we
can
write
this
as
u
being
equal
to
negative
kcx
.
so
,
now
let
's
plug
this
into
our
differential
equation
that
we
have
.
so
,
x
dot
is
ax
plus
bu
,
and
now
instead
of
u.
we
're
plugging
in
this
term
right
.
so
then
we
get
a
minus
bkcx
or
if
you
plug
everything
together
,
we
get
a
minus
bkcx
.
and
this
,
we
can
write
if
you
want
to
as
a
hat
times
x.
so
this
is
just
a
new
system
matrix
and
of
course
our
job
is
to
pick
k
now
so
that
's
the
real
part
of
the
eigenvalues
of
a
hat
is
strictly
negative
.
in
other
words
,
pick
if
possible
k
such
that
the
real
part
of
lambda
is
strictly
negative
for
all
lambda
that
is
,
that
is
an
eigenvalue
to
this
new
system
matrix
a
minus
bkc
.
so
that
's
really
our
,
our
job
here
and
in
a
way
already
picked
k
,
we
said
k
was
equal
to
one
.
well
let
's
see
what
's
happening
if
that
's
the
case
,
then
we
have
x
dot
is
,
this
is
a
,
this
is
b
,
this
is
k
a
nd
this
is
c.
so
this
is
what
we
have
in
terms
of
the
.
the
system
matrix
for
our
,
robot
.
and
one
thing
to
note
,
first
of
all
.
that
1
times
1
,
0
is
just
1
,
0.
and
if
i
multiply
this
by
0
,
1
,
then
i
get
,
what
do
i
get
?
i
get
0
times
1
,
then
0
times
0
1
times
1.
and
0
times
1.
so
this
is
what
this
whole
expression
is
equal
to
.
so
now
i
can
just
take
this
matrix
,
and
subtract
away
this
matrix
to
get
the
,
the
right
answer
.
and
if
i
do
that
,
i
get
x.
is
0
,
1
,
negative
1
,
0
,
x.
and
this
is
for
my
particular
choice
of
k.
and
let
's
check
out
what
,
what
the
eigenvalues
are
of
this
thing
.
well
,
you
write
eig
in
matlab
and
you
get
the
answer
.
or
,
as
we
will
see
in
future
lectures
,
you
can
actually
compute
it
and
,
and
say
something
about
the
clever
choice
of
k
in
that
way
.
but
,
for
now
,
we
're
just
going
to
immediately
plug
this
into
our
favorite
software
system
,
and
we
find
out
that
the
eigenvalues
are
plus
and
minus
j.
where
j
is
square
root
to
negative
1.
so
is
this
system
asymptotically
stable
?
well
,
the
real
part
of
lamda
for
both
lamdas
so
we
have
two
lamdas
.
the
real
part
is
zero
,
because
this
is
a
purely
imaginary
system
.
and
,
as
i
said
last
time
,
if
i
have
two
.
imaginary
eigenvalues
and
all
the
others
are
well
behaved
,
in
this
case
i
do
n't
have
any
others
,
then
i
have
a
critically
stable
system
.
and
in
fact
since
i
have
imaginary
components
,
we
have
already
hinted
at
this
that
what
we
actually
end
up
with
are
oscillations
.
so
this
is
a
critically
stable
system
and
if
i
simulate
with
this
role
,
what
it
's
doing
,
it
's
going
to
look
like
this
.
really
what
's
happening
is
this
thing
is
just
going
back
and
forth
,
back
and
forth
.
so
,
what
's
the
problem
?
we
clearly
did
not
stabilize
it
,
we
know
it
's
not
asymptotically
stable
in
fact
it
's
just
going
back
and
forth
back
and
forth
well
here
is
the
problem
,
when
the
robot
is
let
's
say
on
it
's
way
.
away
from
the
origin
,
then
we
're
pushing
it
,
correctly
so
,
towards
the
origin
.
but
when
it
's
on
it
's
way
back
,
we
're
still
pushing
it
equally
hard
,
even
thou
gh
it
's
actually
going
there
almost
by
itself
.
so
,
we
're
kind
of
not
taking
the
direction
in
which
the
robot
is
going
.
into
account
.
what
this
actually
means
is
that
we
are
not
looking
at
the
velocity
because
the
velocity
is
going
to
tell
you
which
direction
it
is
going
in
.
so
the
problem
is
that
we
do
not
take
velocity
into
account
.
remember
what
the
state
is
?
the
state
is
position
and
velocity
.
so
the
problem
is
that
we
need
all
of
it
to
stabilize
and
we
need
the
full
state
information
not
just
the
output
.
so
output
feedback
like
this
does
n't
quiet
work
,
but
instead
we
want
to
operate
on
x
instead
of
y.
but
here
of
course
is
the
problem
.
how
do
we
do
that
?
and
the
corollary
to
that
is
,
we
do
n't
even
know
x.
we
only
know
y.
how
in
the
world
can
we
design
controllers
for
things
that
we
do
n't
know
?
well
,
as
we
will
see
in
the
next
module
,
it
's
possible
to
figure
out
x
from
y
a
lot
of
times
.
if
you
just
think
of
y
in
this
case
as
being
the
position
and
x
being
y
,
as
x
being
position
in
velocity
.
then
velocity
,
right
,
we
can
get
by
measuring
two
positions
after
each
other
,
and
dividing
it
by
the
time
in
between
the
measurements
.
then
we
get
an
estimate
of
the
velocity
.
so
,
it
's
clearly
possible
in
this
case
to
at
least
get
an
estimate
of
state
from
the
,
the
from
the
output
.
so
like
i
said
this
is
the
next
module
but
in
the
next
lecture
which
is
the
last
lecture
of
this
module
will
pretend
that
we
actually
have
x
and
revisits
the
world
's
simplest
robot
and
see
how
can
we
actually
stabilize
it
if
we
have
all
of
x
and
not
just
y
.
